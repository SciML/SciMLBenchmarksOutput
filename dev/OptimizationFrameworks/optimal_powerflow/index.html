<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Powerflow Nonlinear Optimization Benchmark · The SciML Benchmarks</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://benchmarks.sciml.ai/stable/OptimizationFrameworks/optimal_powerflow/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="The SciML Benchmarks logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Benchmarks</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLBenchmarks.jl: Benchmarks for Scientific Machine Learning (SciML) and Equation Solvers</a></li><li><span class="tocitem">Multi-Language Wrapper Benchmarks</span><ul><li><a class="tocitem" href="../../MultiLanguage/ode_wrapper_packages/">ODE Solver Multi-Language Wrapper Package Work-Precision Benchmarks (MATLAB, SciPy, Julia, deSolve (R))</a></li><li><a class="tocitem" href="../../MultiLanguage/special_benchmarks/">Special Multi-Language Differential Equation Solver Comparison Benchmarks</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../../LinearSolve/LUFactorization/">LU Factorization Benchmarks</a></li><li><a class="tocitem" href="../../LinearSolve/MatrixDepot/">Suite Sparse Matrix Jacobian Factorization Benchmarks</a></li><li><a class="tocitem" href="../../LinearSolve/SparsePDE/">Finite Difference Sparse PDE Jacobian Factorization Benchmarks</a></li></ul></li><li><span class="tocitem">Interval Rootfinding</span><ul><li><a class="tocitem" href="../../IntervalNonlinearProblem/simpleintervalrootfind/">Simple Interval Rootfinding (NonlinearSolve.jl vs Roots.jl vs MATLAB)</a></li></ul></li><li><span class="tocitem">Nonlinear Solvers</span><ul><li><a class="tocitem" href="../../NonlinearProblem/bruss/">Ill-Conditioned Nonlinear System Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonlinearProblem/nonlinear_battery_problem/">Doyle-Fuller-Newman (DFN) Battery Model Initialization</a></li><li><a class="tocitem" href="../../NonlinearProblem/nonlinear_solver_23_tests/">Nonlinear Solver 23 Test Problems</a></li><li><a class="tocitem" href="../../NonlinearProblem/quadratic_nonlinear/">Quadratic Nonlinear Rootfinding Benchmark</a></li></ul></li><li><span class="tocitem">Automatic Differentiation</span><ul><li><a class="tocitem" href="../../AutomaticDifferentiation/BrussScaling/">Bruss Scaling PDE Differentaition Benchmarks</a></li><li><a class="tocitem" href="../../AutomaticDifferentiation/JuliaAD/">Julia AD Benchmarks</a></li><li><a class="tocitem" href="../../AutomaticDifferentiation/SimpleODEAD/">Differentiation of Simple ODE Benchmarks</a></li></ul></li><li><span class="tocitem">Sparse Automatic Differentiation</span><ul><li><a class="tocitem" href="../../AutomaticDifferentiationSparse/BrusselatorSparseAD/">Brusselator sparse AD benchmarks</a></li><li><a class="tocitem" href="../../AutomaticDifferentiationSparse/ManualLoopDissusionSparseAD/">Diffusion operator loop sparse AD benchmarks</a></li></ul></li><li><span class="tocitem">Non-Stiff Ordinary Differential Equations (ODEs)</span><ul><li><a class="tocitem" href="../../NonStiffODE/FitzhughNagumo_wpd/">Fitzhugh-Nagumo Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/LotkaVolterra_wpd/">Lotka-Volterra Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/Pleiades_wpd/">Pleiades Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/RigidBody_wpd/">Rigid Body Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/ThreeBody_wpd/">Three Body Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/linear_wpd/">100 Independent Linear Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Ordinary Differential Equations (ODEs)</span><ul><li><a class="tocitem" href="../../StiffODE/Bruss/">Brusselator Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Hires/">HIRES Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Orego/">OREGO Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Pollution/">POLLU Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/ROBER/">ROBER Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/VanDerPol/">VanDerPol Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Biological Differential Equations</span><ul><li><a class="tocitem" href="../../Bio/BCR/">BCR Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/Bidkhori2012/">Bidkhori2012 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/egfr_net/">Egfr_net Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/fceri_gamma2/">Fceri_gamma2 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/multisite2/">Multisite2 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/multistate/">Multistate Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Astrochemistry Differential Equations</span><ul><li><a class="tocitem" href="../../AstroChem/astrochem/">AstroChem Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../AstroChem/nelson/">Nelson Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Differential-Algebraic Equations (DAEs)</span><ul><li><a class="tocitem" href="../../DAE/ChemicalAkzoNobel/">Chemical Akzo Nobel Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../DAE/OregoDAE/">OREGO Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../DAE/ROBERDAE/">ROBER Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../DAE/TransistorAmplifier/">Transistor Amplifier, DAE format</a></li></ul></li><li><span class="tocitem">Non-Stiff Boundary Value Problems (BVPs)</span><ul><li><a class="tocitem" href="../../NonStiffBVP/linear_wpd/">Linear BVP Benchmarks</a></li><li><a class="tocitem" href="../../NonStiffBVP/orbital/">Orbital Dynamics BVP Benchmark</a></li></ul></li><li><span class="tocitem">Stiff Boundary Value Problems (BVPs)</span><ul><li><a class="tocitem" href="../../StiffBVP/ionic_liquid_dehumidifier/">Ionic Liquid Dehumidifier Benchmarks</a></li></ul></li><li><span class="tocitem">ModelingToolkit Acausal Modeling / Symbolic-Numeric Benchmarks</span><ul><li><a class="tocitem" href="../../ModelingToolkit/Multibody_Robot/">Multibody Robot, compilation and simulation performance</a></li><li><a class="tocitem" href="../../ModelingToolkit/RCCircuit/">RC Circuit</a></li><li><a class="tocitem" href="../../ModelingToolkit/ThermalFluid/">Thermal Fluid ODE Compilation and Perf</a></li></ul></li><li><span class="tocitem">Simple Handwritten Partial Differential Equations (PDEs) as ODEs</span><ul><li><a class="tocitem" href="../../SimpleHandwrittenPDE/allen_cahn_fdm_wpd/">Allen_Cahn FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/allen_cahn_spectral_wpd/">Allen-Cahn Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/burgers_fdm_wpd/">Burgers FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/burgers_spectral_wpd/">Burgers Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/kdv_fdm_wpd/">KdV FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/kdv_spectral_wpd/">KdV Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/ks_fdm_wpd/">KS FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/ks_spectral_wpd/">KS Pseudospectral Methods Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Complicated Partial Differential Equations (PDEs)</span><ul><li><a class="tocitem" href="../../ComplicatedPDE/Filament/">Filament Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../ComplicatedPDE/SpringBlockNonLinearResistance/">Spring-Block PDE Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Dynamical ODEs (Hamiltonian and Second Order)</span><ul><li><a class="tocitem" href="../../DynamicalODE/Henon-Heiles_energy_conservation_benchmark/">Hénon-Heiles Energy Conservation</a></li><li><a class="tocitem" href="../../DynamicalODE/Quadrupole_boson_Hamiltonian_energy_conservation_benchmark/">Quadruple Boson Energy Conservation</a></li><li><a class="tocitem" href="../../DynamicalODE/single_pendulums/">Single Pedulum Comparison</a></li></ul></li><li><span class="tocitem">N-Body Problem Benchmarks</span><ul><li><a class="tocitem" href="../../NBodySimulator/acceleration_functions/">Acceleration function benchmarks</a></li><li><a class="tocitem" href="../../NBodySimulator/liquid_argon/">Liquid argon benchmarks</a></li></ul></li><li><span class="tocitem">Non-Stiff Stochastic Differential Equations (SDEs)</span><ul><li><a class="tocitem" href="../../NonStiffSDE/BasicSDEWeakWorkPrecision/">SDE Basic Weak Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffSDE/BasicSDEWorkPrecision/">SDE Basic Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Stochastic Differential Equations (SDEs)</span><ul><li><a class="tocitem" href="../../StiffSDE/Oval2LongRun/">Oval2 Long Run</a></li><li><a class="tocitem" href="../../StiffSDE/Oval2LongTimes/">Oval2 Long Times</a></li><li><a class="tocitem" href="../../StiffSDE/Oval2Timings/">Oval2 Timings</a></li><li><a class="tocitem" href="../../StiffSDE/QuadraticStiffness/">Quadratic Stiffness Benchmarks</a></li><li><a class="tocitem" href="../../StiffSDE/StochasticHeat/">Stochastic Heat Equation Benchmarks</a></li></ul></li><li><span class="tocitem">Non-Stiff Delay Differential Equations (DDEs)</span><ul><li><a class="tocitem" href="../../NonStiffDDE/Mackey_Glass_wpd/">Mackey and Glass Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffDDE/Wheldon_Kirk_Finlay_wpd/">Wheldon, Kirk, and Finlay Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Delay Differential equations (DDEs)</span><ul><li><a class="tocitem" href="../../StiffDDE/QuorumSensing/">Quorum Sensing Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Jump Process Equations (Gillespie Benchmarks)</span><ul><li><a class="tocitem" href="../../Jumps/Diffusion_CTRW/">Diffusion Model</a></li><li><a class="tocitem" href="../../Jumps/Mendes_multistate_example/">Mendes Multistate Model</a></li><li><a class="tocitem" href="../../Jumps/MultivariateHawkes/">Multivariate Hawkes Model</a></li><li><a class="tocitem" href="../../Jumps/NegFeedback_GeneExpr/">Negative Feedback Gene Expression Model</a></li><li><a class="tocitem" href="../../Jumps/NegFeedback_GeneExpr_Marchetti/">Negative Feedback Marchetti Model</a></li><li><a class="tocitem" href="../../Jumps/Spatial_Signaling_Sanft/">Spatial Signaling Model from Sanft and Othmer (2015)</a></li></ul></li><li><span class="tocitem">Hybrid (Time-Dependent) Jump Processes</span><ul><li><a class="tocitem" href="../../HybridJumps/Synapse/">Synapse model</a></li></ul></li><li><span class="tocitem">Nonlinear Optimization Solver Benchmarks</span><ul><li><a class="tocitem" href="../../Optimizaton/2drosenbrock/">2-Dimensional Rosenbrock Function Nonlinear Optimization Benchmark</a></li></ul></li><li><span class="tocitem">Optimization Framework Benchmarks</span><ul><li><a class="tocitem" href="../clnlbeam/">CLNLBEAM Nonlinear Optimization Benchmark</a></li><li class="is-active"><a class="tocitem" href>Optimal Powerflow Nonlinear Optimization Benchmark</a><ul class="internal"><li><a class="tocitem" href="#Data-Load-and-Setup-Code"><span>Data Load and Setup Code</span></a></li><li><a class="tocitem" href="#Test-Setup"><span>Test Setup</span></a></li><li><a class="tocitem" href="#Setup-and-Validations"><span>Setup and Validations</span></a></li><li><a class="tocitem" href="#ModelingToolkit.jl"><span>ModelingToolkit.jl</span></a></li><li><a class="tocitem" href="#JuMP.jl"><span>JuMP.jl</span></a></li><li><a class="tocitem" href="#NLPModels.jl"><span>NLPModels.jl</span></a></li><li><a class="tocitem" href="#Nonconvex"><span>Nonconvex</span></a></li><li><a class="tocitem" href="#Optim.jl"><span>Optim.jl</span></a></li><li><a class="tocitem" href="#CASADI"><span>CASADI</span></a></li><li><a class="tocitem" href="#Test-the-Benchmarking"><span>Test the Benchmarking</span></a></li><li><a class="tocitem" href="#Run-the-Full-Benchmark"><span>Run the Full Benchmark</span></a></li><li><a class="tocitem" href="#Appendix"><span>Appendix</span></a></li></ul></li></ul></li><li><span class="tocitem">Parameter Estimation and Inverse Problem Benchmarks</span><ul><li><a class="tocitem" href="../../ParameterEstimation/FitzHughNagumoParameterEstimation/">FitzHugh-Nagumo Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../ParameterEstimation/LorenzParameterEstimation/">Lorenz Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../ParameterEstimation/LotkaVolterraParameterEstimation/">Lotka-Volterra Parameter Estimation Benchmarks</a></li></ul></li><li><span class="tocitem">Bayesian Inference and Probabilistic Inverse Problem Benchmarks</span><ul><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesFitzHughNagumo/">Fitzhugh-Nagumo Bayesian Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesLorenz/">Lorenz Bayesian Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesLotkaVolterra/">Lotka-Volterra Bayesian Parameter Estimation Benchmarks</a></li></ul></li><li><span class="tocitem">MethodOfLines.jl Partial Differential Equation (PDE) Formulations</span><ul><li><a class="tocitem" href="../../MethodOfLinesPDE/MOL_fdm/">Burgers FDM Work-Precision Diagrams with Various MethodOfLines Methods</a></li></ul></li><li><span class="tocitem">Physics-Informed Neural Network (Neural Network PDE Solver) Cost Function Benchmarks</span><ul><li><a class="tocitem" href="../../PINNErrorsVsTime/allen_cahn_et/">Allen-Cahn PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/diffusion_et/">Diffusion PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/hamilton_jacobi_et/">Hamilton-Jacobi PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/level_set_et/">Level Set PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/nernst_planck_et/">Nernst-Planck PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li></ul></li><li><span class="tocitem">Physics-Informed Neural Network (Neural Network PDE Solver) Optimizer Benchmarks</span><ul><li><a class="tocitem" href="../../PINNOptimizers/1d_diffusion/">Diffusion Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/1d_poisson_nernst_planck/">Nernst-Planck Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/allen_cahn/">Allen-Cahn Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/burgers_equation/">Berger&#39;s Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/hamilton_jacobi/">Hamilton-Jacobi PDE Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/poisson/">Poisson PDE Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li></ul></li><li><span class="tocitem">SDE Adaptivity Benchmarks</span><ul><li><a class="tocitem" href="../../AdaptiveSDE/AdaptiveEfficiencyTests/">Adaptive Efficiency Tests</a></li><li><a class="tocitem" href="../../AdaptiveSDE/qmaxDetermination/">qmax Determination</a></li></ul></li><li><span class="tocitem">Surrogate Benchmarks</span><ul><li><a class="tocitem" href="../../Surrogates/tensor_product/">Tensor Product Function</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization Framework Benchmarks</a></li><li class="is-active"><a href>Optimal Powerflow Nonlinear Optimization Benchmark</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal Powerflow Nonlinear Optimization Benchmark</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLBenchmarksOutput/blob/main/docs/src/OptimizationFrameworks/optimal_powerflow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimal-Powerflow-Nonlinear-Optimization-Benchmark"><a class="docs-heading-anchor" href="#Optimal-Powerflow-Nonlinear-Optimization-Benchmark">Optimal Powerflow Nonlinear Optimization Benchmark</a><a id="Optimal-Powerflow-Nonlinear-Optimization-Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Powerflow-Nonlinear-Optimization-Benchmark" title="Permalink"></a></h1><h2 id="Data-Load-and-Setup-Code"><a class="docs-heading-anchor" href="#Data-Load-and-Setup-Code">Data Load and Setup Code</a><a id="Data-Load-and-Setup-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Load-and-Setup-Code" title="Permalink"></a></h2><p>This is generic setup code usable for all solver setups. Basically removing some unnecessary untyped dictionaries before getting to the benchmarks.</p><pre><code class="language-julia hljs">PRINT_LEVEL = 0

# This is a soft upper limit to the time of each optimization.
# If times go above this, they will halt early
MAX_CPU_TIME = 100.0

# Maximum number of variables in an optimization problem for the benchmark
# Anything with more variables is rejected and not run
# This is for testing. 100 is a good size for running a test of changes
# Should be set to typemax(Int) to run the whole benchmark
SIZE_LIMIT = 1000</code></pre><pre><code class="nohighlight hljs">1000</code></pre><pre><code class="language-julia hljs">import PowerModels
import ConcreteStructs
using BenchmarkTools
using DataFrames

ConcreteStructs.@concrete struct DataRepresentation
    data
    ref
    var_lookup
    var_init
    var_lb
    var_ub
    ref_gen_idxs
    lookup_pg
    lookup_qg
    lookup_va
    lookup_vm
    lookup_lij
    lookup_p_lij
    lookup_q_lij
    cost_arrs
    f_bus
    t_bus
    ref_bus_idxs
    ref_buses_idxs
    ref_bus_gens
    ref_bus_arcs
    ref_branch_idxs
    ref_arcs_from
    ref_arcs_to
    p_idxmap
    q_idxmap
    bus_pd
    bus_qd
    bus_gs
    bus_bs
    br_g
    br_b
    br_tr
    br_ti
    br_ttm
    br_g_fr
    br_b_fr
    br_g_to
    br_b_to
end

function load_and_setup_data(file_name)
    data = PowerModels.parse_file(file_name)
    PowerModels.standardize_cost_terms!(data, order=2)
    PowerModels.calc_thermal_limits!(data)
    ref = PowerModels.build_ref(data)[:it][:pm][:nw][0]

    # Some data munging to type-stable forms

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        push!(var_init, 0.0) #pg
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #qg
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1

    ref_gen_idxs = [i for i in keys(ref[:gen])]
    lookup_pg = Dict{Int,Int}()
    lookup_qg = Dict{Int,Int}()
    lookup_va = Dict{Int,Int}()
    lookup_vm = Dict{Int,Int}()
    lookup_lij = Tuple{Int,Int,Int}[]
    lookup_p_lij = Int[]
    lookup_q_lij = Int[]
    cost_arrs = Dict{Int,Vector{Float64}}()

    for (i,gen) in ref[:gen]
        lookup_pg[i] = var_lookup[&quot;pg_$(i)&quot;]
        lookup_qg[i] = var_lookup[&quot;qg_$(i)&quot;]
        cost_arrs[i] = gen[&quot;cost&quot;]
    end

    for (i,bus) in ref[:bus]
        lookup_va[i] = var_lookup[&quot;va_$(i)&quot;]
        lookup_vm[i] = var_lookup[&quot;vm_$(i)&quot;]
    end

    for (l,i,j) in ref[:arcs]
        push!(lookup_lij, (l,i,j))
        push!(lookup_p_lij,var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;])
        push!(lookup_q_lij,var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;])
    end

    f_bus = Dict{Int,Int}()
    t_bus = Dict{Int,Int}()

    for (l,branch) in ref[:branch]
        f_bus[l] = branch[&quot;f_bus&quot;]
        t_bus[l] = branch[&quot;t_bus&quot;]
    end

    ref_bus_idxs = [i for i in keys(ref[:bus])]
    ref_buses_idxs = [i for i in keys(ref[:ref_buses])]
    ref_bus_gens = ref[:bus_gens]
    ref_bus_arcs = ref[:bus_arcs]
    ref_branch_idxs = [i for i in keys(ref[:branch])]
    ref_arcs_from = ref[:arcs_from]
    ref_arcs_to = ref[:arcs_to]

    p_idxmap = Dict(lookup_lij[i] =&gt; lookup_p_lij[i] for i in 1:length(lookup_lij))
    q_idxmap = Dict(lookup_lij[i] =&gt; lookup_q_lij[i] for i in 1:length(lookup_lij))

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    DataRepresentation(
        data,
        ref,
        var_lookup,
        var_init,
        var_lb,
        var_ub,
        ref_gen_idxs,
        lookup_pg,
        lookup_qg,
        lookup_va,
        lookup_vm,
        lookup_lij,
        lookup_p_lij,
        lookup_q_lij,
        cost_arrs,
        f_bus,
        t_bus,
        ref_bus_idxs,
        ref_buses_idxs,
        ref_bus_gens,
        ref_bus_arcs,
        ref_branch_idxs,
        ref_arcs_from,
        ref_arcs_to,
        p_idxmap,
        q_idxmap,
        bus_pd,
        bus_qd,
        bus_gs,
        bus_bs,
        br_g,
        br_b,
        br_tr,
        br_ti,
        br_ttm,
        br_g_fr,
        br_b_fr,
        br_g_to,
        br_b_to)
end

file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><h2 id="Test-Setup"><a class="docs-heading-anchor" href="#Test-Setup">Test Setup</a><a id="Test-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Setup" title="Permalink"></a></h2><p>Ensure that all objectives and constraints evaluate to the same value on a feasible point in the same dataset</p><pre><code class="language-julia hljs">test_u0 = [0.062436387733897314, 1.0711076238965598, 0.0, 1.066509799068872, -0.023231313776594726, 1.0879315976617783, -0.033094993289919016, 1.0999999581285527, 0.07121718642320936, 1.094374845084077, 0.4228458440068076, -3.7102746662566277, 1.8046846767604458e-8, -0.44810504067067086, 8.80063717152151, -0.0, 0.8709675496332583, 3.6803022758556523, -0.0, 4.618897246588245, -1.1691336178031877, 1.3748418519024668, 0.9623014391707738, -1.3174990482204871, -2.3850868109149004, 0.1445158405684026, 2.813869610747349, 0.8151138880859179, 1.9869253829584679, 3.768252275480421, 3.9998421778156934, 0.03553108302190666, 1.177155791026922, -1.3025310027752557, -0.9598988325635542, 1.3193604239530325, 2.399997991458022, -0.003103523654225171, -2.7920689620650667, -0.6047898784636468, -1.9771521474512397, -3.7071711426024025, -3.9623014391707136, 0.3313990482205271]
test_obj = 16236.704322376236
test_cons = [0.0, 2.5424107263916085e-14, -1.0835776720341528e-13, -6.039613253960852e-14, 0.0, 0.0, 0.0, -1.7075230118734908e-13, -3.9968028886505635e-14, 1.532107773982716e-13, 0.0, 6.661338147750939e-16, -1.7763568394002505e-15, 0.0, 8.881784197001252e-16, 4.440892098500626e-16, 0.0, 4.440892098500626e-16, -1.7763568394002505e-15, -8.881784197001252e-16, -4.440892098500626e-16, 2.220446049250313e-16, 0.0, 1.7763568394002505e-15, 0.0, 6.8833827526759706e-15, -8.992806499463768e-15, 3.9968028886505635e-14, -7.105427357601002e-15, 0.0, 0.0, 7.327471962526033e-15, -7.105427357601002e-15, 2.842170943040401e-14, -7.105427357601002e-15, -0.033094993289919016, 0.00986367951332429, -0.062436387733897314, 0.07121718642320936, 0.008780798689312044, 0.09444850019980408, 3.2570635340201743, 2.661827801892032, 5.709523923775402, 8.58227283683798, 18.147597689108025, 15.999999905294098, 3.0822827695389314, 2.6621176970504, 5.759999990861611, 8.161419886019171, 17.65224849471505, 15.80965802401578]</code></pre><pre><code class="nohighlight hljs">53-element Vector{Float64}:
  0.0
  2.5424107263916085e-14
 -1.0835776720341528e-13
 -6.039613253960852e-14
  0.0
  0.0
  0.0
 -1.7075230118734908e-13
 -3.9968028886505635e-14
  1.532107773982716e-13
  ⋮
  8.58227283683798
 18.147597689108025
 15.999999905294098
  3.0822827695389314
  2.6621176970504
  5.759999990861611
  8.161419886019171
 17.65224849471505
 15.80965802401578</code></pre><h2 id="Setup-and-Validations"><a class="docs-heading-anchor" href="#Setup-and-Validations">Setup and Validations</a><a id="Setup-and-Validations-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-Validations" title="Permalink"></a></h2><p>Now is the setup code for each optimization framework, along with the validation runs on the test case. Any test which fails the validation case, i.e. has <code>x_test_res[1] !≈ test_obj</code> or <code>x_test_res[2] !≈ test_cons</code> should be considered invalidated as this means that the model in that modeling platform does not evaluate to give the same results</p><h3 id="Optimization.jl"><a class="docs-heading-anchor" href="#Optimization.jl">Optimization.jl</a><a id="Optimization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization.jl" title="Permalink"></a></h3><p>Constraint optimization implementation reference: https://github.com/SciML/Optimization.jl/blob/master/lib/OptimizationMOI/test/runtests.jl Other AD libraries can be considered: https://docs.sciml.ai/dev/modules/Optimization/API/optimization_function/</p><pre><code class="language-julia hljs">import Optimization
import OptimizationMOI
import ModelingToolkit
import Ipopt
import Enzyme
import ReverseDiff

function build_opf_optimization_prob(dataset; adchoice = Optimization.AutoEnzyme())
    (;data,
    ref,
    var_lookup,
    var_init,
    var_lb,
    var_ub,
    ref_gen_idxs,
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij,
    cost_arrs,
    f_bus,
    t_bus,
    ref_bus_idxs,
    ref_buses_idxs,
    ref_bus_gens,
    ref_bus_arcs,
    ref_branch_idxs,
    ref_arcs_from,
    ref_arcs_to,
    p_idxmap,
    q_idxmap,
    bus_pd,
    bus_qd,
    bus_gs,
    bus_bs,
    br_g,
    br_b,
    br_tr,
    br_ti,
    br_ttm,
    br_g_fr,
    br_b_fr,
    br_g_to,
    br_b_to) = dataset

    #total_callback_time = 0.0
    function opf_objective(x, param)
        #start = time()
        cost = 0.0
        for i in ref_gen_idxs
            pg = x[lookup_pg[i]]
            _cost_arr = cost_arrs[i]
            cost += _cost_arr[1]*pg^2 + _cost_arr[2]*pg + _cost_arr[3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints(ret, x, param)
        offsetidx = 0

        # va_con
        for (reti,i) in enumerate(ref_buses_idxs)
            ret[reti + offsetidx] = x[lookup_va[i]]
        end

        offsetidx += length(ref_buses_idxs)
        
        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref_bus_gens[i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*x[lookup_vm[i]]^2
        #     )

        # power_balance_p_con
        for (reti,i) in enumerate(ref_bus_idxs)
            ret[reti + offsetidx] = sum(x[lookup_pg[j]] for j in ref_bus_gens[i]; init=0.0) -
            bus_pd[i] -
            bus_gs[i]*x[lookup_vm[i]]^2 -
            sum(x[p_idxmap[a]] for a in ref_bus_arcs[i])
        end

        offsetidx += length(ref_bus_idxs)

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(x[lookup_qg[g]] for g in ref_bus_gens[i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*x[lookup_vm[i]]^2
        #     )
        # power_balance_q_con
        for (reti,i) in enumerate(ref_bus_idxs)
        ret[reti + offsetidx] = sum(x[lookup_qg[j]] for j in ref_bus_gens[i]; init=0.0) -
        bus_qd[i] +
        bus_bs[i]*x[lookup_vm[i]]^2 -
        sum(x[q_idxmap[a]] for a in ref_bus_arcs[i])
        end

        offsetidx += length(ref_bus_idxs)

        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        # power_flow_p_from_con =
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = (br_g[l]+br_g_fr[l])/br_ttm[l]*x[lookup_vm[f_bus[l]]]^2 +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*cos(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) +
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*sin(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) -
        x[p_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_from)

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        # power_flow_p_to_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = (br_g[l]+br_g_to[l])*x[lookup_vm[t_bus[l]]]^2 +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*cos(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) +
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*sin(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) -
        x[p_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_to)

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        # power_flow_q_from_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = -(br_b[l]+br_b_fr[l])/br_ttm[l]*x[lookup_vm[f_bus[l]]]^2 -
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*cos(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*sin(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) -
        x[q_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_from)

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        # power_flow_q_to_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = -(br_b[l]+br_b_to[l])*x[lookup_vm[t_bus[l]]]^2 -
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*cos(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*sin(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) -
        x[q_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_to)

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        # power_flow_vad_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = x[lookup_va[f_bus[l]]] - x[lookup_va[t_bus[l]]]
        end

        offsetidx += length(ref_arcs_from)

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        # power_flow_mva_from_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = x[p_idxmap[(l,i,j)]]^2 + x[q_idxmap[(l,i,j)]]^2
        end

        offsetidx += length(ref_arcs_from)

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        # power_flow_mva_to_con 
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = x[p_idxmap[(l,i,j)]]^2 + x[q_idxmap[(l,i,j)]]^2
        end

        offsetidx += length(ref_arcs_to)

        @assert offsetidx == length(ret)
        nothing
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    model_variables = length(var_init)
    ret = Array{Float64}(undef, length(con_lbs))
    model_constraints = length(con_lbs)

    optf = Optimization.OptimizationFunction(opf_objective, adchoice; cons=opf_constraints)
    prob = Optimization.OptimizationProblem(optf, var_init; lb=var_lb, ub=var_ub, lcons=con_lbs, ucons=con_ubs)
end

function solve_opf_optimization(dataset; adchoice = Optimization.AutoSparseReverseDiff(true))
    model_build_time = @elapsed prob = build_opf_optimization_prob(dataset; adchoice)

    # Correctness tests
    ret = zeros(length(prob.lcons))
    prob.f.cons(ret, prob.u0, nothing)
    @allocated prob.f(prob.u0, nothing) == 0
    @allocated prob.f.cons(ret, prob.u0, nothing) == 0

    solve_time_with_compilation = @elapsed sol = Optimization.solve(prob, Ipopt.Optimizer(), print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    cost = sol.minimum
    feasible = (sol.retcode == Optimization.SciMLBase.ReturnCode.Success)
    #println(sol.u) # solution vector

    solve_time_without_compilation = @elapsed sol = Optimization.solve(prob, Ipopt.Optimizer(), print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    
    return (prob,sol),Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; length(prob.u0),
        &quot;constraints&quot; =&gt; length(prob.lcons),
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_optimization_prob(dataset, test_u0)
    prob = build_opf_optimization_prob(dataset)
    ret = zeros(length(prob.lcons))
    prob.f.cons(ret, test_u0, nothing)
    obj = prob.f(test_u0, nothing)
    obj, ret
end</code></pre><pre><code class="nohighlight hljs">test_optimization_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">optimization_test_res = test_optimization_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.0, 2.5424107263916085e-14, -1.0835776720341528e-13,
 -6.039613253960852e-14, 0.0, 0.0, 0.0, -1.7075230118734908e-13, -3.9968028
886505635e-14, 1.532107773982716e-13  …  5.709523923775402, 8.5822728368379
8, 18.147597689108025, 15.999999905294098, 3.0822827695389314, 2.6621176970
504, 5.759999990861611, 8.161419886019171, 17.65224849471505, 15.8096580240
1578])</code></pre><pre><code class="language-julia hljs">@assert optimization_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert optimization_test_res[2] == test_cons</code></pre><h2 id="ModelingToolkit.jl"><a class="docs-heading-anchor" href="#ModelingToolkit.jl">ModelingToolkit.jl</a><a id="ModelingToolkit.jl-1"></a><a class="docs-heading-anchor-permalink" href="#ModelingToolkit.jl" title="Permalink"></a></h2><p>Showcases symbolic interface to Optimization.jl, through ModelingToolkit.jl. The simplification process in ModelingToolkit.jl transforms the system to solve for a smaller subset of variables. As a result, while the optimization problem being solved is equivalent constraint function values don&#39;t match. The test for this system is thus modified. The <code>test_u0</code> vector will be appropriately subsetted to match the reduced set of variables, and the resultant point is ensured to be feasible as per the modified constraints. The subsetted point will be used to re-generate the full point using the observed equations in the reduced system, and this point will be validated to match <code>test_u0</code>.</p><pre><code class="language-julia hljs">
import PowerModels
import Ipopt
using ModelingToolkit, Optimization, OptimizationMOI
import ModelingToolkit: ≲, unknowns
import SymbolicIndexingInterface
using SymbolicIndexingInterface: variable_symbols, all_variable_symbols, getname

function build_opf_mtk_prob(dataset)
    (;data, ref) = dataset

    vars = Num[]
    lb = Float64[]
    ub = Float64[]

    ModelingToolkit.@variables va[1:maximum(keys(ref[:bus]))]
    for i in keys(ref[:bus])
        push!(lb, -Inf)
        push!(ub, Inf)
    end
    ModelingToolkit.@variables vm[1:maximum(keys(ref[:bus]))]
    for i in keys(ref[:bus])
        push!(lb, ref[:bus][i][&quot;vmin&quot;])
        push!(ub, ref[:bus][i][&quot;vmax&quot;])
    end
    vars = vcat(vars, [va[i] for i in keys(ref[:bus])], [vm[i] for i in keys(ref[:bus])])
    ModelingToolkit.@variables pg[1:maximum(keys(ref[:gen]))]
    for i in keys(ref[:gen])
        push!(lb, ref[:gen][i][&quot;pmin&quot;])
        push!(ub, ref[:gen][i][&quot;pmax&quot;])
    end
    ModelingToolkit.@variables qg[1:maximum(keys(ref[:gen]))]
    for i in keys(ref[:gen])
        push!(lb, ref[:gen][i][&quot;qmin&quot;])
        push!(ub, ref[:gen][i][&quot;qmax&quot;])
    end
    vars = vcat(vars, [pg[i] for i in keys(ref[:gen])], [qg[i] for i in keys(ref[:gen])])
    i_inds, j_inds, l_inds = maximum(first.(ref[:arcs])), maximum(getindex.(ref[:arcs], Ref(2))), maximum(last.(ref[:arcs]))
    ModelingToolkit.@variables p[1:i_inds, 1:j_inds, 1:l_inds]
    ModelingToolkit.@variables q[1:i_inds, 1:j_inds, 1:l_inds]

    for (l, i, j) in ref[:arcs]
        push!(vars, p[l, i, j])
        push!(lb, -ref[:branch][l][&quot;rate_a&quot;])
        push!(ub, ref[:branch][l][&quot;rate_a&quot;])
    end

    for (l, i, j) in ref[:arcs]
        push!(vars, q[l, i, j])
        push!(lb, -ref[:branch][l][&quot;rate_a&quot;])
        push!(ub, ref[:branch][l][&quot;rate_a&quot;])
    end

    loss = sum(gen[&quot;cost&quot;][1] * pg[i]^2 + gen[&quot;cost&quot;][2] * pg[i] + gen[&quot;cost&quot;][3] for (i, gen) in ref[:gen])

    cons = Array{Union{ModelingToolkit.Equation,ModelingToolkit.Inequality}}([])
    for (i, bus) in ref[:ref_buses]
        push!(cons, va[i] ~ 0)
    end

    for (i, bus) in ref[:bus]
        bus_loads = [ref[:load][l] for l in ref[:bus_loads][i]]
        bus_shunts = [ref[:shunt][s] for s in ref[:bus_shunts][i]]
        push!(cons,
            sum(p[a...] for a in ref[:bus_arcs][i]) ~
                (sum(pg[g] for g in ref[:bus_gens][i]; init = 0.0)) -
                (sum(load[&quot;pd&quot;] for load in bus_loads; init = 0.0)) -
             sum(shunt[&quot;gs&quot;] for shunt in bus_shunts; init = 0.0)*vm[i]^2
        )

        push!(cons,
            sum(q[a...] for a in ref[:bus_arcs][i]) ~
                (sum(qg[g] for g in ref[:bus_gens][i]; init = 0.0)) -
                (sum(load[&quot;qd&quot;] for load in bus_loads; init = 0.0))
             + sum(shunt[&quot;bs&quot;] for shunt in bus_shunts; init = 0.0)*vm[i]^2
        )
    end

    # Branch power flow physics and limit constraints
    for (i, branch) in ref[:branch]
        f_idx = (i, branch[&quot;f_bus&quot;], branch[&quot;t_bus&quot;])
        t_idx = (i, branch[&quot;t_bus&quot;], branch[&quot;f_bus&quot;])

        p_fr = p[f_idx...]
        q_fr = q[f_idx...]
        p_to = p[t_idx...]
        q_to = q[t_idx...]

        vm_fr = vm[branch[&quot;f_bus&quot;]]
        vm_to = vm[branch[&quot;t_bus&quot;]]
        va_fr = va[branch[&quot;f_bus&quot;]]
        va_to = va[branch[&quot;t_bus&quot;]]

        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)
        ttm = tr^2 + ti^2
        g_fr = branch[&quot;g_fr&quot;]
        b_fr = branch[&quot;b_fr&quot;]
        g_to = branch[&quot;g_to&quot;]
        b_to = branch[&quot;b_to&quot;]

        # From side of the branch flow
        push!(cons, p_fr ~ (g + g_fr) / ttm * vm_fr^2 + (-g * tr + b * ti) / ttm * (vm_fr * vm_to * cos(va_fr - va_to)) + (-b * tr - g * ti) / ttm * (vm_fr * vm_to * sin(va_fr - va_to)))
        push!(cons, q_fr ~ -(b + b_fr) / ttm * vm_fr^2 - (-b * tr - g * ti) / ttm * (vm_fr * vm_to * cos(va_fr - va_to)) + (-g * tr + b * ti) / ttm * (vm_fr * vm_to * sin(va_fr - va_to)))

        # To side of the branch flow
        push!(cons, p_to ~ (g + g_to) * vm_to^2 + (-g * tr - b * ti) / ttm * (vm_to * vm_fr * cos(va_to - va_fr)) + (-b * tr + g * ti) / ttm * (vm_to * vm_fr * sin(va_to - va_fr)))
        push!(cons, q_to ~ -(b + b_to) * vm_to^2 - (-b * tr + g * ti) / ttm * (vm_to * vm_fr * cos(va_to - va_fr)) + (-g * tr - b * ti) / ttm * (vm_to * vm_fr * sin(va_to - va_fr)))

        # Voltage angle difference limit
        push!(cons, va_fr - va_to ≲ branch[&quot;angmax&quot;])
        push!(cons, branch[&quot;angmin&quot;] ≲ va_fr - va_to)

        # Apparent power limit, from side and to side
        push!(cons, p_fr^2 + q_fr^2 ≲ branch[&quot;rate_a&quot;]^2)
        push!(cons, p_to^2 + q_to^2 ≲ branch[&quot;rate_a&quot;]^2)
    end

    optsys = ModelingToolkit.OptimizationSystem(loss, vars, [], constraints=cons, name=:rosetta)
    optsys = ModelingToolkit.complete(optsys)
    u0map = [Num(k) =&gt; 0.0 for k in collect(unknowns(optsys))]
    ks = collect(Num.(unknowns(optsys)))
    for key in keys(ref[:bus])
        ind = findfirst(x -&gt; isequal(x, vm[key]), ks)
        if ind !== nothing
            u0map[ind] = vm[key] =&gt; 1.0
        end
    end

    inds = Int[]
    for k in collect(unknowns(optsys))
        push!(inds, findall(x -&gt; isequal(x, k), vars)[1])
    end
    prob = Optimization.OptimizationProblem(optsys, Dict(u0map), lb = lb[inds], ub = ub[inds], grad=true, hess=true, cons_j=true, cons_h=true, cons_sparse=true, sparse=true)
end

function solve_opf_mtk(dataset)
    model_build_time = @elapsed prob = build_opf_mtk_prob(dataset)

    # @assert prob.f(prob.u0, nothing) == 0.0 #MTK with simplification doesn&#39;t evaluate the same
    ret = zeros(length(prob.lcons))
    prob.f.cons(ret, prob.u0, nothing, )
    @allocated prob.f(prob.u0, nothing) == 0
    @allocated prob.f.cons(ret, prob.u0, nothing) == 0


    solve_time_with_compilation = @elapsed sol = OptimizationMOI.solve(prob, Ipopt.Optimizer())
    solve_time_without_compilation = @elapsed sol = OptimizationMOI.solve(prob, Ipopt.Optimizer())

    cost = sol.minimum
    feasible = (sol.retcode == Optimization.SciMLBase.ReturnCode.Success)

   return (prob,sol),Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; length(prob.u0),
        &quot;constraints&quot; =&gt; length(prob.lcons),
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

# Given a ModelingToolkit.jl variable, translate it to the corresponding
# name it has in the dataset
function mtk_sym_to_name(sym)
    sym = ModelingToolkit.unwrap(sym)
    return string(getname(sym)) * &quot;_&quot; * join(ModelingToolkit.arguments(sym)[2:end], &quot;_&quot;)
end

function test_mtk_prob(dataset, test_u0)
    prob = build_opf_mtk_prob(dataset)

    syms_subset = variable_symbols(prob)
    syms_names = map(mtk_sym_to_name, syms_subset)
    subset_idxs = [dataset.var_lookup[name] for name in syms_names]
    sub_u0 = test_u0[subset_idxs]

    objective = prob.f(sub_u0, prob.p)

    cons_buffer = zeros(length(prob.lcons))
    prob.f.cons(cons_buffer, sub_u0)

    all_syms = all_variable_symbols(prob)
    all_syms_names = map(mtk_sym_to_name, all_syms)
    all_syms_idxs = [dataset.var_lookup[name] for name in all_syms_names]
    reordered_syms = similar(all_syms)
    for (sym, idx) in zip(all_syms, all_syms_idxs)
        reordered_syms[idx] = sym
    end
    reconstructed_u0 = SymbolicIndexingInterface.observed(prob, reordered_syms)(sub_u0, prob.p)
    return objective, reconstructed_u0, cons_buffer, prob.lcons, prob.ucons
end</code></pre><pre><code class="nohighlight hljs">test_mtk_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">objective, reconstructed_u0, cons_vals, lcons, ucons = test_mtk_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.062436387733897314, 1.0711076238965598, 0.0, 1.0665
09799068872, -0.023231313776594726, 1.0879315976617783, -0.0330949932899190
16, 1.0999999581285527, 0.07121718642320936, 1.094374845084077  …  -0.95989
88325635542, 1.3193604239530325, 2.399997991458022, -0.003103523654225171, 
-2.7920689620650667, -0.6047898784636468, -1.9771521474512397, -3.707171142
6024025, -3.9623014391707136, 0.3313990482205271], [0.0, -2.542410726391608
5e-14, 0.0, 1.0782979045774244e-13, 1.7091883464104285e-13, 6.0174087934683
48e-14, 3.9968028886505635e-14, 0.0, -1.5276668818842154e-13, 0.0  …  -2.31
08919702252706e-6, -0.49535150528494754, 0.0, 1.5543122344752192e-15, 4.440
892098500626e-16, -1.5543122344752192e-15, -0.42915027539849476, -0.6180472
757981029, -9.470590205053371e-8, -0.19034197598422065], [0.0, 0.0, 0.0, 0.
0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  -Inf, -Inf, 0.0, 0.0, 0.0, 0.0, -Inf, -
Inf, -Inf, -Inf], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0
, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0])</code></pre><pre><code class="language-julia hljs">@assert isapprox(objective, test_obj)</code></pre><pre><code class="language-julia hljs"># Some pairs of variables have interchangeable values.
# Either one could be specified in terms of the other, and the choice
# is arbitrary during simplification of the symbolic system.
swappable_pairs = [
    [dataset.var_lookup[&quot;pg_1&quot;], dataset.var_lookup[&quot;pg_2&quot;]],
    [dataset.var_lookup[&quot;qg_1&quot;], dataset.var_lookup[&quot;qg_2&quot;]],
]

# Indexes that must match
non_swappable_idxs = setdiff(eachindex(reconstructed_u0), reduce(vcat, swappable_pairs))
@assert isapprox(reconstructed_u0[non_swappable_idxs], test_u0[non_swappable_idxs])
for (i, j) in swappable_pairs
    @assert isapprox(reconstructed_u0[[i, j]], test_u0[[i, j]]) || isapprox(reconstructed_u0[[j, i]], test_u0[[i, j]])
end</code></pre><pre><code class="language-julia hljs"># Test all constraint values
@assert all(isapprox.(lcons, cons_vals, atol=1e-12) .|| (lcons .&lt;= cons_vals .&lt;= ucons) .|| isapprox.(cons_vals, ucons, atol=1e-12))</code></pre><pre><code class="language-julia hljs"></code></pre><h2 id="JuMP.jl"><a class="docs-heading-anchor" href="#JuMP.jl">JuMP.jl</a><a id="JuMP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP.jl" title="Permalink"></a></h2><p>Implementation reference: https://github.com/lanl-ansi/PowerModelsAnnex.jl/blob/master/src/model/ac-opf.jl Only the built-in AD library is supported</p><pre><code class="language-julia hljs">import PowerModels
import Ipopt
import JuMP

function build_opf_jump_prob(dataset)
    (;data, ref) = dataset
    constraints = Any[]
    model = JuMP.Model(Ipopt.Optimizer)

    vars = [JuMP.@variable(model, va[i in keys(ref[:bus])]),
            JuMP.@variable(model, ref[:bus][i][&quot;vmin&quot;] &lt;= vm[i in keys(ref[:bus])] &lt;= ref[:bus][i][&quot;vmax&quot;], start=1.0),
            JuMP.@variable(model, ref[:gen][i][&quot;pmin&quot;] &lt;= pg[i in keys(ref[:gen])] &lt;= ref[:gen][i][&quot;pmax&quot;]),
            JuMP.@variable(model, ref[:gen][i][&quot;qmin&quot;] &lt;= qg[i in keys(ref[:gen])] &lt;= ref[:gen][i][&quot;qmax&quot;]),
            JuMP.@variable(model, -ref[:branch][l][&quot;rate_a&quot;] &lt;= p[(l,i,j) in ref[:arcs]] &lt;= ref[:branch][l][&quot;rate_a&quot;]),
            JuMP.@variable(model, -ref[:branch][l][&quot;rate_a&quot;] &lt;= q[(l,i,j) in ref[:arcs]] &lt;= ref[:branch][l][&quot;rate_a&quot;])]

    JuMP.@objective(model, Min, sum(gen[&quot;cost&quot;][1]*pg[i]^2 + gen[&quot;cost&quot;][2]*pg[i] + gen[&quot;cost&quot;][3] for (i,gen) in ref[:gen]))

    for (i,bus) in ref[:ref_buses]
        push!(constraints,JuMP.@constraint(model, va[i] == 0))
    end

    for (i,bus) in ref[:bus]
        bus_loads = [ref[:load][l] for l in ref[:bus_loads][i]]
        bus_shunts = [ref[:shunt][s] for s in ref[:bus_shunts][i]]

        push!(constraints,JuMP.@constraint(model,
            sum(p[a] for a in ref[:bus_arcs][i]) ==
            sum(pg[g] for g in ref[:bus_gens][i]) -
            sum(load[&quot;pd&quot;] for load in bus_loads) -
            sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        ))

        push!(constraints,JuMP.@constraint(model,
            sum(q[a] for a in ref[:bus_arcs][i]) ==
            sum(qg[g] for g in ref[:bus_gens][i]) -
            sum(load[&quot;qd&quot;] for load in bus_loads) +
            sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        ))
    end

    # Branch power flow physics and limit constraints
    for (i,branch) in ref[:branch]
        f_idx = (i, branch[&quot;f_bus&quot;], branch[&quot;t_bus&quot;])
        t_idx = (i, branch[&quot;t_bus&quot;], branch[&quot;f_bus&quot;])

        p_fr = p[f_idx]
        q_fr = q[f_idx]
        p_to = p[t_idx]
        q_to = q[t_idx]

        vm_fr = vm[branch[&quot;f_bus&quot;]]
        vm_to = vm[branch[&quot;t_bus&quot;]]
        va_fr = va[branch[&quot;f_bus&quot;]]
        va_to = va[branch[&quot;t_bus&quot;]]

        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)
        ttm = tr^2 + ti^2
        g_fr = branch[&quot;g_fr&quot;]
        b_fr = branch[&quot;b_fr&quot;]
        g_to = branch[&quot;g_to&quot;]
        b_to = branch[&quot;b_to&quot;]

        # From side of the branch flow
        push!(constraints,JuMP.@NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) ))
        push!(constraints,JuMP.@NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) ))

        # To side of the branch flow
        push!(constraints,JuMP.@NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) ))
        push!(constraints,JuMP.@NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) ))

        # Voltage angle difference limit
        push!(constraints,JuMP.@constraint(model, branch[&quot;angmin&quot;] &lt;= va_fr - va_to &lt;= branch[&quot;angmax&quot;]))

        # Apparent power limit, from side and to side
        push!(constraints,JuMP.@constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2))
        push!(constraints,JuMP.@constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2))
    end

    model_variables = JuMP.num_variables(model)

    # for consistency with other solvers, skip the variable bounds in the constraint count
    non_nl_constraints = sum(JuMP.num_constraints(model, ft, st) for (ft, st) in JuMP.list_of_constraint_types(model) if ft != JuMP.VariableRef)
    model_constraints = JuMP.num_nonlinear_constraints(model) + non_nl_constraints

    model, vars, constraints
end

function solve_opf_jump(dataset)
    model_build_time = @elapsed model = build_opf_jump_prob(dataset)[1]
    JuMP.set_attribute(model, &quot;max_cpu_time&quot;, MAX_CPU_TIME)
    JuMP.set_attribute(model, &quot;print_level&quot;, PRINT_LEVEL)

    solve_time_with_compilation = @elapsed JuMP.optimize!(model)
    solve_time_without_compilation = @elapsed JuMP.optimize!(model)

    cost = JuMP.objective_value(model)
    feasible = (JuMP.termination_status(model) == JuMP.LOCALLY_SOLVED)

    nlp_block = JuMP.MOI.get(model, JuMP.MOI.NLPBlock())
    total_callback_time =
        nlp_block.evaluator.eval_objective_timer +
        nlp_block.evaluator.eval_objective_gradient_timer +
        nlp_block.evaluator.eval_constraint_timer +
        nlp_block.evaluator.eval_constraint_jacobian_timer +
        nlp_block.evaluator.eval_hessian_lagrangian_timer
    model_variables = JuMP.num_variables(model)
    non_nl_constraints = sum(JuMP.num_constraints(model, ft, st) for (ft, st) in JuMP.list_of_constraint_types(model) if ft != JuMP.VariableRef)
    model_constraints = JuMP.num_nonlinear_constraints(model) + non_nl_constraints
    
    return model, Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_jump_prob(dataset, test_u0)
    model, vars, constraints  = build_opf_jump_prob(dataset)
    (;
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij) = dataset
    f = JuMP.objective_function(model)

    flatvars = reduce(vcat,[reduce(vcat,vars[i]) for i in 1:length(vars)])
    point = Dict()
    for v in flatvars
        varname, varint = split(JuMP.name(v), &quot;[&quot;)
        idx = if varint[1] == &#39;(&#39;
            varint = (parse(Int, varint[2]), parse(Int, varint[5]), parse(Int, varint[8]))
            if varname == &quot;p&quot;
                lookup_p_lij[findfirst(x-&gt;x==varint,lookup_lij)]
            elseif varname == &quot;q&quot;
                lookup_q_lij[findfirst(x-&gt;x==varint,lookup_lij)]
            else
                error(&quot;Invalid $varname, $varint&quot;)
            end
        else
            varint = parse(Int, varint[1:end-1])
            if varname == &quot;va&quot;
                lookup_va[varint]
            elseif varname == &quot;pg&quot;
                lookup_pg[varint]
            elseif varname == &quot;qg&quot;
                lookup_qg[varint]
            elseif varname == &quot;vm&quot;
                lookup_vm[varint]
            else
                error(&quot;Invalid $varname, $varint&quot;)
            end
        end
        point[v] = test_u0[idx]
    end
    obj = JuMP.value(x-&gt;point[x], f)

    # The JuMP assertion error is because JuMP and optimization.jl build different problems. JuMP builds f(x) == a and optimization.jl builds f(x) - a == 0
    # Workaround this for consistent evaluation
    # It&#39;s not a general purpose approach because only some of the Optimization.jl constraints are written as f(x) - a = 0 . 
    # Others are written as f(x) &lt;= a, like the p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2 constraints

    primal_value(set::JuMP.MOI.EqualTo) = JuMP.MOI.constant(set)
    primal_value(set) = 0.0
    function primal_value(f, constraint)
        object = JuMP.constraint_object(constraint)
        fx = JuMP.value(f, object.func)
        return fx - primal_value(object.set)
    end
    function primal_value(f, constraint::JuMP.NonlinearConstraintRef)
        return JuMP.value(f, constraint)
    end
    obj = JuMP.value(x-&gt;point[x], f)
    cons = [primal_value(x-&gt;point[x], c) for c in constraints]
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_jump_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">jump_test_res = test_jump_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.0, -2.55351295663786e-14, 0.0, 1.0835776720341528e-
13, 1.7075230118734908e-13, 6.039613253960852e-14, 3.9968028886505635e-14, 
0.0, -1.5298873279334657e-13, 4.440892098500626e-16  …  0.00878079868931204
4, 18.147597689108025, 17.65224849471505, 0.0, 7.105427357601002e-15, 0.0, 
7.105427357601002e-15, 0.09444850019980408, 15.999999905294098, 15.80965802
401578])</code></pre><pre><code class="language-julia hljs">@assert jump_test_res[1] ≈ test_obj</code></pre><pre><code class="language-julia hljs">@assert sort(abs.(jump_test_res[2])) ≈ sort(abs.(test_cons))</code></pre><h2 id="NLPModels.jl"><a class="docs-heading-anchor" href="#NLPModels.jl">NLPModels.jl</a><a id="NLPModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#NLPModels.jl" title="Permalink"></a></h2><p>Implementation reference: https://juliasmoothoptimizers.github.io/ADNLPModels.jl/stable/tutorial/ Other AD libraries can be considered: https://juliasmoothoptimizers.github.io/ADNLPModels.jl/stable/</p><pre><code class="language-julia hljs">import ADNLPModels
import NLPModelsIpopt

function build_opf_nlpmodels_prob(dataset)
    (;data, ref) = dataset

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        push!(var_init, 0.0) #pg
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #qg
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1
    #total_callback_time = 0.0
    function opf_objective(x)
        #start = time()
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[var_lookup[&quot;pg_$(i)&quot;]]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints!(cx, x)
        #start = time()

        va = Dict(i =&gt; x[var_lookup[&quot;va_$(i)&quot;]] for (i,bus) in ref[:bus])
        vm = Dict(i =&gt; x[var_lookup[&quot;vm_$(i)&quot;]] for (i,bus) in ref[:bus])

        pg = Dict(i =&gt; x[var_lookup[&quot;pg_$(i)&quot;]] for (i,gen) in ref[:gen])
        qg = Dict(i =&gt; x[var_lookup[&quot;qg_$(i)&quot;]] for (i,gen) in ref[:gen])

        p = Dict((l,i,j) =&gt; x[var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])
        q = Dict((l,i,j) =&gt; x[var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])

        vm_fr = Dict(l =&gt; vm[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        vm_to = Dict(l =&gt; vm[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])
        va_fr = Dict(l =&gt; va[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        va_to = Dict(l =&gt; va[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])


        # va_con = [va[i] for (i,bus) in ref[:ref_buses]]
        k = 0
        for (i,bus) in ref[:ref_buses]
            k += 1
            cx[k] = va[i]
        end

        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        for (i, bus) in ref[:bus]
            k += 1
            cx[k] = sum(pg[j] for j in ref[:bus_gens][i]; init=0.0) - bus_pd[i] - bus_gs[i]*vm[i]^2 - sum(p[a] for a in ref[:bus_arcs][i])
        end

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(qg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        for (i, bus) in ref[:bus]
            k += 1
            cx[k] = sum(qg[j] for j in ref[:bus_gens][i]; init=0.0) - bus_qd[i] + bus_bs[i]*vm[i]^2 - sum(q[a] for a in ref[:bus_arcs][i])
        end


        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = (br_g[l]+br_g_fr[l])/br_ttm[l]*vm_fr[l]^2 +
            (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
            (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
            p[(l,i,j)]
        end

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = (br_g[l]+br_g_to[l])*vm_to[l]^2 +
            (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
            (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
            p[(l,i,j)]
        end

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = -(br_b[l]+br_b_fr[l])/br_ttm[l]*vm_fr[l]^2 -
            (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
            (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
            q[(l,i,j)]
        end

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = -(br_b[l]+br_b_to[l])*vm_to[l]^2 -
            (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
            (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
            q[(l,i,j)]
        end

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = va_fr[l] - va_to[l]
        end

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = p[(l,i,j)]^2 + q[(l,i,j)]^2
        end

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = p[(l,i,j)]^2 + q[(l,i,j)]^2
        end

        #total_callback_time += time() - start
        return cx
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    model_variables = length(var_init)
    model_constraints = length(opf_constraints!(similar(con_lbs), var_init))
    #=
    backend = ADNLPModels.ADModelBackend(model_variables, opf_objective, model_constraints, opf_constraints!;
                   gradient_backend = ADNLPModels.ReverseDiffADGradient,
                   hprod_backend = ADNLPModels.SDTForwardDiffADHvprod,
                   jprod_backend = ADNLPModels.ForwardDiffADJprod, 
                   jtprod_backend = ADNLPModels.ReverseDiffADJtprod, 
                   jacobian_backend = ADNLPModels.ForwardDiffADJacobian, # SDTSparseADJacobian, 
                   hessian_backend = ADNLPModels.ForwardDiffADHessian, # SparseADJacobian, 
                   ghjvprod_backend = ADNLPModels.ForwardDiffADGHjvprod, 
                   hprod_residual_backend = ADNLPModels.ReverseDiffADHvprod, 
                   jprod_residual_backend = ADNLPModels.ForwardDiffADJprod, 
                   jtprod_residual_backend = ADNLPModels.ReverseDiffADJtprod, 
                   jacobian_residual_backend = ADNLPModels.ForwardDiffADHessian, # SparseADJacobian, 
                   hessian_residual_backend = ADNLPModels.ForwardDiffADHessian
                   )
    =#
    nlp = ADNLPModels.ADNLPModel!(opf_objective, var_init, var_lb, var_ub, opf_constraints!, con_lbs, con_ubs, backend = :optimized)
end

function solve_opf_nlpmodels(dataset)
    model_build_time = @elapsed nlp = build_opf_nlpmodels_prob(dataset)
    solve_time_with_compilation = @elapsed output = NLPModelsIpopt.ipopt(nlp, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    solve_time_without_compilation = @elapsed output = NLPModelsIpopt.ipopt(nlp, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    cost = output.objective
    feasible = (output.primal_feas &lt;= 1e-6)  

    model_variables = nlp.meta.nvar
    model_constraints = nlp.meta.ncon

    return (nlp, output), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_nlpmodels_prob(dataset, test_u0)
    nlp = build_opf_nlpmodels_prob(dataset)
    ret = zeros(nlp.meta.ncon)
    nlp.c!(ret, test_u0)
    obj = nlp.f(test_u0)
    obj, ret
end</code></pre><pre><code class="nohighlight hljs">test_nlpmodels_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">nlpmodels_test_res = test_nlpmodels_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.0, 2.5424107263916085e-14, -1.0835776720341528e-13,
 -6.039613253960852e-14, 0.0, 0.0, 0.0, -1.7075230118734908e-13, -3.9968028
886505635e-14, 1.532107773982716e-13  …  5.709523923775402, 8.5822728368379
8, 18.147597689108025, 15.999999905294098, 3.0822827695389314, 2.6621176970
504, 5.759999990861611, 8.161419886019171, 17.65224849471505, 15.8096580240
1578])</code></pre><pre><code class="language-julia hljs">@assert nlpmodels_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert nlpmodels_test_res[2] == test_cons</code></pre><h2 id="Nonconvex"><a class="docs-heading-anchor" href="#Nonconvex">Nonconvex</a><a id="Nonconvex-1"></a><a class="docs-heading-anchor-permalink" href="#Nonconvex" title="Permalink"></a></h2><p>Implementation reference: https://julianonconvex.github.io/Nonconvex.jl/stable/problem/ Currently does not converge due to an upstream issue with the AD backend Zygote: https://github.com/JuliaNonconvex/Nonconvex.jl/issues/130</p><pre><code class="language-julia hljs">import Nonconvex
Nonconvex.@load Ipopt

function build_opf_nonconvex_prob(dataset)
    (;data, ref) = dataset
    time_model_start = time()

    model = Nonconvex.DictModel()

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_rate_a = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_angmin = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_angmax = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]

        br_rate_a[i] = branch[&quot;rate_a&quot;]
        br_angmin[i] = branch[&quot;angmin&quot;]
        br_angmax[i] = branch[&quot;angmax&quot;]
    end


    for (i,bus) in ref[:bus]
        addvar!(model, &quot;va_$(i)&quot;, -Inf, Inf, init=0.0) #va
        addvar!(model, &quot;vm_$(i)&quot;, bus[&quot;vmin&quot;], bus[&quot;vmax&quot;], init=1.0) #vm
    end

    for (i,gen) in ref[:gen]
        addvar!(model, &quot;pg_$(i)&quot;, gen[&quot;pmin&quot;], gen[&quot;pmax&quot;], init=0.0) #pg
        addvar!(model, &quot;qg_$(i)&quot;, gen[&quot;qmin&quot;], gen[&quot;qmax&quot;], init=0.0) #qg
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]
        addvar!(model, &quot;p_$(l)_$(i)_$(j)&quot;, -branch[&quot;rate_a&quot;], branch[&quot;rate_a&quot;], init=0.0) #p
        addvar!(model, &quot;q_$(l)_$(i)_$(j)&quot;, -branch[&quot;rate_a&quot;], branch[&quot;rate_a&quot;], init=0.0) #q
    end


    # JuMP.@objective(model, Min, sum(gen[&quot;cost&quot;][1]*pg[i]^2 + gen[&quot;cost&quot;][2]*pg[i] + gen[&quot;cost&quot;][3] for (i,gen) in ref[:gen]))
    function opf_objective(x::OrderedDict)
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[&quot;pg_$(i)&quot;]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        return cost
    end
    Nonconvex.set_objective!(model, opf_objective)

    # JuMP.@constraint(model, va[i] == 0)
    function const_ref_bus(x::OrderedDict, i)
        return x[&quot;va_$(i)&quot;]
    end
    for (i,bus) in ref[:ref_buses]
        add_eq_constraint!(model, x -&gt; const_ref_bus(x,i))
    end

    # @constraint(model,
    #     sum(p[a] for a in ref[:bus_arcs][i]) ==
    #     sum(pg[g] for g in ref[:bus_gens][i]) -
    #     sum(load[&quot;pd&quot;] for load in bus_loads) -
    #     sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
    # )
    function const_power_balance_p(x::OrderedDict, b)
        balance = - bus_pd[b] - bus_gs[b]*x[&quot;vm_$(b)&quot;]^2
        for (l,i,j) in ref[:bus_arcs][b]
            balance -= x[&quot;p_$(l)_$(i)_$(j)&quot;]
        end
        for j in ref[:bus_gens][b]
            balance += x[&quot;pg_$(j)&quot;]
        end
        return balance
    end

    # @constraint(model,
    #     sum(q[a] for a in ref[:bus_arcs][i]) ==
    #     sum(qg[g] for g in ref[:bus_gens][i]) -
    #     sum(load[&quot;qd&quot;] for load in bus_loads) +
    #     sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
    # )
    function const_power_balance_q(x::OrderedDict, b)
        balance = - bus_qd[b] + bus_bs[b]*x[&quot;vm_$(b)&quot;]^2
        for (l,i,j) in ref[:bus_arcs][b]
            balance -= x[&quot;q_$(l)_$(i)_$(j)&quot;]
        end
        for j in ref[:bus_gens][b]
            balance += x[&quot;qg_$(j)&quot;]
        end
        return balance
    end

    for (i,bus) in ref[:bus]
        add_eq_constraint!(model, x -&gt; const_power_balance_p(x,i))
        add_eq_constraint!(model, x -&gt; const_power_balance_q(x,i))
    end


    # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
    function const_flow_p_from(x::OrderedDict,l,i,j)
        return (br_g[l]+br_g_fr[l])/br_ttm[l]*x[&quot;vm_$(i)&quot;]^2 +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*cos(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) +
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*sin(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) -
        x[&quot;p_$(l)_$(i)_$(j)&quot;]
    end
    # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
    function const_flow_q_from(x::OrderedDict,l,i,j)
        return -(br_b[l]+br_b_fr[l])/br_ttm[l]*x[&quot;vm_$(i)&quot;]^2 -
       (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*cos(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) +
       (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*sin(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) -
       x[&quot;q_$(l)_$(i)_$(j)&quot;]
    end

    # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
    function const_flow_p_to(x::OrderedDict,l,i,j)
        return (br_g[l]+br_g_to[l])*x[&quot;vm_$(j)&quot;]^2 +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*cos(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) +
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*sin(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) -
        x[&quot;p_$(l)_$(j)_$(i)&quot;]
    end
    # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
    function const_flow_q_to(x::OrderedDict,l,i,j)
       return -(br_b[l]+br_b_to[l])*x[&quot;vm_$(j)&quot;]^2 -
       (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*cos(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) +
       (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*sin(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) -
       x[&quot;q_$(l)_$(j)_$(i)&quot;]
    end

    function const_thermal_limit(x::OrderedDict,l,i,j)
       return x[&quot;p_$(l)_$(i)_$(j)&quot;]^2 + x[&quot;q_$(l)_$(i)_$(j)&quot;]^2 - br_rate_a[l]^2
    end

    function const_voltage_angle_difference_lb(x::OrderedDict,l,i,j)
       return br_angmin[l] - x[&quot;va_$(i)&quot;] + x[&quot;va_$(j)&quot;]
    end

    function const_voltage_angle_difference_ub(x::OrderedDict,l,i,j)
       return x[&quot;va_$(i)&quot;] - x[&quot;va_$(j)&quot;] - br_angmax[l]
    end

    for (l,i,j) in ref[:arcs_from]
        add_eq_constraint!(model, x -&gt; const_flow_p_from(x,l,i,j))
        add_eq_constraint!(model, x -&gt; const_flow_q_from(x,l,i,j))

        add_eq_constraint!(model, x -&gt; const_flow_p_to(x,l,i,j))
        add_eq_constraint!(model, x -&gt; const_flow_q_to(x,l,i,j))

        add_ineq_constraint!(model, x -&gt; const_thermal_limit(x,l,i,j))
        add_ineq_constraint!(model, x -&gt; const_thermal_limit(x,l,j,i))

        add_ineq_constraint!(model, x -&gt; const_voltage_angle_difference_lb(x,l,i,j))
        add_ineq_constraint!(model, x -&gt; const_voltage_angle_difference_ub(x,l,i,j))
    end
    model
end

function solve_opf_nonconvex(dataset)
    model_build_time = @elapsed model = build_opf_nonconvex_prob(dataset)

    solve_time_with_compilation = @elapsed result = Nonconvex.optimize(
        model,
        IpoptAlg(),
        NonconvexCore.getinit(model);
        options = IpoptOptions(; first_order=false, symbolic=false, sparse=true, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME),
    )

    solve_time_without_compilation = @elapsed result = Nonconvex.optimize(
        model,
        IpoptAlg(),
        NonconvexCore.getinit(model);
        options = IpoptOptions(; first_order=false, symbolic=false, sparse=true, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME),
    )

    cost = result.minimum
    feasible = result.status == 0 # just guessing this is correct for Ipopt

    model_variables = Nonconvex.NonconvexCore.getnvars(model)
    model_constraints = Nonconvex.NonconvexCore.getnconstraints(model)

    return (model, result), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_nonconvex_prob(dataset, test_u0)
    model = build_opf_nonconvex_prob(dataset)
        (;
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij) = dataset

    point = Dict()
    for v in keys(model.init)
        varsplit = split(v, &quot;_&quot;)
        varname = varsplit[1]
        varint = parse.(Int, varsplit[2:end])

        idx = if varname == &quot;p&quot;
            lookup_p_lij[findfirst(x-&gt;x==Tuple(varint),lookup_lij)]
        elseif varname == &quot;q&quot;
            lookup_q_lij[findfirst(x-&gt;x==Tuple(varint),lookup_lij)]
        elseif varname == &quot;va&quot;
            lookup_va[varint[1]]
        elseif varname == &quot;pg&quot;
            lookup_pg[varint[1]]
        elseif varname == &quot;qg&quot;
            lookup_qg[varint[1]]
        elseif varname == &quot;vm&quot;
            lookup_vm[varint[1]]
        else
            error(&quot;Invalid $varname, $varint&quot;)
        end
        point[v] = test_u0[idx]
    end
    u0 = OrderedDict(keys(model.init) .=&gt; getindex.((point,),keys(model.init)))
    obj = model.objective(u0)
    cons = vcat(model.eq_constraints(u0), model.ineq_constraints(u0))
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_nonconvex_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">nonconvex_test_res = test_nonconvex_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.0, 2.5424107263916085e-14, 0.0, -1.0782979045774244
e-13, -1.7091883464104285e-13, -5.995204332975845e-14, -3.9968028886505635e
-14, 2.220446049250313e-16, 1.5276668818842154e-13, 0.0  …  -0.594815962021
5082, -0.45238158917508947, -2.3108919720016274e-6, -0.49535150528494754, -
0.532379574287611, -0.5148179769089868, -9.470590178750626e-8, -0.190341975
98421976, -0.6180472757981029, -0.4291502753984947])</code></pre><pre><code class="language-julia hljs">@assert nonconvex_test_res[1] ≈ test_obj</code></pre><pre><code class="language-julia hljs">@assert sort(abs.(nonconvex_test_res[2])) ≈ sort(abs.(test_cons))</code></pre><pre><code class="nohighlight hljs">Error: DimensionMismatch: dimensions must match: a has dims (Base.OneTo(59)
,), b has dims (Base.OneTo(53),), mismatch at 1</code></pre><pre><code class="language-julia hljs">println(sort(abs.(nonconvex_test_res[2])))</code></pre><pre><code class="nohighlight hljs">[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.220446049250313e-16, 2
.220446049250313e-16, 4.440892098500626e-16, 4.440892098500626e-16, 4.44089
2098500626e-16, 6.661338147750939e-16, 8.881784197001252e-16, 8.88178419700
1252e-16, 1.7763568394002505e-15, 1.7763568394002505e-15, 1.776356839400250
5e-15, 6.8833827526759706e-15, 7.105427357601002e-15, 7.105427357601002e-15
, 7.105427357601002e-15, 7.327471962526033e-15, 8.992806499463768e-15, 2.54
24107263916085e-14, 2.842170943040401e-14, 3.9968028886505635e-14, 3.996802
8886505635e-14, 5.995204332975845e-14, 1.0782979045774244e-13, 1.5276668818
842154e-13, 1.7091883464104285e-13, 9.138388712415235e-9, 9.470590178750626
e-8, 2.3108919720016274e-6, 0.05047607622459793, 0.19034197598421976, 0.429
1502753984947, 0.45238158917508947, 0.4611623878644015, 0.4905037823083798,
 0.49535150528494754, 0.5137350960849745, 0.5148179769089868, 0.53237957428
7611, 0.5334624551116232, 0.5566937688882179, 0.5860351633321961, 0.5948159
620215082, 0.6180472757981029, 9.565327163162017, 9.986180113980826, 14.890
536465979823, 15.065317230461066, 15.485482302949597, 15.485772198107965]</code></pre><pre><code class="language-julia hljs">println(sort(abs.(test_cons)))</code></pre><pre><code class="nohighlight hljs">[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 2.220446049250313e-
16, 4.440892098500626e-16, 4.440892098500626e-16, 4.440892098500626e-16, 6.
661338147750939e-16, 8.881784197001252e-16, 8.881784197001252e-16, 1.776356
8394002505e-15, 1.7763568394002505e-15, 1.7763568394002505e-15, 6.883382752
6759706e-15, 7.105427357601002e-15, 7.105427357601002e-15, 7.10542735760100
2e-15, 7.327471962526033e-15, 8.992806499463768e-15, 2.5424107263916085e-14
, 2.842170943040401e-14, 3.9968028886505635e-14, 3.9968028886505635e-14, 6.
039613253960852e-14, 1.0835776720341528e-13, 1.532107773982716e-13, 1.70752
30118734908e-13, 0.008780798689312044, 0.00986367951332429, 0.0330949932899
19016, 0.062436387733897314, 0.07121718642320936, 0.09444850019980408, 2.66
1827801892032, 2.6621176970504, 3.0822827695389314, 3.2570635340201743, 5.7
09523923775402, 5.759999990861611, 8.161419886019171, 8.58227283683798, 15.
80965802401578, 15.999999905294098, 17.65224849471505, 18.147597689108025]</code></pre><h2 id="Optim.jl"><a class="docs-heading-anchor" href="#Optim.jl">Optim.jl</a><a id="Optim.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Optim.jl" title="Permalink"></a></h2><p>Implementation reference: https://julianlsolvers.github.io/Optim.jl/stable/#examples/generated/ipnewton_basics/ Currently does not converge to a feasible point, root cause in unclear <code>debug/optim-debug.jl</code> can be used to confirm it will converge if given a suitable starting point</p><pre><code class="language-julia hljs">import Optim

function build_opf_optim_prob(dataset)
    (;data, ref) = dataset

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        #push!(var_init, 0.0) #pg
        push!(var_init, (gen[&quot;pmax&quot;]+gen[&quot;pmin&quot;])/2) # non-standard start
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        #push!(var_init, 0.0) #qg
        push!(var_init, (gen[&quot;qmax&quot;]+gen[&quot;qmin&quot;])/2) # non-standard start
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1
    #total_callback_time = 0.0
    function opf_objective(x)
        #start = time()
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[var_lookup[&quot;pg_$(i)&quot;]]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints(c,x)
        #start = time()
        va = Dict(i =&gt; x[var_lookup[&quot;va_$(i)&quot;]] for (i,bus) in ref[:bus])
        vm = Dict(i =&gt; x[var_lookup[&quot;vm_$(i)&quot;]] for (i,bus) in ref[:bus])

        pg = Dict(i =&gt; x[var_lookup[&quot;pg_$(i)&quot;]] for (i,gen) in ref[:gen])
        qg = Dict(i =&gt; x[var_lookup[&quot;qg_$(i)&quot;]] for (i,gen) in ref[:gen])

        p = Dict((l,i,j) =&gt; x[var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])
        q = Dict((l,i,j) =&gt; x[var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])

        vm_fr = Dict(l =&gt; vm[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        vm_to = Dict(l =&gt; vm[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])
        va_fr = Dict(l =&gt; va[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        va_to = Dict(l =&gt; va[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])


        va_con = [va[i] for (i,bus) in ref[:ref_buses]]

        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        power_balance_p_con = [
           sum(pg[j] for j in ref[:bus_gens][i]; init=0.0) -
           bus_pd[i] -
           bus_gs[i]*vm[i]^2 -
           sum(p[a] for a in ref[:bus_arcs][i])
           for (i,bus) in ref[:bus]
        ]

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(qg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        power_balance_q_con = [
           sum(qg[j] for j in ref[:bus_gens][i]; init=0.0) -
           bus_qd[i] +
           bus_bs[i]*vm[i]^2 -
           sum(q[a] for a in ref[:bus_arcs][i])
           for (i,bus) in ref[:bus]
        ]


        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        power_flow_p_from_con = [
           (br_g[l]+br_g_fr[l])/br_ttm[l]*vm_fr[l]^2 +
           (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
           (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
           p[(l,i,j)]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        power_flow_p_to_con = [
           (br_g[l]+br_g_to[l])*vm_to[l]^2 +
           (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
           (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
           p[(l,i,j)]
           for (l,i,j) in ref[:arcs_to]
        ]

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        power_flow_q_from_con = [
           -(br_b[l]+br_b_fr[l])/br_ttm[l]*vm_fr[l]^2 -
           (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
           (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
           q[(l,i,j)]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        power_flow_q_to_con = [
           -(br_b[l]+br_b_to[l])*vm_to[l]^2 -
           (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
           (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
           q[(l,i,j)]
           for (l,i,j) in ref[:arcs_to]
        ]

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        power_flow_vad_con = [
           va_fr[l] - va_to[l]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        power_flow_mva_from_con = [
           p[(l,i,j)]^2 + q[(l,i,j)]^2
           for (l,i,j) in ref[:arcs_from]
        ]

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        power_flow_mva_to_con = [
           p[(l,i,j)]^2 + q[(l,i,j)]^2
           for (l,i,j) in ref[:arcs_to]
        ]

        c .= [
            va_con...,
            power_balance_p_con...,
            power_balance_q_con...,
            power_flow_p_from_con...,
            power_flow_p_to_con...,
            power_flow_q_from_con...,
            power_flow_q_to_con...,
            power_flow_vad_con...,
            power_flow_mva_from_con...,
            power_flow_mva_to_con...,
        ]
        #total_callback_time += time() - start
        return c
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end


    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
        #push!(con_lbs, -Inf)
        #push!(con_ubs, Inf)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
        #push!(con_lbs, -Inf)
        #push!(con_ubs, Inf)
    end


    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    df = Optim.TwiceDifferentiable(opf_objective, var_init)
    dfc = Optim.TwiceDifferentiableConstraints(opf_constraints, var_lb, var_ub, con_lbs, con_ubs)
    df, dfc, var_init, con_lbs, con_ubs
end

function solve_opf_optim(dataset)
    model_build_time = @elapsed df, dfc, var_init, con_lbs, con_ubs = build_opf_optim_prob(dataset)

    options = Optim.Options(show_trace=PRINT_LEVEL != 0,time_limit=MAX_CPU_TIME)
    solve_time_with_compilation = @elapsed res = Optim.optimize(df, dfc, var_init, Optim.IPNewton(), options)
    solve_time_without_compilation = @elapsed res = Optim.optimize(df, dfc, var_init, Optim.IPNewton(), options)

    sol = res.minimizer
    cost = res.minimum

    # NOTE: confirmed these constraint violations can be eliminated
    # if a better starting point is used
    sol_eval = dfc.c!(zeros(dfc.bounds.nc), sol)
    vio_lb = [max(v,0) for v in (con_lbs .- sol_eval)]
    vio_ub = [max(v,0) for v in (sol_eval .- con_ubs)]
    const_vio = vio_lb .+ vio_ub
    constraint_tol = 1e-6
    feasible = (sum(const_vio) &lt;= constraint_tol)

    return (res,), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; length(var_init),
        &quot;constraints&quot; =&gt; dfc.bounds.nc,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_optim_prob(dataset, test_u0)
    df, dfc, var_init, con_lbs, con_ubs = build_opf_optim_prob(dataset)
    obj = df.f(test_u0)
    cons = dfc.c!(zeros(dfc.bounds.nc), test_u0)
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_optim_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">optim_test_res = test_optim_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(16236.704322376236, [0.0, 2.5424107263916085e-14, -1.0835776720341528e-13,
 -6.039613253960852e-14, 0.0, 0.0, 0.0, -1.7075230118734908e-13, -3.9968028
886505635e-14, 1.532107773982716e-13  …  5.709523923775402, 8.5822728368379
8, 18.147597689108025, 15.999999905294098, 3.0822827695389314, 2.6621176970
504, 5.759999990861611, 8.161419886019171, 17.65224849471505, 15.8096580240
1578])</code></pre><pre><code class="language-julia hljs">@assert optim_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert optim_test_res[2] == test_cons</code></pre><h2 id="CASADI"><a class="docs-heading-anchor" href="#CASADI">CASADI</a><a id="CASADI-1"></a><a class="docs-heading-anchor-permalink" href="#CASADI" title="Permalink"></a></h2><p>Implementation reference: https://github.com/lanl-ansi/PowerModelsAnnex.jl/blob/master/src/model/ac-opf.jl</p><p>CASADI Segfaults so removed for now.</p><pre><code class="nohighlight hljs">import PowerModels
import PythonCall
import CondaPkg
CondaPkg.add(&quot;casadi&quot;)

function solve_opf_casadi(dataset)
    (;data, ref) = dataset

    time_model_start = time()

    casadi = PythonCall.pyimport(&quot;casadi&quot;)

    x, x0, lbx, ubx, cons, lbg, ubg = [], [], [], [], [], [], []
    va, vm = Dict{Int,Any}(), Dict{Int,Any}()
    for (k, _) in ref[:bus]
        va[k] = casadi.SX.sym(&quot;va$k&quot;)
        push!(x, va[k])
        push!(x0, 0.0)
        push!(lbx, -casadi.inf)
        push!(ubx, casadi.inf)
        vm[k] = casadi.SX.sym(&quot;vm$k&quot;)
        push!(x, vm[k])
        push!(x0, 1.0)
        push!(lbx, ref[:bus][k][&quot;vmin&quot;])
        push!(ubx, ref[:bus][k][&quot;vmax&quot;])
    end
    pg, qg = Dict{Int,Any}(), Dict{Int,Any}()
    for (k, ) in ref[:gen]
        pg[k] = casadi.SX.sym(&quot;pg$k&quot;)
        push!(x, pg[k])
        push!(x0, 0.0)
        push!(lbx, ref[:gen][k][&quot;pmin&quot;])
        push!(ubx, ref[:gen][k][&quot;pmax&quot;])
        qg[k] = casadi.SX.sym(&quot;qg$k&quot;)
        push!(x, qg[k])
        push!(x0, 0.0)
        push!(lbx, ref[:gen][k][&quot;qmin&quot;])
        push!(ubx, ref[:gen][k][&quot;qmax&quot;])
    end
    p, q = Dict{NTuple{3,Int},Any}(), Dict{NTuple{3,Int},Any}()
    for k in ref[:arcs]
        a = ref[:branch][k[1]][&quot;rate_a&quot;]
        p[k] = casadi.SX.sym(&quot;p$k&quot;)
        push!(x, p[k])
        push!(x0, 0.0)
        push!(lbx, -a)
        push!(ubx, a)
        q[k] = casadi.SX.sym(&quot;q$k&quot;)
        push!(x, q[k])
        push!(x0, 0.0)
        push!(lbx, -a)
        push!(ubx, a)
    end
    f = sum(
        cost[&quot;cost&quot;][1] * pg[k]^2 +
        cost[&quot;cost&quot;][2] * pg[k] +
        cost[&quot;cost&quot;][3] for (k, cost) in ref[:gen]
    )
    for (k, _) in ref[:ref_buses]
        push!(cons, va[k])
        push!(lbg, 0)
        push!(ubg, 0)
    end
    for (i, _) in ref[:bus]
        bus_loads = [ref[:load][l] for l in ref[:bus_loads][i]]
        bus_shunts = [ref[:shunt][s] for s in ref[:bus_shunts][i]]
        push!(
            cons,
            sum(p[k] for k in ref[:bus_arcs][i]) -
            sum(pg[g] for g in ref[:bus_gens][i]; init = 0) +
            sum(load[&quot;pd&quot;] for load in bus_loads; init = 0) +
            sum(shunt[&quot;gs&quot;] for shunt in bus_shunts; init = 0) * vm[i]^2
        )
        push!(lbg, 0)
        push!(ubg, 0)
        push!(
            cons,
            sum(q[k] for k in ref[:bus_arcs][i]) -
            sum(qg[g] for g in ref[:bus_gens][i]; init = 0) +
            sum(load[&quot;qd&quot;] for load in bus_loads; init = 0) -
            sum(shunt[&quot;bs&quot;] for shunt in bus_shunts; init = 0) * vm[i]^2
        )
        push!(lbg, 0)
        push!(ubg, 0)
    end
    for (i, branch) in ref[:branch]
        f_idx = (i, branch[&quot;f_bus&quot;], branch[&quot;t_bus&quot;])
        t_idx = (i, branch[&quot;t_bus&quot;], branch[&quot;f_bus&quot;])
        p_fr = p[f_idx]
        q_fr = q[f_idx]
        p_to = p[t_idx]
        q_to = q[t_idx]
        vm_fr = vm[branch[&quot;f_bus&quot;]]
        vm_to = vm[branch[&quot;t_bus&quot;]]
        va_fr = va[branch[&quot;f_bus&quot;]]
        va_to = va[branch[&quot;t_bus&quot;]]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)
        ttm = tr^2 + ti^2
        g_fr = branch[&quot;g_fr&quot;]
        b_fr = branch[&quot;b_fr&quot;]
        g_to = branch[&quot;g_to&quot;]
        b_to = branch[&quot;b_to&quot;]
        push!(
            cons,
            (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*casadi.cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*casadi.sin(va_fr-va_to)) - p_fr
        )
        push!(
            cons,
            -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*casadi.cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*casadi.sin(va_fr-va_to)) - q_fr
        )
        push!(
            cons,
            (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*casadi.cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*casadi.sin(va_to-va_fr)) - p_to
        )
        push!(
            cons,
            -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*casadi.cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*casadi.sin(va_to-va_fr)) - q_to
        )
        for i in 1:4
            push!(lbg, 0)
            push!(ubg, 0)
        end
        push!(cons, va_fr - va_to)
        push!(lbg, branch[&quot;angmin&quot;])
        push!(ubg, branch[&quot;angmax&quot;])
        push!(cons, p_fr^2 + q_fr^2)
        push!(lbg, -casadi.inf)
        push!(ubg, branch[&quot;rate_a&quot;]^2)
        push!(cons, p_to^2 + q_to^2)
        push!(lbg, -casadi.inf)
        push!(ubg, branch[&quot;rate_a&quot;]^2)
    end

    nlp = Dict(&quot;x&quot; =&gt; casadi.vcat(x), &quot;f&quot; =&gt; f, &quot;g&quot; =&gt; casadi.vcat(cons))
    options = PythonCall.pydict(Dict(&quot;error_on_fail&quot; =&gt; true))
    model = casadi.nlpsol(&quot;model&quot;, &quot;ipopt&quot;, PythonCall.pydict(nlp), options)

    model_variables = length(x)
    model_constraints = length(lbg)

    model_build_time = time() - time_model_start

    time_solve_start = time()
    solution = model(; lbx = lbx, ubx = ubx, lbg = lbg, ubg = ubg, x0 = x0)
    cost = PythonCall.pyconvert(Float64, (PythonCall.pyfloat(solution[&quot;f&quot;])))
    feasible = true # error if not feasible

    solve_time = time() - time_solve_start
    total_time = time() - time_data_start

    println(&quot;&quot;)
    println(&quot;\033[1mSummary\033[0m&quot;)
    println(&quot;   case........: $(file_name)&quot;)
    println(&quot;   variables...: $(model_variables)&quot;)
    println(&quot;   constraints.: $(model_constraints)&quot;)
    println(&quot;   feasible....: $(feasible)&quot;)
    println(&quot;   cost........: $(round(Int, cost))&quot;)
    println(&quot;   total time..: $(total_time)&quot;)
    println(&quot;     data time.: $(data_load_time)&quot;)
    println(&quot;     build time: $(model_build_time)&quot;)
    println(&quot;     solve time: $(solve_time)&quot;)
    # println(&quot;      callbacks: $(total_callback_time)&quot;)
    println(&quot;&quot;)

    return Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_total&quot; =&gt; total_time,
        &quot;time_data&quot; =&gt; data_load_time,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time,
        #&quot;time_callbacks&quot; =&gt; TBD,
    )
end

solve_opf_casadi(&quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;)</code></pre><h2 id="Test-the-Benchmarking"><a class="docs-heading-anchor" href="#Test-the-Benchmarking">Test the Benchmarking</a><a id="Test-the-Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Test-the-Benchmarking" title="Permalink"></a></h2><pre><code class="language-julia hljs">file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optimization(dataset);
res</code></pre><pre><code class="nohighlight hljs">***************************************************************************
***
This program contains Ipopt, a library for large-scale nonlinear optimizati
on.
 Ipopt is released as open source code under the Eclipse Public License (EP
L).
         For more information visit https://github.com/coin-or/Ipopt
***************************************************************************
***

Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.000189458
  &quot;time_solve_compilation&quot; =&gt; 16.5577
  &quot;time_solve&quot;             =&gt; 0.459221
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_jump(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.00215803
  &quot;time_solve_compilation&quot; =&gt; 1.08609
  &quot;time_solve&quot;             =&gt; 0.012472
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nlpmodels(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.621379
  &quot;time_solve_compilation&quot; =&gt; 2.6468
  &quot;time_solve&quot;             =&gt; 0.0346682
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nonconvex(dataset);
res</code></pre><pre><code class="nohighlight hljs">Error: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDi
ff.Tag{NonconvexUtils.var&quot;#101#108&quot;{NonconvexUtils.var&quot;#100#107&quot;{NonconvexU
tils.var&quot;#97#104&quot;{NonconvexCore.VectorOfFunctions{Tuple{NonconvexCore.IneqC
onstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;
##WeaveSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_t
hermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differentia
bleFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}
, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int
64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity
), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Nonconve
xCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrappe
r{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.v
ar&quot;#const_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, 
DifferentiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String
, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}
, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{type
of(identity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64
}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.Fun
ctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSan
dBox#225&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}
, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedColle
ctions.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_
to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#u
nflatten_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{Strin
g, Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;
#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224
#266&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#2
58&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unf
latten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Differentiab
leFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Dif
ferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedColl
ections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqCons
traint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##W
eaveSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_ther
mal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differentiable
Flatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, D
ifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}
, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), 
OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCo
re.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{M
ain.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;
#const_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Dif
ferentiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, F
loat64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, T
uple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(
identity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, 
NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.Functi
onWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBo
x#225&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, I
nt64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollecti
ons.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_
Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unfl
atten_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, 
Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80
#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#26
6&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;
{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflat
ten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableF
latten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Differ
entiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollect
ions.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConstra
int{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##Weav
eSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_thermal
_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFla
tten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Diff
erentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, T
uple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), Ord
eredCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.
IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main
.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#co
nst_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differ
entiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Floa
t64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tupl
e{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(ide
ntity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Non
convexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionW
rapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBox#2
25&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, Int6
4, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollections
.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tup
le#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatt
en_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, Flo
at64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82
&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#266&quot;{
Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;{Di
ct{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten
{Tuple{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableFlat
ten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Different
iableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollection
s.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint
{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSa
ndBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_thermal_li
mit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatte
n.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Differe
ntiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tupl
e{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), Ordere
dCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.Ine
qConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.va
r&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const
_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Different
iableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64
}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{I
nt64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identi
ty), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Noncon
vexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrap
per{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBox#225&quot;
.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, Int64, 
Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollections.Or
deredDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#
11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_
to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, Float6
4}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{N
onconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#266&quot;{Mai
n.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;{Dict{
Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tu
ple{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableFlatten
.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Differentiab
leFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollections.O
rderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{No
nconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandB
ox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_thermal_limit
#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.U
nflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Differenti
ableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{D
ifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCo
llections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqCo
nstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;#
#WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_th
ermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differentiab
leFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}},
 DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int6
4}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity)
, OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Nonconvex
Core.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper
{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBox#225&quot;.va
r&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, Int64, Int
64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollections.Order
edDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;
{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_
Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, Float64}}
}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{Nonc
onvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#266&quot;{Main.v
ar&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;{Dict{Int
64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple
{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableFlatten.va
r&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableF
latten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollections.Orde
redDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{Nonco
nvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#
225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_thermal_limit#25
6&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unfl
atten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Differentiabl
eFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Diff
erentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedColle
ctions.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConst
raint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##We
aveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_therm
al_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableF
latten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Di
fferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64},
 Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), O
rderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCor
e.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Ma
in.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#
const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, Int64, Int64,
 Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedD
ict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tu
ple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dic
t#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, Float64}}}}}
}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{Nonconv
exCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#266&quot;{Main.var&quot;
##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;{Dict{Int64,
 Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{Or
deredCollections.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#
unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlat
ten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollections.Ordered
Dict{String, Float64}}}}}}, Float64}}}}}}, Float64}, Float64, 1})

Closest candidates are:
  (::Type{T})(::Real, !Matched::RoundingMode) where T&lt;:AbstractFloat
   @ Base rounding.jl:207
  (::Type{T})(::T) where T&lt;:Number
   @ Core boot.jl:792
  Float64(!Matched::IrrationalConstants.Sqrt3)
   @ IrrationalConstants /cache/julia-buildkite-plugin/depots/5b300254-1738
-4989-ae0a-f4d2d937f953/packages/IrrationalConstants/vp5v4/src/macro.jl:112
  ...</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optim(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 77.9548
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.000570855
  &quot;time_solve_compilation&quot; =&gt; 21.4562
  &quot;time_solve&quot;             =&gt; 16.304
  &quot;feasible&quot;               =&gt; false</code></pre><pre><code class="language-julia hljs">file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optimization(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 8.7959e-5
  &quot;time_solve_compilation&quot; =&gt; 0.0758728
  &quot;time_solve&quot;             =&gt; 0.0818315
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_jump(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.00333447
  &quot;time_solve_compilation&quot; =&gt; 0.00856609
  &quot;time_solve&quot;             =&gt; 0.00782539
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nlpmodels(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.0159399
  &quot;time_solve_compilation&quot; =&gt; 0.0181383
  &quot;time_solve&quot;             =&gt; 0.0169084
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nonconvex(dataset);
res</code></pre><pre><code class="nohighlight hljs">Error: MethodError: no method matching Float64(::ForwardDiff.Dual{ForwardDi
ff.Tag{NonconvexUtils.var&quot;#101#108&quot;{NonconvexUtils.var&quot;#100#107&quot;{NonconvexU
tils.var&quot;#97#104&quot;{NonconvexCore.VectorOfFunctions{Tuple{NonconvexCore.IneqC
onstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;
##WeaveSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_t
hermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differentia
bleFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}
, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int
64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity
), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Nonconve
xCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrappe
r{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.v
ar&quot;#const_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, 
DifferentiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String
, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}
, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{type
of(identity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64
}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.Fun
ctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSan
dBox#225&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}
, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedColle
ctions.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_
to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#u
nflatten_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{Strin
g, Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;
#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224
#266&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#2
58&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unf
latten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Differentiab
leFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Dif
ferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedColl
ections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqCons
traint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##W
eaveSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_ther
mal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differentiable
Flatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, D
ifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}
, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), 
OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCo
re.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{M
ain.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;
#const_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Dif
ferentiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, F
loat64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, T
uple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(
identity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, 
NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.Functi
onWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBo
x#225&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, I
nt64, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollecti
ons.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_
Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unfl
atten_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, 
Float64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80
#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#26
6&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;
{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflat
ten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableF
latten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Differ
entiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollect
ions.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.IneqConstra
int{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##Weav
eSandBox#225&quot;.var&quot;#221#263&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_thermal
_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFla
tten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Float64}}, Diff
erentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, T
uple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), Ord
eredCollections.OrderedDict{String, Float64}}}}}}, Float64}, NonconvexCore.
IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionWrapper{Main
.var&quot;##WeaveSandBox#225&quot;.var&quot;#222#264&quot;{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#co
nst_thermal_limit#256&quot;{Dict{Int64, Float64}}, Int64, Int64, Int64}}, Differ
entiableFlatten.Unflatten{Tuple{OrderedCollections.OrderedDict{String, Floa
t64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tupl
e{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(ide
ntity), OrderedCollections.OrderedDict{String, Float64}}}}}}, Float64}, Non
convexCore.IneqConstraint{NonconvexCore.var&quot;#80#82&quot;{NonconvexCore.FunctionW
rapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#223#265&quot;{Main.var&quot;##WeaveSandBox#2
25&quot;.var&quot;#const_voltage_angle_difference_lb#257&quot;{Dict{Int64, Float64}}, Int6
4, Int64, Int64}}, DifferentiableFlatten.Unflatten{Tuple{OrderedCollections
.OrderedDict{String, Float64}}, DifferentiableFlatten.var&quot;#unflatten_to_Tup
le#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{DifferentiableFlatten.var&quot;#unflatt
en_to_Dict#16&quot;{typeof(identity), OrderedCollections.OrderedDict{String, Flo
at64}}}}}}, Float64}, NonconvexCore.IneqConstraint{NonconvexCore.var&quot;#80#82
&quot;{NonconvexCore.FunctionWrapper{Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#224#266&quot;{
Main.var&quot;##WeaveSandBox#225&quot;.var&quot;#const_voltage_angle_difference_ub#258&quot;{Di
ct{Int64, Float64}}, Int64, Int64, Int64}}, DifferentiableFlatten.Unflatten
{Tuple{OrderedCollections.OrderedDict{String, Float64}}, DifferentiableFlat
ten.var&quot;#unflatten_to_Tuple#11&quot;{Tuple{Int64}, Tuple{Int64}, Tuple{Different
iableFlatten.var&quot;#unflatten_to_Dict#16&quot;{typeof(identity), OrderedCollection
s.OrderedDict{String, Float64}}}}}}, Float64}}}}}}, Float64}, Float64, 1})

Closest candidates are:
  (::Type{T})(::Real, !Matched::RoundingMode) where T&lt;:AbstractFloat
   @ Base rounding.jl:207
  (::Type{T})(::T) where T&lt;:Number
   @ Core boot.jl:792
  Float64(!Matched::IrrationalConstants.Sqrt3)
   @ IrrationalConstants /cache/julia-buildkite-plugin/depots/5b300254-1738
-4989-ae0a-f4d2d937f953/packages/IrrationalConstants/vp5v4/src/macro.jl:112
  ...</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optim(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 6273.63
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.0517723
  &quot;time_solve_compilation&quot; =&gt; 2.09519
  &quot;time_solve&quot;             =&gt; 2.06204
  &quot;feasible&quot;               =&gt; false</code></pre><pre><code class="language-julia hljs">using DataFrames, PrettyTables

function multidata_multisolver_benchmark(dataset_files; sizelimit = SIZE_LIMIT)

    cases = String[]
    vars = Int[]
    cons = Int[]

    optimization_time = Float64[]
    mtk_time = Float64[]
    jump_time = Float64[]
    nlpmodels_time = Float64[]
    nonconvex_time = Float64[]
    optim_time = Float64[]

    optimization_time_modelbuild = Float64[]
    mtk_time_modelbuild = Float64[]
    jump_time_modelbuild = Float64[]
    nlpmodels_time_modelbuild = Float64[]
    nonconvex_time_modelbuild = Float64[]
    optim_time_modelbuild = Float64[]

    optimization_time_compilation = Float64[]
    mtk_time_compilation = Float64[]
    jump_time_compilation = Float64[]
    nlpmodels_time_compilation = Float64[]
    nonconvex_time_compilation = Float64[]
    optim_time_compilation = Float64[]

    optimization_cost = Float64[]
    mtk_cost = Float64[]
    jump_cost = Float64[]
    nlpmodels_cost = Float64[]
    nonconvex_cost = Float64[]
    optim_cost = Float64[]

    for file in dataset_files
        @show file
        dataset = load_and_setup_data(file)

        prob = build_opf_optimization_prob(dataset)
        @info &quot;Number of Variables: $(length(prob.u0))&quot;
        @info &quot;Number of Constraints: $(length(prob.lcons))&quot;

        if length(prob.u0) &gt; sizelimit
            @info &quot;Variable size over global limit. Skipping for now&quot;
            continue
        end
        
        @info &quot;Running Optimization.jl&quot;
        model, res = solve_opf_optimization(dataset)
        push!(cases, split(file,&quot;/&quot;)[end])
        push!(vars, res[&quot;variables&quot;])
        push!(cons, res[&quot;constraints&quot;])
        push!(optimization_time, res[&quot;time_solve&quot;])
        push!(optimization_time_modelbuild, res[&quot;time_build&quot;])
        push!(optimization_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(optimization_cost, res[&quot;cost&quot;])

        @info &quot;Running ModelingToolkit.jl&quot;
        model, res = solve_opf_mtk(dataset)
        push!(mtk_time, res[&quot;time_solve&quot;])
        push!(mtk_time_modelbuild, res[&quot;time_build&quot;])
        push!(mtk_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(mtk_cost, res[&quot;cost&quot;])


        @info &quot;Running JuMP.jl&quot;
        model, res = solve_opf_jump(dataset)
        push!(jump_time, res[&quot;time_solve&quot;])
        push!(jump_time_modelbuild, res[&quot;time_build&quot;])
        push!(jump_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(jump_cost, res[&quot;cost&quot;])

        @info &quot;Running NLPModels.jl&quot;
        model, res = solve_opf_nlpmodels(dataset)
        push!(nlpmodels_time, res[&quot;time_solve&quot;])
        push!(nlpmodels_time_modelbuild, res[&quot;time_build&quot;])
        push!(nlpmodels_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(nlpmodels_cost, res[&quot;cost&quot;])
        
        #=
        @info &quot;Running Nonconvex.jl&quot;
        model, res = solve_opf_nonconvex(dataset)
        push!(nonconvex_time, res[&quot;time_solve&quot;])
        push!(nonconvex_time_modelbuild, res[&quot;time_build&quot;])
        push!(nonconvex_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(nonconvex_cost, res[&quot;cost&quot;])
        =#
        
        if length(prob.u0) &gt; 400
            @info &quot;Running Optim.jl&quot;
            model, res = solve_opf_optim(dataset)
            push!(optim_time, NaN)
            push!(optim_time_modelbuild, NaN)
            push!(optim_time_compilation, NaN)
            push!(optim_cost, NaN)
        else
            @info &quot;Running Optim.jl&quot;
            model, res = solve_opf_optim(dataset)
            push!(optim_time, res[&quot;time_solve&quot;])
            push!(optim_time_modelbuild, res[&quot;time_build&quot;])
            push!(optim_time_compilation, res[&quot;time_solve_compilation&quot;])
            push!(optim_cost, res[&quot;cost&quot;])
        end
    end
    DataFrame(:case =&gt; cases, :vars =&gt; vars, :cons =&gt; cons, 
              :optimization =&gt; optimization_time, :optimization_modelbuild =&gt; optimization_time_modelbuild, :optimization_wcompilation =&gt; optimization_time_compilation, :optimization_cost =&gt; optimization_cost,
              :mtk =&gt; mtk_time, :mtk_time_modelbuild =&gt; mtk_time_modelbuild, :mtk_time_wcompilation =&gt; mtk_time_compilation, :mtk_cost =&gt; mtk_cost,
              :jump =&gt; jump_time, :jump_modelbuild =&gt; jump_time_modelbuild, :jump_wcompilation =&gt; jump_time_compilation, :jump_cost =&gt; jump_cost, 
              :nlpmodels =&gt; nlpmodels_time, :nlpmodels_modelbuild =&gt; nlpmodels_time_modelbuild, :nlpmodels_wcompilation =&gt; nlpmodels_time_compilation,  :nlpmodels_cost =&gt; nlpmodels_cost, 
              #:nonconvex =&gt; nonconvex_time, :nonconvex_modelbuild =&gt; nonconvex_time_modelbuild, :nonconvex_wcompilation =&gt; nonconvex_time_compilation,  :nonconvex_cost =&gt; nonconvex_cost,
              :optim =&gt; optim_time, :optim_modelbuild =&gt; optim_time_modelbuild, :optim_wcompilation =&gt; optim_time_compilation,  :optim_cost =&gt; optim_cost)
end

test_datasets = [
    &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;,
    &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
    ]</code></pre><pre><code class="nohighlight hljs">2-element Vector{String}:
 &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
 &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;</code></pre><pre><code class="language-julia hljs">timing_data = multidata_multisolver_benchmark(test_datasets)</code></pre><pre><code class="nohighlight hljs">file = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:       78
Number of nonzeros in inequality constraint Jacobian.:       24
Number of nonzeros in Lagrangian Hessian.............:      122

Total number of variables............................:       23
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       20
                     variables with only upper bounds:        0
Total number of equality constraints.................:       19
Total number of inequality constraints...............:       12
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       12

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.3949934e+00 1.09e+00 1.67e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.1048421e+03 4.62e-01 1.04e+02  -1.0 1.81e+00    -  5.77e-03 5.76e-01h  1
   2  4.4503068e+03 1.36e-01 3.09e+01  -1.0 8.29e-01    -  8.15e-01 7.05e-01h  1
   3  4.6140270e+03 1.18e-01 2.67e+01  -1.0 2.99e-01    -  4.13e-01 1.37e-01h  1
   4  4.9343698e+03 8.25e-02 3.85e+01  -1.0 4.36e-01    -  4.94e-01 2.98e-01h  1
   5  5.4019378e+03 3.46e-02 2.51e+01  -1.0 3.62e-01    -  9.90e-01 5.81e-01h  1
   6  5.4116196e+03 3.37e-02 1.26e+02  -1.0 1.45e-01    -  1.84e-01 2.70e-02h  1
   7  5.6094774e+03 1.60e-02 5.13e+01  -1.0 2.53e-01    -  2.76e-01 5.25e-01h  1
   8  5.7031738e+03 8.53e-03 8.21e+01  -1.0 1.43e-01    -  7.00e-01 4.67e-01h  1
   9  5.8145457e+03 6.10e-04 2.19e+00  -1.0 5.77e-02    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  5.8146316e+03 2.55e-05 7.83e-03  -1.0 1.23e-02    -  1.00e+00 1.00e+00h  1
  11  5.8127612e+03 1.60e-05 1.36e-02  -2.5 8.27e-03    -  1.00e+00 1.00e+00f  1
  12  5.8126464e+03 2.60e-07 1.15e-04  -3.8 1.05e-03    -  1.00e+00 1.00e+00f  1
  13  5.8126430e+03 1.32e-10 8.31e-08  -5.7 2.50e-05    -  1.00e+00 1.00e+00h  1
  14  5.8126429e+03 7.55e-15 6.25e-12  -8.6 1.78e-07    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 14

                                   (scaled)                 (unscaled)
Objective...............:   1.1625285870072360e+03    5.8126429350361796e+03
Dual infeasibility......:   6.2541517268298295e-12    3.1270758634149147e-11
Constraint violation....:   7.5495165674510645e-15    7.5495165674510645e-15
Variable bound violation:   1.0911841874516881e-08    1.0911841874516881e-08
Complementarity.........:   2.5102170848799089e-09    1.2551085424399544e-08
Overall NLP error.......:   2.5102170848799089e-09    1.2551085424399544e-08


Number of objective function evaluations             = 15
Number of objective gradient evaluations             = 15
Number of equality constraint evaluations            = 15
Number of inequality constraint evaluations          = 15
Number of equality constraint Jacobian evaluations   = 15
Number of inequality constraint Jacobian evaluations = 15
Number of Lagrangian Hessian evaluations             = 14
Total seconds in IPOPT                               = 0.799

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:       78
Number of nonzeros in inequality constraint Jacobian.:       24
Number of nonzeros in Lagrangian Hessian.............:      122

Total number of variables............................:       23
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       20
                     variables with only upper bounds:        0
Total number of equality constraints.................:       19
Total number of inequality constraints...............:       12
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       12

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.3949934e+00 1.09e+00 1.67e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.1048421e+03 4.62e-01 1.04e+02  -1.0 1.81e+00    -  5.77e-03 5.76e-01h  1
   2  4.4503068e+03 1.36e-01 3.09e+01  -1.0 8.29e-01    -  8.15e-01 7.05e-01h  1
   3  4.6140270e+03 1.18e-01 2.67e+01  -1.0 2.99e-01    -  4.13e-01 1.37e-01h  1
   4  4.9343698e+03 8.25e-02 3.85e+01  -1.0 4.36e-01    -  4.94e-01 2.98e-01h  1
   5  5.4019378e+03 3.46e-02 2.51e+01  -1.0 3.62e-01    -  9.90e-01 5.81e-01h  1
   6  5.4116196e+03 3.37e-02 1.26e+02  -1.0 1.45e-01    -  1.84e-01 2.70e-02h  1
   7  5.6094774e+03 1.60e-02 5.13e+01  -1.0 2.53e-01    -  2.76e-01 5.25e-01h  1
   8  5.7031738e+03 8.53e-03 8.21e+01  -1.0 1.43e-01    -  7.00e-01 4.67e-01h  1
   9  5.8145457e+03 6.10e-04 2.19e+00  -1.0 5.77e-02    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  5.8146316e+03 2.55e-05 7.83e-03  -1.0 1.23e-02    -  1.00e+00 1.00e+00h  1
  11  5.8127612e+03 1.60e-05 1.36e-02  -2.5 8.27e-03    -  1.00e+00 1.00e+00f  1
  12  5.8126464e+03 2.60e-07 1.15e-04  -3.8 1.05e-03    -  1.00e+00 1.00e+00f  1
  13  5.8126430e+03 1.32e-10 8.31e-08  -5.7 2.50e-05    -  1.00e+00 1.00e+00h  1
  14  5.8126429e+03 7.55e-15 6.25e-12  -8.6 1.78e-07    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 14

                                   (scaled)                 (unscaled)
Objective...............:   1.1625285870072360e+03    5.8126429350361796e+03
Dual infeasibility......:   6.2541517268298295e-12    3.1270758634149147e-11
Constraint violation....:   7.5495165674510645e-15    7.5495165674510645e-15
Variable bound violation:   1.0911841874516881e-08    1.0911841874516881e-08
Complementarity.........:   2.5102170848799089e-09    1.2551085424399544e-08
Overall NLP error.......:   2.5102170848799089e-09    1.2551085424399544e-08


Number of objective function evaluations             = 15
Number of objective gradient evaluations             = 15
Number of equality constraint evaluations            = 15
Number of inequality constraint evaluations          = 15
Number of equality constraint Jacobian evaluations   = 15
Number of inequality constraint Jacobian evaluations = 15
Number of Lagrangian Hessian evaluations             = 14
Total seconds in IPOPT                               = 0.008

EXIT: Optimal Solution Found.
file = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      155
Number of nonzeros in inequality constraint Jacobian.:       48
Number of nonzeros in Lagrangian Hessian.............:      240

Total number of variables............................:       44
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       39
                     variables with only upper bounds:        0
Total number of equality constraints.................:       35
Total number of inequality constraints...............:       24
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       24

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0059989e+02 3.99e+00 2.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  8.3066305e+03 2.47e+00 1.01e+02  -1.0 2.78e+00    -  4.11e-03 3.82e-01h  1
   2  6.7181372e+03 2.36e+00 9.62e+01  -1.0 1.60e+01    -  7.37e-02 4.44e-02f  1
   3  6.6689587e+03 2.30e+00 9.34e+01  -1.0 1.30e+01    -  4.94e-01 2.40e-02f  1
   4  6.5741805e+03 2.04e+00 8.25e+01  -1.0 1.29e+01    -  3.67e-01 1.12e-01f  2
   5  6.8264259e+03 1.80e+00 7.10e+01  -1.0 1.23e+01    -  8.72e-01 1.20e-01h  2
   6  8.8540136e+03 1.08e+00 4.20e+01  -1.0 9.14e+00    -  5.92e-01 4.00e-01h  1
   7  1.0572806e+04 8.62e-01 3.58e+01  -1.0 2.94e+00    -  4.93e-01 2.00e-01h  1
   8  1.7308577e+04 3.63e-02 1.46e+01  -1.0 2.41e+00    -  7.65e-01 9.58e-01h  1
   9  1.7572869e+04 1.33e-02 1.10e+00  -1.0 2.11e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7590631e+04 1.68e-03 1.61e-01  -1.0 5.04e-01    -  1.00e+00 1.00e+00h  1
  11  1.7558724e+04 5.24e-03 5.03e-01  -2.5 6.03e-01    -  8.35e-01 9.36e-01f  1
  12  1.7553111e+04 3.34e-03 4.12e+00  -2.5 2.84e-01    -  1.00e+00 8.20e-01h  1
  13  1.7552956e+04 3.24e-05 1.26e-02  -2.5 6.35e-02    -  1.00e+00 1.00e+00h  1
  14  1.7551990e+04 1.35e-05 1.09e+00  -3.8 2.53e-02    -  1.00e+00 9.25e-01h  1
  15  1.7551938e+04 4.46e-08 1.22e-02  -3.8 7.00e-03    -  1.00e+00 1.00e+00f  1
  16  1.7551940e+04 2.35e-10 2.06e-04  -3.8 3.83e-04    -  1.00e+00 1.00e+00h  1
  17  1.7551893e+04 1.75e-07 2.10e-01  -5.7 2.49e-03    -  1.00e+00 9.68e-01f  1
  18  1.7551891e+04 6.80e-11 3.09e-05  -5.7 2.38e-04    -  1.00e+00 1.00e+00f  1
  19  1.7551891e+04 5.68e-14 6.47e-10  -5.7 5.17e-07    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.7551891e+04 6.26e-12 3.03e-07  -8.6 3.52e-05    -  1.00e+00 1.00e+00f  1
  21  1.7551891e+04 5.68e-14 3.38e-12  -8.6 3.33e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 21

                                   (scaled)                 (unscaled)
Objective...............:   4.3879727248486898e+02    1.7551890899394759e+04
Dual infeasibility......:   3.3822003142280486e-12    1.3528801256912194e-10
Constraint violation....:   3.6743585951626306e-14    5.6843418860808015e-14
Variable bound violation:   2.9463905093507492e-08    2.9463905093507492e-08
Complementarity.........:   2.5059076126917168e-09    1.0023630450766867e-07
Overall NLP error.......:   2.5059076126917168e-09    1.0023630450766867e-07


Number of objective function evaluations             = 28
Number of objective gradient evaluations             = 22
Number of equality constraint evaluations            = 28
Number of inequality constraint evaluations          = 28
Number of equality constraint Jacobian evaluations   = 22
Number of inequality constraint Jacobian evaluations = 22
Number of Lagrangian Hessian evaluations             = 21
Total seconds in IPOPT                               = 1.356

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      155
Number of nonzeros in inequality constraint Jacobian.:       48
Number of nonzeros in Lagrangian Hessian.............:      240

Total number of variables............................:       44
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       39
                     variables with only upper bounds:        0
Total number of equality constraints.................:       35
Total number of inequality constraints...............:       24
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       24

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0059989e+02 3.99e+00 2.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  8.3066305e+03 2.47e+00 1.01e+02  -1.0 2.78e+00    -  4.11e-03 3.82e-01h  1
   2  6.7181372e+03 2.36e+00 9.62e+01  -1.0 1.60e+01    -  7.37e-02 4.44e-02f  1
   3  6.6689587e+03 2.30e+00 9.34e+01  -1.0 1.30e+01    -  4.94e-01 2.40e-02f  1
   4  6.5741805e+03 2.04e+00 8.25e+01  -1.0 1.29e+01    -  3.67e-01 1.12e-01f  2
   5  6.8264259e+03 1.80e+00 7.10e+01  -1.0 1.23e+01    -  8.72e-01 1.20e-01h  2
   6  8.8540136e+03 1.08e+00 4.20e+01  -1.0 9.14e+00    -  5.92e-01 4.00e-01h  1
   7  1.0572806e+04 8.62e-01 3.58e+01  -1.0 2.94e+00    -  4.93e-01 2.00e-01h  1
   8  1.7308577e+04 3.63e-02 1.46e+01  -1.0 2.41e+00    -  7.65e-01 9.58e-01h  1
   9  1.7572869e+04 1.33e-02 1.10e+00  -1.0 2.11e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7590631e+04 1.68e-03 1.61e-01  -1.0 5.04e-01    -  1.00e+00 1.00e+00h  1
  11  1.7558724e+04 5.24e-03 5.03e-01  -2.5 6.03e-01    -  8.35e-01 9.36e-01f  1
  12  1.7553111e+04 3.34e-03 4.12e+00  -2.5 2.84e-01    -  1.00e+00 8.20e-01h  1
  13  1.7552956e+04 3.24e-05 1.26e-02  -2.5 6.35e-02    -  1.00e+00 1.00e+00h  1
  14  1.7551990e+04 1.35e-05 1.09e+00  -3.8 2.53e-02    -  1.00e+00 9.25e-01h  1
  15  1.7551938e+04 4.46e-08 1.22e-02  -3.8 7.00e-03    -  1.00e+00 1.00e+00f  1
  16  1.7551940e+04 2.35e-10 2.06e-04  -3.8 3.83e-04    -  1.00e+00 1.00e+00h  1
  17  1.7551893e+04 1.75e-07 2.10e-01  -5.7 2.49e-03    -  1.00e+00 9.68e-01f  1
  18  1.7551891e+04 6.80e-11 3.09e-05  -5.7 2.38e-04    -  1.00e+00 1.00e+00f  1
  19  1.7551891e+04 5.68e-14 6.47e-10  -5.7 5.17e-07    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.7551891e+04 6.26e-12 3.03e-07  -8.6 3.52e-05    -  1.00e+00 1.00e+00f  1
  21  1.7551891e+04 5.68e-14 3.38e-12  -8.6 3.33e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 21

                                   (scaled)                 (unscaled)
Objective...............:   4.3879727248486898e+02    1.7551890899394759e+04
Dual infeasibility......:   3.3822003142280486e-12    1.3528801256912194e-10
Constraint violation....:   3.6743585951626306e-14    5.6843418860808015e-14
Variable bound violation:   2.9463905093507492e-08    2.9463905093507492e-08
Complementarity.........:   2.5059076126917168e-09    1.0023630450766867e-07
Overall NLP error.......:   2.5059076126917168e-09    1.0023630450766867e-07


Number of objective function evaluations             = 28
Number of objective gradient evaluations             = 22
Number of equality constraint evaluations            = 28
Number of inequality constraint evaluations          = 28
Number of equality constraint Jacobian evaluations   = 22
Number of inequality constraint Jacobian evaluations = 22
Number of Lagrangian Hessian evaluations             = 21
Total seconds in IPOPT                               = 0.016

EXIT: Optimal Solution Found.
2×23 DataFrame
 Row │ case                    vars   cons   optimization  optimization_modelb ⋯
     │ String                  Int64  Int64  Float64       Float64             ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ pglib_opf_case3_lmbd.m     24     28     0.0761628                4.997 ⋯
   2 │ pglib_opf_case5_pjm.m      44     53     0.395627                 4.678
                                                              19 columns omitted</code></pre><pre><code class="language-julia hljs">io = IOBuffer()
println(io, &quot;```@raw html&quot;)
pretty_table(io, timing_data; backend = Val(:html))
# show(io, &quot;text/html&quot;, pretty_table(timing_data; backend = Val(:html)))
println(io, &quot;```&quot;)
Text(String(take!(io)))</code></pre><table>
  <thead>
    <tr class = "header">
      <th style = "text-align: right;">case</th>
      <th style = "text-align: right;">vars</th>
      <th style = "text-align: right;">cons</th>
      <th style = "text-align: right;">optimization</th>
      <th style = "text-align: right;">optimization_modelbuild</th>
      <th style = "text-align: right;">optimization_wcompilation</th>
      <th style = "text-align: right;">optimization_cost</th>
      <th style = "text-align: right;">mtk</th>
      <th style = "text-align: right;">mtk_time_modelbuild</th>
      <th style = "text-align: right;">mtk_time_wcompilation</th>
      <th style = "text-align: right;">mtk_cost</th>
      <th style = "text-align: right;">jump</th>
      <th style = "text-align: right;">jump_modelbuild</th>
      <th style = "text-align: right;">jump_wcompilation</th>
      <th style = "text-align: right;">jump_cost</th>
      <th style = "text-align: right;">nlpmodels</th>
      <th style = "text-align: right;">nlpmodels_modelbuild</th>
      <th style = "text-align: right;">nlpmodels_wcompilation</th>
      <th style = "text-align: right;">nlpmodels_cost</th>
      <th style = "text-align: right;">optim</th>
      <th style = "text-align: right;">optim_modelbuild</th>
      <th style = "text-align: right;">optim_wcompilation</th>
      <th style = "text-align: right;">optim_cost</th>
    </tr>
    <tr class = "subheader headerLastRow">
      <th style = "text-align: right;">String</th>
      <th style = "text-align: right;">Int64</th>
      <th style = "text-align: right;">Int64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style = "text-align: right;">pglib_opf_case3_lmbd.m</td>
      <td style = "text-align: right;">24</td>
      <td style = "text-align: right;">28</td>
      <td style = "text-align: right;">0.0761628</td>
      <td style = "text-align: right;">4.9979e-5</td>
      <td style = "text-align: right;">0.0745601</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.0169464</td>
      <td style = "text-align: right;">1.25872</td>
      <td style = "text-align: right;">3.08062</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.00765398</td>
      <td style = "text-align: right;">0.00178746</td>
      <td style = "text-align: right;">0.00805817</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.0170089</td>
      <td style = "text-align: right;">0.0149911</td>
      <td style = "text-align: right;">0.0178768</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">2.07783</td>
      <td style = "text-align: right;">0.000258597</td>
      <td style = "text-align: right;">2.10584</td>
      <td style = "text-align: right;">6273.63</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case5_pjm.m</td>
      <td style = "text-align: right;">44</td>
      <td style = "text-align: right;">53</td>
      <td style = "text-align: right;">0.395627</td>
      <td style = "text-align: right;">4.6789e-5</td>
      <td style = "text-align: right;">0.426829</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.0319069</td>
      <td style = "text-align: right;">0.36729</td>
      <td style = "text-align: right;">2.70288</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.0121948</td>
      <td style = "text-align: right;">0.00211386</td>
      <td style = "text-align: right;">0.0125961</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.0349266</td>
      <td style = "text-align: right;">0.0261484</td>
      <td style = "text-align: right;">0.0355382</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">17.1599</td>
      <td style = "text-align: right;">0.000399686</td>
      <td style = "text-align: right;">17.1126</td>
      <td style = "text-align: right;">77.9548</td>
    </tr>
  </tbody>
</table><h2 id="Run-the-Full-Benchmark"><a class="docs-heading-anchor" href="#Run-the-Full-Benchmark">Run the Full Benchmark</a><a id="Run-the-Full-Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-Full-Benchmark" title="Permalink"></a></h2><pre><code class="language-julia hljs">using LibGit2
tmpdir = Base.Filesystem.mktempdir()
LibGit2.clone(&quot;https://github.com/power-grid-lib/pglib-opf&quot;, tmpdir)
benchmarkfiles = readdir(tmpdir)
benchmarkfiles = benchmarkfiles[endswith(&quot;.m&quot;).(benchmarkfiles)]
benchmark_datasets = joinpath.((tmpdir,),benchmarkfiles)</code></pre><pre><code class="nohighlight hljs">66-element Vector{String}:
 &quot;/tmp/jl_XPUwWW/pglib_opf_case10000_goc.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case10192_epigrids.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case10480_goc.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case118_ieee.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case1354_pegase.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case13659_pegase.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case14_ieee.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case162_ieee_dtc.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case179_goc.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case1803_snem.m&quot;
 ⋮
 &quot;/tmp/jl_XPUwWW/pglib_opf_case6515_rte.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case7336_epigrids.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case73_ieee_rts.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case78484_epigrids.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case793_goc.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case8387_pegase.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case89_pegase.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case9241_pegase.m&quot;
 &quot;/tmp/jl_XPUwWW/pglib_opf_case9591_goc.m&quot;</code></pre><pre><code class="language-julia hljs">timing_data = multidata_multisolver_benchmark(benchmark_datasets)</code></pre><pre><code class="nohighlight hljs">file = &quot;/tmp/jl_XPUwWW/pglib_opf_case10000_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case10192_epigrids.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case10480_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case118_ieee.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case1354_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case13659_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case14_ieee.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      489
Number of nonzeros in inequality constraint Jacobian.:      160
Number of nonzeros in Lagrangian Hessian.............:      791

Total number of variables............................:      115
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      101
                     variables with only upper bounds:        0
Total number of equality constraints.................:      109
Total number of inequality constraints...............:       80
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       80

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.1649922e+01 9.42e-01 1.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.4464214e+03 2.50e-01 1.33e+02  -1.0 1.81e+00    -  5.61e-03 7.34e-01H  1
   2  2.3967630e+03 4.55e-02 8.94e+01  -1.0 1.75e+00    -  1.74e-02 9.97e-01f  1
   3  2.1633361e+03 4.42e-02 8.75e+01  -1.0 2.61e+01    -  2.18e-01 1.95e-02f  1
   4  2.1823081e+03 8.47e-04 1.41e+01  -1.0 8.82e-01    -  7.57e-01 1.00e+00h  1
   5  2.1890842e+03 3.76e-03 7.25e-01  -1.0 6.67e-02    -  1.00e+00 1.00e+00f  1
   6  2.1849633e+03 4.30e-04 5.24e-01  -1.7 1.38e-02    -  9.64e-01 1.00e+00h  1
   7  2.1794160e+03 2.31e-03 2.33e-02  -1.7 4.13e-02    -  1.00e+00 1.00e+00f  1
   8  2.1786673e+03 6.12e-04 2.89e-01  -3.8 7.90e-03    -  8.46e-01 7.40e-01h  1
   9  2.1780966e+03 1.45e-04 3.05e-01  -3.8 4.14e-02    -  4.43e-01 9.69e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  2.1780936e+03 7.00e-06 6.66e-04  -3.8 1.35e-02    -  1.00e+00 1.00e+00h  1
  11  2.1780803e+03 1.65e-06 9.68e-04  -5.7 4.57e-03    -  9.56e-01 9.45e-01h  1
  12  2.1780805e+03 1.82e-07 1.04e-05  -5.7 1.67e-03    -  1.00e+00 1.00e+00h  1
  13  2.1780804e+03 2.19e-09 2.91e-06  -8.6 1.68e-04    -  1.00e+00 9.99e-01h  1
  14  2.1780804e+03 1.10e-09 1.44e-05  -8.6 2.01e-06    -  1.00e+00 5.00e-01f  2
  15  2.1780804e+03 6.66e-14 3.85e-12  -8.6 1.01e-06    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 15

                                   (scaled)                 (unscaled)
Objective...............:   9.3602396804143993e+01    2.1780804108196480e+03
Dual infeasibility......:   3.8475889141409425e-12    8.9531447152069183e-11
Constraint violation....:   6.6613381477509392e-14    6.6613381477509392e-14
Variable bound violation:   1.0340993394919451e-08    1.0340993394919451e-08
Complementarity.........:   2.5059040485519189e-09    5.8311119222354586e-08
Overall NLP error.......:   2.5059040485519189e-09    5.8311119222354586e-08


Number of objective function evaluations             = 18
Number of objective gradient evaluations             = 16
Number of equality constraint evaluations            = 18
Number of inequality constraint evaluations          = 18
Number of equality constraint Jacobian evaluations   = 16
Number of inequality constraint Jacobian evaluations = 16
Number of Lagrangian Hessian evaluations             = 15
Total seconds in IPOPT                               = 4.395

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      489
Number of nonzeros in inequality constraint Jacobian.:      160
Number of nonzeros in Lagrangian Hessian.............:      791

Total number of variables............................:      115
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      101
                     variables with only upper bounds:        0
Total number of equality constraints.................:      109
Total number of inequality constraints...............:       80
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       80

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.1649922e+01 9.42e-01 1.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.4464214e+03 2.50e-01 1.33e+02  -1.0 1.81e+00    -  5.61e-03 7.34e-01H  1
   2  2.3967630e+03 4.55e-02 8.94e+01  -1.0 1.75e+00    -  1.74e-02 9.97e-01f  1
   3  2.1633361e+03 4.42e-02 8.75e+01  -1.0 2.61e+01    -  2.18e-01 1.95e-02f  1
   4  2.1823081e+03 8.47e-04 1.41e+01  -1.0 8.82e-01    -  7.57e-01 1.00e+00h  1
   5  2.1890842e+03 3.76e-03 7.25e-01  -1.0 6.67e-02    -  1.00e+00 1.00e+00f  1
   6  2.1849633e+03 4.30e-04 5.24e-01  -1.7 1.38e-02    -  9.64e-01 1.00e+00h  1
   7  2.1794160e+03 2.31e-03 2.33e-02  -1.7 4.13e-02    -  1.00e+00 1.00e+00f  1
   8  2.1786673e+03 6.12e-04 2.89e-01  -3.8 7.90e-03    -  8.46e-01 7.40e-01h  1
   9  2.1780966e+03 1.45e-04 3.05e-01  -3.8 4.14e-02    -  4.43e-01 9.69e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  2.1780936e+03 7.00e-06 6.66e-04  -3.8 1.35e-02    -  1.00e+00 1.00e+00h  1
  11  2.1780803e+03 1.65e-06 9.68e-04  -5.7 4.57e-03    -  9.56e-01 9.45e-01h  1
  12  2.1780805e+03 1.82e-07 1.04e-05  -5.7 1.67e-03    -  1.00e+00 1.00e+00h  1
  13  2.1780804e+03 2.19e-09 2.91e-06  -8.6 1.68e-04    -  1.00e+00 9.99e-01h  1
  14  2.1780804e+03 1.10e-09 1.44e-05  -8.6 2.01e-06    -  1.00e+00 5.00e-01f  2
  15  2.1780804e+03 6.66e-14 3.85e-12  -8.6 1.01e-06    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 15

                                   (scaled)                 (unscaled)
Objective...............:   9.3602396804143993e+01    2.1780804108196480e+03
Dual infeasibility......:   3.8475889141409425e-12    8.9531447152069183e-11
Constraint violation....:   6.6613381477509392e-14    6.6613381477509392e-14
Variable bound violation:   1.0340993394919451e-08    1.0340993394919451e-08
Complementarity.........:   2.5059040485519189e-09    5.8311119222354586e-08
Overall NLP error.......:   2.5059040485519189e-09    5.8311119222354586e-08


Number of objective function evaluations             = 18
Number of objective gradient evaluations             = 16
Number of equality constraint evaluations            = 18
Number of inequality constraint evaluations          = 18
Number of equality constraint Jacobian evaluations   = 16
Number of inequality constraint Jacobian evaluations = 16
Number of Lagrangian Hessian evaluations             = 15
Total seconds in IPOPT                               = 0.023

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case162_ieee_dtc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case179_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case1803_snem.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case1888_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case19402_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case1951_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case197_snem.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2000_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case200_activ.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case20758_epigrids.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2312_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2383wp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case240_pserc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case24464_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case24_ieee_rts.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      979
Number of nonzeros in inequality constraint Jacobian.:      304
Number of nonzeros in Lagrangian Hessian.............:     1543

Total number of variables............................:      265
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      241
                     variables with only upper bounds:        0
Total number of equality constraints.................:      201
Total number of inequality constraints...............:      152
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      152

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  4.0097983e+04 2.52e+00 4.56e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  5.6173148e+04 1.56e+00 6.27e+01  -1.0 2.38e+00    -  1.00e-02 3.79e-01h  1
   2  5.3163376e+04 1.35e+00 5.43e+01  -1.0 6.42e+00    -  1.34e-02 1.39e-01f  1
   3  5.2196944e+04 1.33e+00 5.02e+01  -1.0 8.86e+00    -  3.43e-01 1.34e-02f  1
   4  5.3182043e+04 1.06e+00 3.73e+01  -1.0 7.58e+00    -  7.33e-01 2.03e-01h  1
   5  5.5137462e+04 3.87e-01 1.31e+01  -1.0 9.48e+00    -  9.74e-01 6.34e-01H  1
   6  5.4942906e+04 3.18e-01 1.19e+01  -1.0 1.03e+01    -  4.67e-01 1.79e-01f  1
   7  5.5363333e+04 2.73e-01 1.12e+01  -1.0 7.18e+00    -  1.00e+00 1.42e-01h  1
   8  5.5935463e+04 2.33e-01 6.62e+00  -1.0 3.08e+00    -  2.59e-01 1.44e-01h  1
   9  6.2388698e+04 6.41e-02 5.12e+00  -1.0 1.40e+00    -  6.92e-01 8.82e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  6.3791569e+04 2.81e-03 8.67e-01  -1.0 1.80e+00    -  7.56e-01 1.00e+00h  1
  11  6.3501031e+04 8.45e-04 6.21e-01  -1.7 1.69e-01    -  8.51e-01 1.00e+00f  1
  12  6.3454928e+04 1.01e-03 1.25e-02  -1.7 1.02e-01    -  1.00e+00 1.00e+00h  1
  13  6.3378078e+04 8.53e-04 1.25e-01  -3.8 1.49e-01    -  8.03e-01 7.30e-01f  1
  14  6.3364846e+04 4.37e-04 2.13e+00  -3.8 2.00e-01    -  7.95e-01 5.13e-01h  1
  15  6.3352718e+04 1.22e-04 8.47e-02  -3.8 2.47e-01    -  1.00e+00 9.79e-01h  1
  16  6.3352941e+04 1.86e-06 2.89e-05  -3.8 9.06e-03    -  1.00e+00 1.00e+00h  1
  17  6.3352216e+04 3.36e-07 5.07e-04  -5.7 9.37e-03    -  9.90e-01 9.93e-01h  1
  18  6.3352210e+04 1.17e-09 2.51e-08  -5.7 1.81e-04    -  1.00e+00 1.00e+00h  1
  19  6.3352201e+04 5.65e-11 8.23e-10  -8.6 1.04e-04    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 19

                                   (scaled)                 (unscaled)
Objective...............:   4.8732462373895481e+02    6.3352201086064124e+04
Dual infeasibility......:   8.2331781542267553e-10    1.0703131600494782e-07
Constraint violation....:   5.6523674629715970e-11    5.6523674629715970e-11
Variable bound violation:   3.9922449346363464e-08    3.9922449346363464e-08
Complementarity.........:   3.7502813809752752e-09    4.8753657952678579e-07
Overall NLP error.......:   3.7502813809752752e-09    4.8753657952678579e-07


Number of objective function evaluations             = 21
Number of objective gradient evaluations             = 20
Number of equality constraint evaluations            = 21
Number of inequality constraint evaluations          = 21
Number of equality constraint Jacobian evaluations   = 20
Number of inequality constraint Jacobian evaluations = 20
Number of Lagrangian Hessian evaluations             = 19
Total seconds in IPOPT                               = 11.453

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      979
Number of nonzeros in inequality constraint Jacobian.:      304
Number of nonzeros in Lagrangian Hessian.............:     1543

Total number of variables............................:      265
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      241
                     variables with only upper bounds:        0
Total number of equality constraints.................:      201
Total number of inequality constraints...............:      152
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      152

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  4.0097983e+04 2.52e+00 4.56e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  5.6173148e+04 1.56e+00 6.27e+01  -1.0 2.38e+00    -  1.00e-02 3.79e-01h  1
   2  5.3163376e+04 1.35e+00 5.43e+01  -1.0 6.42e+00    -  1.34e-02 1.39e-01f  1
   3  5.2196944e+04 1.33e+00 5.02e+01  -1.0 8.86e+00    -  3.43e-01 1.34e-02f  1
   4  5.3182043e+04 1.06e+00 3.73e+01  -1.0 7.58e+00    -  7.33e-01 2.03e-01h  1
   5  5.5137462e+04 3.87e-01 1.31e+01  -1.0 9.48e+00    -  9.74e-01 6.34e-01H  1
   6  5.4942906e+04 3.18e-01 1.19e+01  -1.0 1.03e+01    -  4.67e-01 1.79e-01f  1
   7  5.5363333e+04 2.73e-01 1.12e+01  -1.0 7.18e+00    -  1.00e+00 1.42e-01h  1
   8  5.5935463e+04 2.33e-01 6.62e+00  -1.0 3.08e+00    -  2.59e-01 1.44e-01h  1
   9  6.2388698e+04 6.41e-02 5.12e+00  -1.0 1.40e+00    -  6.92e-01 8.82e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  6.3791569e+04 2.81e-03 8.67e-01  -1.0 1.80e+00    -  7.56e-01 1.00e+00h  1
  11  6.3501031e+04 8.45e-04 6.21e-01  -1.7 1.69e-01    -  8.51e-01 1.00e+00f  1
  12  6.3454928e+04 1.01e-03 1.25e-02  -1.7 1.02e-01    -  1.00e+00 1.00e+00h  1
  13  6.3378078e+04 8.53e-04 1.25e-01  -3.8 1.49e-01    -  8.03e-01 7.30e-01f  1
  14  6.3364846e+04 4.37e-04 2.13e+00  -3.8 2.00e-01    -  7.95e-01 5.13e-01h  1
  15  6.3352718e+04 1.22e-04 8.47e-02  -3.8 2.47e-01    -  1.00e+00 9.79e-01h  1
  16  6.3352941e+04 1.86e-06 2.89e-05  -3.8 9.06e-03    -  1.00e+00 1.00e+00h  1
  17  6.3352216e+04 3.36e-07 5.07e-04  -5.7 9.37e-03    -  9.90e-01 9.93e-01h  1
  18  6.3352210e+04 1.17e-09 2.51e-08  -5.7 1.81e-04    -  1.00e+00 1.00e+00h  1
  19  6.3352201e+04 5.65e-11 8.23e-10  -8.6 1.04e-04    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 19

                                   (scaled)                 (unscaled)
Objective...............:   4.8732462373895481e+02    6.3352201086064124e+04
Dual infeasibility......:   8.2331781542267553e-10    1.0703131600494782e-07
Constraint violation....:   5.6523674629715970e-11    5.6523674629715970e-11
Variable bound violation:   3.9922449346363464e-08    3.9922449346363464e-08
Complementarity.........:   3.7502813809752752e-09    4.8753657952678579e-07
Overall NLP error.......:   3.7502813809752752e-09    4.8753657952678579e-07


Number of objective function evaluations             = 21
Number of objective gradient evaluations             = 20
Number of equality constraint evaluations            = 21
Number of inequality constraint evaluations          = 21
Number of equality constraint Jacobian evaluations   = 20
Number of inequality constraint Jacobian evaluations = 20
Number of Lagrangian Hessian evaluations             = 19
Total seconds in IPOPT                               = 0.051

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2736sp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2737sop_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2742_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2746wop_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2746wp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2848_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2853_sdet.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2868_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case2869_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case30000_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case300_ieee.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3012wp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3022_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case30_as.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      999
Number of nonzeros in inequality constraint Jacobian.:      328
Number of nonzeros in Lagrangian Hessian.............:     1634

Total number of variables............................:      236
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      206
                     variables with only upper bounds:        0
Total number of equality constraints.................:      225
Total number of inequality constraints...............:      164
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      164

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.9330612e+02 7.89e-01 6.98e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  7.3680988e+02 1.06e-01 4.80e+01  -1.0 7.66e-01    -  1.76e-02 8.65e-01h  1
   2  7.6515454e+02 5.53e-02 2.51e+01  -1.0 9.70e-01    -  7.06e-01 4.79e-01h  1
   3  8.0390995e+02 9.81e-03 3.83e+00  -1.0 6.95e-01    -  1.00e+00 1.00e+00h  1
   4  8.0419681e+02 2.85e-04 1.48e-01  -1.0 1.06e-01    -  1.00e+00 1.00e+00h  1
   5  8.0355508e+02 1.29e-04 2.65e-02  -1.7 7.56e-02    -  1.00e+00 1.00e+00f  1
   6  8.0322260e+02 1.45e-04 2.45e-02  -2.5 4.50e-02    -  9.81e-01 1.00e+00f  1
   7  8.0312215e+02 2.25e-04 7.52e-02  -3.8 4.76e-02    -  8.87e-01 9.26e-01h  1
   8  8.0312831e+02 3.92e-05 5.43e-04  -3.8 1.60e-02    -  1.00e+00 1.00e+00h  1
   9  8.0312738e+02 1.51e-06 2.40e-04  -5.7 4.36e-03    -  1.00e+00 9.98e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.0312733e+02 3.89e-09 4.27e-07  -5.7 3.29e-04    -  1.00e+00 1.00e+00f  1
  11  8.0312731e+02 7.14e-11 1.82e-09  -8.6 2.73e-05    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 11

                                   (scaled)                 (unscaled)
Objective...............:   2.4711609550316729e+02    8.0312731038529364e+02
Dual infeasibility......:   1.8152057634779339e-09    5.8994187313032853e-09
Constraint violation....:   7.1401551338112768e-11    7.1401551338112768e-11
Variable bound violation:   1.0369035186030828e-08    1.0369035186030828e-08
Complementarity.........:   3.8105847373601750e-09    1.2384400396420568e-08
Overall NLP error.......:   3.8105847373601750e-09    1.2384400396420568e-08


Number of objective function evaluations             = 12
Number of objective gradient evaluations             = 12
Number of equality constraint evaluations            = 12
Number of inequality constraint evaluations          = 12
Number of equality constraint Jacobian evaluations   = 12
Number of inequality constraint Jacobian evaluations = 12
Number of Lagrangian Hessian evaluations             = 11
Total seconds in IPOPT                               = 11.386

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      999
Number of nonzeros in inequality constraint Jacobian.:      328
Number of nonzeros in Lagrangian Hessian.............:     1634

Total number of variables............................:      236
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      206
                     variables with only upper bounds:        0
Total number of equality constraints.................:      225
Total number of inequality constraints...............:      164
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      164

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.9330612e+02 7.89e-01 6.98e+00  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  7.3680988e+02 1.06e-01 4.80e+01  -1.0 7.66e-01    -  1.76e-02 8.65e-01h  1
   2  7.6515454e+02 5.53e-02 2.51e+01  -1.0 9.70e-01    -  7.06e-01 4.79e-01h  1
   3  8.0390995e+02 9.81e-03 3.83e+00  -1.0 6.95e-01    -  1.00e+00 1.00e+00h  1
   4  8.0419681e+02 2.85e-04 1.48e-01  -1.0 1.06e-01    -  1.00e+00 1.00e+00h  1
   5  8.0355508e+02 1.29e-04 2.65e-02  -1.7 7.56e-02    -  1.00e+00 1.00e+00f  1
   6  8.0322260e+02 1.45e-04 2.45e-02  -2.5 4.50e-02    -  9.81e-01 1.00e+00f  1
   7  8.0312215e+02 2.25e-04 7.52e-02  -3.8 4.76e-02    -  8.87e-01 9.26e-01h  1
   8  8.0312831e+02 3.92e-05 5.43e-04  -3.8 1.60e-02    -  1.00e+00 1.00e+00h  1
   9  8.0312738e+02 1.51e-06 2.40e-04  -5.7 4.36e-03    -  1.00e+00 9.98e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.0312733e+02 3.89e-09 4.27e-07  -5.7 3.29e-04    -  1.00e+00 1.00e+00f  1
  11  8.0312731e+02 7.14e-11 1.82e-09  -8.6 2.73e-05    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 11

                                   (scaled)                 (unscaled)
Objective...............:   2.4711609550316729e+02    8.0312731038529364e+02
Dual infeasibility......:   1.8152057634779339e-09    5.8994187313032853e-09
Constraint violation....:   7.1401551338112768e-11    7.1401551338112768e-11
Variable bound violation:   1.0369035186030828e-08    1.0369035186030828e-08
Complementarity.........:   3.8105847373601750e-09    1.2384400396420568e-08
Overall NLP error.......:   3.8105847373601750e-09    1.2384400396420568e-08


Number of objective function evaluations             = 12
Number of objective gradient evaluations             = 12
Number of equality constraint evaluations            = 12
Number of inequality constraint evaluations          = 12
Number of equality constraint Jacobian evaluations   = 12
Number of inequality constraint Jacobian evaluations = 12
Number of Lagrangian Hessian evaluations             = 11
Total seconds in IPOPT                               = 0.033

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case30_ieee.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      995
Number of nonzeros in inequality constraint Jacobian.:      328
Number of nonzeros in Lagrangian Hessian.............:     1628

Total number of variables............................:      232
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      202
                     variables with only upper bounds:        0
Total number of equality constraints.................:      225
Total number of inequality constraints...............:      164
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      164

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.6429132e+01 9.42e-01 1.81e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  7.3805974e+03 1.92e-01 1.37e+02  -1.0 1.73e+00    -  5.86e-03 7.96e-01H  1
   2  7.0362117e+03 7.70e-02 5.47e+01  -1.0 1.62e+00    -  2.07e-02 6.00e-01f  1
   3  7.0544217e+03 7.45e-02 5.34e+01  -1.0 7.99e-01    -  9.68e-01 3.19e-02h  1
   4  8.2288089e+03 5.15e-04 1.49e+00  -1.0 3.21e-01    -  1.00e+00 1.00e+00h  1
   5  8.2390074e+03 3.30e-05 1.34e-01  -1.0 2.16e-02    -  1.00e+00 1.00e+00h  1
   6  8.2178583e+03 7.40e-05 4.92e-01  -2.5 2.35e-02    -  8.48e-01 9.57e-01f  1
   7  8.2101534e+03 7.44e-05 6.45e+00  -2.5 4.92e-02    -  1.00e+00 7.43e-01f  1
   8  8.2093612e+03 5.58e-06 6.10e-02  -2.5 2.33e-02    -  1.00e+00 1.00e+00f  1
   9  8.2094471e+03 1.15e-07 8.09e-03  -2.5 1.99e-03    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.2085399e+03 5.53e-06 8.48e-04  -3.8 8.62e-03    -  1.00e+00 1.00e+00f  1
  11  8.2085221e+03 8.56e-06 1.69e+01  -5.7 1.49e-03    -  8.58e-01 4.60e-01h  1
  12  8.2085142e+03 1.44e-06 1.47e-02  -5.7 1.50e-03    -  1.00e+00 1.00e+00h  1
  13  8.2085158e+03 5.61e-08 7.72e-05  -5.7 4.49e-04    -  1.00e+00 1.00e+00h  1
  14  8.2085159e+03 2.07e-09 5.33e-06  -5.7 2.37e-04    -  1.00e+00 1.00e+00h  1
  15  8.2085154e+03 5.30e-09 2.50e-03  -8.6 8.83e-05    -  9.80e-01 1.00e+00h  1
  16  8.2085154e+03 4.62e-09 2.33e-03  -8.6 1.11e-05    -  1.00e+00 1.25e-01f  4
  17  8.2085154e+03 3.63e-12 1.37e-08  -8.6 9.90e-06    -  1.00e+00 1.00e+00h  1
  18  8.2085154e+03 1.42e-14 2.54e-12  -9.0 4.10e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 18

                                   (scaled)                 (unscaled)
Objective...............:   1.5730473122733963e+02    8.2085154403067681e+03
Dual infeasibility......:   2.5374700336157655e-12    1.3241090581152641e-10
Constraint violation....:   1.4210854715202004e-14    1.4210854715202004e-14
Variable bound violation:   1.0549795703695963e-08    1.0549795703695963e-08
Complementarity.........:   9.0917662089346910e-10    4.7442885362324712e-08
Overall NLP error.......:   9.0917662089346910e-10    4.7442885362324712e-08


Number of objective function evaluations             = 23
Number of objective gradient evaluations             = 19
Number of equality constraint evaluations            = 23
Number of inequality constraint evaluations          = 23
Number of equality constraint Jacobian evaluations   = 19
Number of inequality constraint Jacobian evaluations = 19
Number of Lagrangian Hessian evaluations             = 18
Total seconds in IPOPT                               = 11.588

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      995
Number of nonzeros in inequality constraint Jacobian.:      328
Number of nonzeros in Lagrangian Hessian.............:     1628

Total number of variables............................:      232
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      202
                     variables with only upper bounds:        0
Total number of equality constraints.................:      225
Total number of inequality constraints...............:      164
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      164

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.6429132e+01 9.42e-01 1.81e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  7.3805974e+03 1.92e-01 1.37e+02  -1.0 1.73e+00    -  5.86e-03 7.96e-01H  1
   2  7.0362117e+03 7.70e-02 5.47e+01  -1.0 1.62e+00    -  2.07e-02 6.00e-01f  1
   3  7.0544217e+03 7.45e-02 5.34e+01  -1.0 7.99e-01    -  9.68e-01 3.19e-02h  1
   4  8.2288089e+03 5.15e-04 1.49e+00  -1.0 3.21e-01    -  1.00e+00 1.00e+00h  1
   5  8.2390074e+03 3.30e-05 1.34e-01  -1.0 2.16e-02    -  1.00e+00 1.00e+00h  1
   6  8.2178583e+03 7.40e-05 4.92e-01  -2.5 2.35e-02    -  8.48e-01 9.57e-01f  1
   7  8.2101534e+03 7.44e-05 6.45e+00  -2.5 4.92e-02    -  1.00e+00 7.43e-01f  1
   8  8.2093612e+03 5.58e-06 6.10e-02  -2.5 2.33e-02    -  1.00e+00 1.00e+00f  1
   9  8.2094471e+03 1.15e-07 8.09e-03  -2.5 1.99e-03    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.2085399e+03 5.53e-06 8.48e-04  -3.8 8.62e-03    -  1.00e+00 1.00e+00f  1
  11  8.2085221e+03 8.56e-06 1.69e+01  -5.7 1.49e-03    -  8.58e-01 4.60e-01h  1
  12  8.2085142e+03 1.44e-06 1.47e-02  -5.7 1.50e-03    -  1.00e+00 1.00e+00h  1
  13  8.2085158e+03 5.61e-08 7.72e-05  -5.7 4.49e-04    -  1.00e+00 1.00e+00h  1
  14  8.2085159e+03 2.07e-09 5.33e-06  -5.7 2.37e-04    -  1.00e+00 1.00e+00h  1
  15  8.2085154e+03 5.30e-09 2.50e-03  -8.6 8.83e-05    -  9.80e-01 1.00e+00h  1
  16  8.2085154e+03 4.62e-09 2.33e-03  -8.6 1.11e-05    -  1.00e+00 1.25e-01f  4
  17  8.2085154e+03 3.63e-12 1.37e-08  -8.6 9.90e-06    -  1.00e+00 1.00e+00h  1
  18  8.2085154e+03 1.42e-14 2.54e-12  -9.0 4.10e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 18

                                   (scaled)                 (unscaled)
Objective...............:   1.5730473122733963e+02    8.2085154403067681e+03
Dual infeasibility......:   2.5374700336157655e-12    1.3241090581152641e-10
Constraint violation....:   1.4210854715202004e-14    1.4210854715202004e-14
Variable bound violation:   1.0549795703695963e-08    1.0549795703695963e-08
Complementarity.........:   9.0917662089346910e-10    4.7442885362324712e-08
Overall NLP error.......:   9.0917662089346910e-10    4.7442885362324712e-08


Number of objective function evaluations             = 23
Number of objective gradient evaluations             = 19
Number of equality constraint evaluations            = 23
Number of inequality constraint evaluations          = 23
Number of equality constraint Jacobian evaluations   = 19
Number of inequality constraint Jacobian evaluations = 19
Number of Lagrangian Hessian evaluations             = 18
Total seconds in IPOPT                               = 0.052

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3120sp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3375wp_k.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3970_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case39_epri.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     1125
Number of nonzeros in inequality constraint Jacobian.:      368
Number of nonzeros in Lagrangian Hessian.............:     1832

Total number of variables............................:      282
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      243
                     variables with only upper bounds:        0
Total number of equality constraints.................:      263
Total number of inequality constraints...............:      184
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      184

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.3768629e+02 1.10e+01 1.25e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.1096016e+04 1.02e+01 6.03e+01  -1.0 6.92e+00    -  1.45e-03 7.43e-02h  2
   2  2.0586599e+04 9.35e+00 5.53e+01  -1.0 1.21e+01    -  5.88e-02 8.41e-02h  4
   3  2.8045737e+04 8.65e+00 5.11e+01  -1.0 3.53e+01    -  1.19e-01 7.49e-02h  4
   4  3.4162191e+04 8.06e+00 4.76e+01  -1.0 5.29e+01    -  2.03e-01 6.79e-02h  4
   5  4.4158466e+04 7.09e+00 4.18e+01  -1.0 6.46e+01    -  2.50e-01 1.21e-01h  3
   6  5.4914496e+04 6.03e+00 3.55e+01  -1.0 7.52e+01    -  2.65e-01 1.50e-01h  2
   7  6.6043801e+04 4.95e+00 2.90e+01  -1.0 7.38e+01    -  5.73e-01 1.79e-01h  1
   8  7.6876929e+04 4.05e+00 2.38e+01  -1.0 5.15e+01    -  5.38e-01 1.80e-01h  1
   9  9.6582595e+04 2.65e+00 1.55e+01  -1.0 5.05e+01    -  3.04e-01 3.46e-01H  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.1317794e+05 1.47e+00 8.54e+00  -1.0 6.29e+01    -  3.50e-01 4.46e-01H  1
  11  1.1373986e+05 1.43e+00 1.46e+01  -1.0 3.33e+01    -  8.90e-01 2.45e-02h  1
  12  1.2662465e+05 6.62e-01 9.96e+00  -1.0 2.83e+01    -  1.00e+00 5.38e-01h  1
  13  1.3081352e+05 4.07e-01 4.65e+00  -1.0 5.24e+01    -  8.69e-01 3.86e-01h  1
  14  1.3171708e+05 3.56e-01 9.76e+00  -1.0 1.01e+01    -  3.50e-01 1.25e-01h  1
  15  1.3630115e+05 1.14e-01 2.18e+00  -1.0 6.05e+00    -  1.00e+00 6.81e-01h  1
  16  1.3815859e+05 2.30e-02 7.46e-01  -1.0 3.59e+00    -  8.11e-01 8.46e-01h  1
  17  1.3844499e+05 4.46e-03 1.00e-01  -1.7 1.19e+00    -  9.76e-01 1.00e+00h  1
  18  1.3842260e+05 3.88e-03 1.28e+00  -2.5 5.82e-01    -  1.00e+00 6.00e-01h  1
  19  1.3841745e+05 2.48e-03 9.52e+00  -2.5 5.85e-01    -  6.99e-01 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.3841745e+05 3.85e-05 7.32e-04  -2.5 5.45e-02    -  1.00e+00 1.00e+00h  1
  21  1.3841575e+05 4.57e-05 5.16e-02  -3.8 1.08e-01    -  9.11e-01 9.17e-01h  1
  22  1.3841566e+05 7.70e-06 2.95e-04  -3.8 1.89e-02    -  1.00e+00 1.00e+00h  1
  23  1.3841557e+05 3.47e-06 1.17e-01  -5.7 9.00e-03    -  9.92e-01 9.04e-01h  1
  24  1.3841556e+05 1.69e-07 2.44e-06  -5.7 1.56e-03    -  1.00e+00 1.00e+00h  1
  25  1.3841556e+05 1.86e-10 4.07e-06  -8.6 7.90e-05    -  1.00e+00 1.00e+00h  1
  26  1.3841556e+05 1.14e-13 1.36e-11  -8.6 5.30e-08    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 26

                                   (scaled)                 (unscaled)
Objective...............:   3.9723627718148396e+03    1.3841556265037853e+05
Dual infeasibility......:   1.3577390042013769e-11    4.7309930888572472e-10
Constraint violation....:   4.9308361011817179e-14    1.1368683772161603e-13
Variable bound violation:   1.0982981990537155e-07    1.0982981990537155e-07
Complementarity.........:   2.5059244715281850e-09    8.7318043595363258e-08
Overall NLP error.......:   2.5059244715281850e-09    8.7318043595363258e-08


Number of objective function evaluations             = 55
Number of objective gradient evaluations             = 27
Number of equality constraint evaluations            = 55
Number of inequality constraint evaluations          = 55
Number of equality constraint Jacobian evaluations   = 27
Number of inequality constraint Jacobian evaluations = 27
Number of Lagrangian Hessian evaluations             = 26
Total seconds in IPOPT                               = 14.936

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     1125
Number of nonzeros in inequality constraint Jacobian.:      368
Number of nonzeros in Lagrangian Hessian.............:     1832

Total number of variables............................:      282
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      243
                     variables with only upper bounds:        0
Total number of equality constraints.................:      263
Total number of inequality constraints...............:      184
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      184

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  2.3768629e+02 1.10e+01 1.25e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.1096016e+04 1.02e+01 6.03e+01  -1.0 6.92e+00    -  1.45e-03 7.43e-02h  2
   2  2.0586599e+04 9.35e+00 5.53e+01  -1.0 1.21e+01    -  5.88e-02 8.41e-02h  4
   3  2.8045737e+04 8.65e+00 5.11e+01  -1.0 3.53e+01    -  1.19e-01 7.49e-02h  4
   4  3.4162191e+04 8.06e+00 4.76e+01  -1.0 5.29e+01    -  2.03e-01 6.79e-02h  4
   5  4.4158466e+04 7.09e+00 4.18e+01  -1.0 6.46e+01    -  2.50e-01 1.21e-01h  3
   6  5.4914496e+04 6.03e+00 3.55e+01  -1.0 7.52e+01    -  2.65e-01 1.50e-01h  2
   7  6.6043801e+04 4.95e+00 2.90e+01  -1.0 7.38e+01    -  5.73e-01 1.79e-01h  1
   8  7.6876929e+04 4.05e+00 2.38e+01  -1.0 5.15e+01    -  5.38e-01 1.80e-01h  1
   9  9.6582595e+04 2.65e+00 1.55e+01  -1.0 5.05e+01    -  3.04e-01 3.46e-01H  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.1317794e+05 1.47e+00 8.54e+00  -1.0 6.29e+01    -  3.50e-01 4.46e-01H  1
  11  1.1373986e+05 1.43e+00 1.46e+01  -1.0 3.33e+01    -  8.90e-01 2.45e-02h  1
  12  1.2662465e+05 6.62e-01 9.96e+00  -1.0 2.83e+01    -  1.00e+00 5.38e-01h  1
  13  1.3081352e+05 4.07e-01 4.65e+00  -1.0 5.24e+01    -  8.69e-01 3.86e-01h  1
  14  1.3171708e+05 3.56e-01 9.76e+00  -1.0 1.01e+01    -  3.50e-01 1.25e-01h  1
  15  1.3630115e+05 1.14e-01 2.18e+00  -1.0 6.05e+00    -  1.00e+00 6.81e-01h  1
  16  1.3815859e+05 2.30e-02 7.46e-01  -1.0 3.59e+00    -  8.11e-01 8.46e-01h  1
  17  1.3844499e+05 4.46e-03 1.00e-01  -1.7 1.19e+00    -  9.76e-01 1.00e+00h  1
  18  1.3842260e+05 3.88e-03 1.28e+00  -2.5 5.82e-01    -  1.00e+00 6.00e-01h  1
  19  1.3841745e+05 2.48e-03 9.52e+00  -2.5 5.85e-01    -  6.99e-01 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.3841745e+05 3.85e-05 7.32e-04  -2.5 5.45e-02    -  1.00e+00 1.00e+00h  1
  21  1.3841575e+05 4.57e-05 5.16e-02  -3.8 1.08e-01    -  9.11e-01 9.17e-01h  1
  22  1.3841566e+05 7.70e-06 2.95e-04  -3.8 1.89e-02    -  1.00e+00 1.00e+00h  1
  23  1.3841557e+05 3.47e-06 1.17e-01  -5.7 9.00e-03    -  9.92e-01 9.04e-01h  1
  24  1.3841556e+05 1.69e-07 2.44e-06  -5.7 1.56e-03    -  1.00e+00 1.00e+00h  1
  25  1.3841556e+05 1.86e-10 4.07e-06  -8.6 7.90e-05    -  1.00e+00 1.00e+00h  1
  26  1.3841556e+05 1.14e-13 1.36e-11  -8.6 5.30e-08    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 26

                                   (scaled)                 (unscaled)
Objective...............:   3.9723627718148396e+03    1.3841556265037853e+05
Dual infeasibility......:   1.3577390042013769e-11    4.7309930888572472e-10
Constraint violation....:   4.9308361011817179e-14    1.1368683772161603e-13
Variable bound violation:   1.0982981990537155e-07    1.0982981990537155e-07
Complementarity.........:   2.5059244715281850e-09    8.7318043595363258e-08
Overall NLP error.......:   2.5059244715281850e-09    8.7318043595363258e-08


Number of objective function evaluations             = 55
Number of objective gradient evaluations             = 27
Number of equality constraint evaluations            = 55
Number of inequality constraint evaluations          = 55
Number of equality constraint Jacobian evaluations   = 27
Number of inequality constraint Jacobian evaluations = 27
Number of Lagrangian Hessian evaluations             = 26
Total seconds in IPOPT                               = 0.088

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case3_lmbd.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:       78
Number of nonzeros in inequality constraint Jacobian.:       24
Number of nonzeros in Lagrangian Hessian.............:      122

Total number of variables............................:       23
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       20
                     variables with only upper bounds:        0
Total number of equality constraints.................:       19
Total number of inequality constraints...............:       12
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       12

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.3949934e+00 1.09e+00 1.67e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.1048421e+03 4.62e-01 1.04e+02  -1.0 1.81e+00    -  5.77e-03 5.76e-01h  1
   2  4.4503068e+03 1.36e-01 3.09e+01  -1.0 8.29e-01    -  8.15e-01 7.05e-01h  1
   3  4.6140270e+03 1.18e-01 2.67e+01  -1.0 2.99e-01    -  4.13e-01 1.37e-01h  1
   4  4.9343698e+03 8.25e-02 3.85e+01  -1.0 4.36e-01    -  4.94e-01 2.98e-01h  1
   5  5.4019378e+03 3.46e-02 2.51e+01  -1.0 3.62e-01    -  9.90e-01 5.81e-01h  1
   6  5.4116196e+03 3.37e-02 1.26e+02  -1.0 1.45e-01    -  1.84e-01 2.70e-02h  1
   7  5.6094774e+03 1.60e-02 5.13e+01  -1.0 2.53e-01    -  2.76e-01 5.25e-01h  1
   8  5.7031738e+03 8.53e-03 8.21e+01  -1.0 1.43e-01    -  7.00e-01 4.67e-01h  1
   9  5.8145457e+03 6.10e-04 2.19e+00  -1.0 5.77e-02    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  5.8146316e+03 2.55e-05 7.83e-03  -1.0 1.23e-02    -  1.00e+00 1.00e+00h  1
  11  5.8127612e+03 1.60e-05 1.36e-02  -2.5 8.27e-03    -  1.00e+00 1.00e+00f  1
  12  5.8126464e+03 2.60e-07 1.15e-04  -3.8 1.05e-03    -  1.00e+00 1.00e+00f  1
  13  5.8126430e+03 1.32e-10 8.31e-08  -5.7 2.50e-05    -  1.00e+00 1.00e+00h  1
  14  5.8126429e+03 7.55e-15 6.25e-12  -8.6 1.78e-07    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 14

                                   (scaled)                 (unscaled)
Objective...............:   1.1625285870072360e+03    5.8126429350361796e+03
Dual infeasibility......:   6.2541517268298295e-12    3.1270758634149147e-11
Constraint violation....:   7.5495165674510645e-15    7.5495165674510645e-15
Variable bound violation:   1.0911841874516881e-08    1.0911841874516881e-08
Complementarity.........:   2.5102170848799089e-09    1.2551085424399544e-08
Overall NLP error.......:   2.5102170848799089e-09    1.2551085424399544e-08


Number of objective function evaluations             = 15
Number of objective gradient evaluations             = 15
Number of equality constraint evaluations            = 15
Number of inequality constraint evaluations          = 15
Number of equality constraint Jacobian evaluations   = 15
Number of inequality constraint Jacobian evaluations = 15
Number of Lagrangian Hessian evaluations             = 14
Total seconds in IPOPT                               = 0.010

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:       78
Number of nonzeros in inequality constraint Jacobian.:       24
Number of nonzeros in Lagrangian Hessian.............:      122

Total number of variables............................:       23
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       20
                     variables with only upper bounds:        0
Total number of equality constraints.................:       19
Total number of inequality constraints...............:       12
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       12

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  6.3949934e+00 1.09e+00 1.67e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  2.1048421e+03 4.62e-01 1.04e+02  -1.0 1.81e+00    -  5.77e-03 5.76e-01h  1
   2  4.4503068e+03 1.36e-01 3.09e+01  -1.0 8.29e-01    -  8.15e-01 7.05e-01h  1
   3  4.6140270e+03 1.18e-01 2.67e+01  -1.0 2.99e-01    -  4.13e-01 1.37e-01h  1
   4  4.9343698e+03 8.25e-02 3.85e+01  -1.0 4.36e-01    -  4.94e-01 2.98e-01h  1
   5  5.4019378e+03 3.46e-02 2.51e+01  -1.0 3.62e-01    -  9.90e-01 5.81e-01h  1
   6  5.4116196e+03 3.37e-02 1.26e+02  -1.0 1.45e-01    -  1.84e-01 2.70e-02h  1
   7  5.6094774e+03 1.60e-02 5.13e+01  -1.0 2.53e-01    -  2.76e-01 5.25e-01h  1
   8  5.7031738e+03 8.53e-03 8.21e+01  -1.0 1.43e-01    -  7.00e-01 4.67e-01h  1
   9  5.8145457e+03 6.10e-04 2.19e+00  -1.0 5.77e-02    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  5.8146316e+03 2.55e-05 7.83e-03  -1.0 1.23e-02    -  1.00e+00 1.00e+00h  1
  11  5.8127612e+03 1.60e-05 1.36e-02  -2.5 8.27e-03    -  1.00e+00 1.00e+00f  1
  12  5.8126464e+03 2.60e-07 1.15e-04  -3.8 1.05e-03    -  1.00e+00 1.00e+00f  1
  13  5.8126430e+03 1.32e-10 8.31e-08  -5.7 2.50e-05    -  1.00e+00 1.00e+00h  1
  14  5.8126429e+03 7.55e-15 6.25e-12  -8.6 1.78e-07    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 14

                                   (scaled)                 (unscaled)
Objective...............:   1.1625285870072360e+03    5.8126429350361796e+03
Dual infeasibility......:   6.2541517268298295e-12    3.1270758634149147e-11
Constraint violation....:   7.5495165674510645e-15    7.5495165674510645e-15
Variable bound violation:   1.0911841874516881e-08    1.0911841874516881e-08
Complementarity.........:   2.5102170848799089e-09    1.2551085424399544e-08
Overall NLP error.......:   2.5102170848799089e-09    1.2551085424399544e-08


Number of objective function evaluations             = 15
Number of objective gradient evaluations             = 15
Number of equality constraint evaluations            = 15
Number of inequality constraint evaluations          = 15
Number of equality constraint Jacobian evaluations   = 15
Number of inequality constraint Jacobian evaluations = 15
Number of Lagrangian Hessian evaluations             = 14
Total seconds in IPOPT                               = 0.009

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4020_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4601_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4619_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4661_sdet.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4837_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case4917_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case500_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case5658_epigrids.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case57_ieee.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     1935
Number of nonzeros in inequality constraint Jacobian.:      640
Number of nonzeros in Lagrangian Hessian.............:     3167

Total number of variables............................:      445
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      388
                     variables with only upper bounds:        0
Total number of equality constraints.................:      435
Total number of inequality constraints...............:      320
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      320

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0503586e+02 3.76e+00 1.91e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.0716549e+04 2.65e+00 1.19e+02  -1.0 3.70e+00    -  2.74e-03 2.95e-01h  1
   2  1.3984057e+04 2.15e+00 9.71e+01  -1.0 7.02e+00    -  5.91e-02 1.90e-01h  1
   3  1.4673527e+04 2.08e+00 7.81e+01  -1.0 3.90e+00    -  3.67e-01 2.99e-02h  1
   4  2.0340384e+04 1.57e+00 5.90e+01  -1.0 4.22e+00    -  7.79e-01 2.46e-01h  1
   5  3.5210269e+04 2.14e-01 4.79e+01  -1.0 4.88e+00    -  7.60e-01 8.64e-01h  1
   6  3.6360055e+04 1.01e-01 2.37e+01  -1.0 1.06e+01    -  7.33e-01 5.27e-01h  1
   7  3.7555239e+04 1.23e-02 1.55e+00  -1.0 6.75e+00    -  1.00e+00 1.00e+00h  1
   8  3.7614438e+04 3.64e-04 1.91e-02  -1.0 1.25e+00    -  1.00e+00 1.00e+00h  1
   9  3.7591308e+04 4.39e-04 3.47e+00  -2.5 1.26e+00    -  8.64e-01 1.00e+00f  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  3.7590571e+04 8.45e-05 2.31e+00  -2.5 1.37e-01    -  9.45e-01 8.36e-01h  1
  11  3.7590149e+04 1.43e-05 1.36e-03  -2.5 2.81e-02    -  1.00e+00 1.00e+00f  1
  12  3.7589396e+04 2.20e-06 1.90e-02  -3.8 4.24e-02    -  9.89e-01 1.00e+00h  1
  13  3.7589383e+04 8.07e-09 2.05e-06  -3.8 5.69e-04    -  1.00e+00 1.00e+00h  1
  14  3.7589339e+04 7.59e-09 1.23e-06  -5.7 2.32e-03    -  1.00e+00 1.00e+00h  1
  15  3.7589338e+04 1.86e-12 2.72e-10  -8.6 2.92e-05    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 15

                                   (scaled)                 (unscaled)
Objective...............:   1.0107655336327775e+03    3.7589338204193162e+04
Dual infeasibility......:   2.7159293080629876e-10    1.0100263800303899e-08
Constraint violation....:   1.8649361568923162e-12    1.8649361568923162e-12
Variable bound violation:   2.4448082225347889e-08    2.4448082225347889e-08
Complementarity.........:   2.6288227592950274e-09    9.7763234390144846e-08
Overall NLP error.......:   2.6288227592950274e-09    9.7763234390144846e-08


Number of objective function evaluations             = 16
Number of objective gradient evaluations             = 16
Number of equality constraint evaluations            = 16
Number of inequality constraint evaluations          = 16
Number of equality constraint Jacobian evaluations   = 16
Number of inequality constraint Jacobian evaluations = 16
Number of Lagrangian Hessian evaluations             = 15
Total seconds in IPOPT                               = 35.324

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     1935
Number of nonzeros in inequality constraint Jacobian.:      640
Number of nonzeros in Lagrangian Hessian.............:     3167

Total number of variables............................:      445
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      388
                     variables with only upper bounds:        0
Total number of equality constraints.................:      435
Total number of inequality constraints...............:      320
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      320

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0503586e+02 3.76e+00 1.91e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.0716549e+04 2.65e+00 1.19e+02  -1.0 3.70e+00    -  2.74e-03 2.95e-01h  1
   2  1.3984057e+04 2.15e+00 9.71e+01  -1.0 7.02e+00    -  5.91e-02 1.90e-01h  1
   3  1.4673527e+04 2.08e+00 7.81e+01  -1.0 3.90e+00    -  3.67e-01 2.99e-02h  1
   4  2.0340384e+04 1.57e+00 5.90e+01  -1.0 4.22e+00    -  7.79e-01 2.46e-01h  1
   5  3.5210269e+04 2.14e-01 4.79e+01  -1.0 4.88e+00    -  7.60e-01 8.64e-01h  1
   6  3.6360055e+04 1.01e-01 2.37e+01  -1.0 1.06e+01    -  7.33e-01 5.27e-01h  1
   7  3.7555239e+04 1.23e-02 1.55e+00  -1.0 6.75e+00    -  1.00e+00 1.00e+00h  1
   8  3.7614438e+04 3.64e-04 1.91e-02  -1.0 1.25e+00    -  1.00e+00 1.00e+00h  1
   9  3.7591308e+04 4.39e-04 3.47e+00  -2.5 1.26e+00    -  8.64e-01 1.00e+00f  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  3.7590571e+04 8.45e-05 2.31e+00  -2.5 1.37e-01    -  9.45e-01 8.36e-01h  1
  11  3.7590149e+04 1.43e-05 1.36e-03  -2.5 2.81e-02    -  1.00e+00 1.00e+00f  1
  12  3.7589396e+04 2.20e-06 1.90e-02  -3.8 4.24e-02    -  9.89e-01 1.00e+00h  1
  13  3.7589383e+04 8.07e-09 2.05e-06  -3.8 5.69e-04    -  1.00e+00 1.00e+00h  1
  14  3.7589339e+04 7.59e-09 1.23e-06  -5.7 2.32e-03    -  1.00e+00 1.00e+00h  1
  15  3.7589338e+04 1.86e-12 2.72e-10  -8.6 2.92e-05    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 15

                                   (scaled)                 (unscaled)
Objective...............:   1.0107655336327775e+03    3.7589338204193162e+04
Dual infeasibility......:   2.7159293080629876e-10    1.0100263800303899e-08
Constraint violation....:   1.8649361568923162e-12    1.8649361568923162e-12
Variable bound violation:   2.4448082225347889e-08    2.4448082225347889e-08
Complementarity.........:   2.6288227592950274e-09    9.7763234390144846e-08
Overall NLP error.......:   2.6288227592950274e-09    9.7763234390144846e-08


Number of objective function evaluations             = 16
Number of objective gradient evaluations             = 16
Number of equality constraint evaluations            = 16
Number of inequality constraint evaluations          = 16
Number of equality constraint Jacobian evaluations   = 16
Number of inequality constraint Jacobian evaluations = 16
Number of Lagrangian Hessian evaluations             = 15
Total seconds in IPOPT                               = 0.084

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case588_sdet.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case5_pjm.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      155
Number of nonzeros in inequality constraint Jacobian.:       48
Number of nonzeros in Lagrangian Hessian.............:      240

Total number of variables............................:       44
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       39
                     variables with only upper bounds:        0
Total number of equality constraints.................:       35
Total number of inequality constraints...............:       24
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       24

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0059989e+02 3.99e+00 2.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  8.3066305e+03 2.47e+00 1.01e+02  -1.0 2.78e+00    -  4.11e-03 3.82e-01h  1
   2  6.7181372e+03 2.36e+00 9.62e+01  -1.0 1.60e+01    -  7.37e-02 4.44e-02f  1
   3  6.6689587e+03 2.30e+00 9.34e+01  -1.0 1.30e+01    -  4.94e-01 2.40e-02f  1
   4  6.5741805e+03 2.04e+00 8.25e+01  -1.0 1.29e+01    -  3.67e-01 1.12e-01f  2
   5  6.8264259e+03 1.80e+00 7.10e+01  -1.0 1.23e+01    -  8.72e-01 1.20e-01h  2
   6  8.8540136e+03 1.08e+00 4.20e+01  -1.0 9.14e+00    -  5.92e-01 4.00e-01h  1
   7  1.0572806e+04 8.62e-01 3.58e+01  -1.0 2.94e+00    -  4.93e-01 2.00e-01h  1
   8  1.7308577e+04 3.63e-02 1.46e+01  -1.0 2.41e+00    -  7.65e-01 9.58e-01h  1
   9  1.7572869e+04 1.33e-02 1.10e+00  -1.0 2.11e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7590631e+04 1.68e-03 1.61e-01  -1.0 5.04e-01    -  1.00e+00 1.00e+00h  1
  11  1.7558724e+04 5.24e-03 5.03e-01  -2.5 6.03e-01    -  8.35e-01 9.36e-01f  1
  12  1.7553111e+04 3.34e-03 4.12e+00  -2.5 2.84e-01    -  1.00e+00 8.20e-01h  1
  13  1.7552956e+04 3.24e-05 1.26e-02  -2.5 6.35e-02    -  1.00e+00 1.00e+00h  1
  14  1.7551990e+04 1.35e-05 1.09e+00  -3.8 2.53e-02    -  1.00e+00 9.25e-01h  1
  15  1.7551938e+04 4.46e-08 1.22e-02  -3.8 7.00e-03    -  1.00e+00 1.00e+00f  1
  16  1.7551940e+04 2.35e-10 2.06e-04  -3.8 3.83e-04    -  1.00e+00 1.00e+00h  1
  17  1.7551893e+04 1.75e-07 2.10e-01  -5.7 2.49e-03    -  1.00e+00 9.68e-01f  1
  18  1.7551891e+04 6.80e-11 3.09e-05  -5.7 2.38e-04    -  1.00e+00 1.00e+00f  1
  19  1.7551891e+04 5.68e-14 6.47e-10  -5.7 5.17e-07    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.7551891e+04 6.26e-12 3.03e-07  -8.6 3.52e-05    -  1.00e+00 1.00e+00f  1
  21  1.7551891e+04 5.68e-14 3.38e-12  -8.6 3.33e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 21

                                   (scaled)                 (unscaled)
Objective...............:   4.3879727248486898e+02    1.7551890899394759e+04
Dual infeasibility......:   3.3822003142280486e-12    1.3528801256912194e-10
Constraint violation....:   3.6743585951626306e-14    5.6843418860808015e-14
Variable bound violation:   2.9463905093507492e-08    2.9463905093507492e-08
Complementarity.........:   2.5059076126917168e-09    1.0023630450766867e-07
Overall NLP error.......:   2.5059076126917168e-09    1.0023630450766867e-07


Number of objective function evaluations             = 28
Number of objective gradient evaluations             = 22
Number of equality constraint evaluations            = 28
Number of inequality constraint evaluations          = 28
Number of equality constraint Jacobian evaluations   = 22
Number of inequality constraint Jacobian evaluations = 22
Number of Lagrangian Hessian evaluations             = 21
Total seconds in IPOPT                               = 0.019

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:      155
Number of nonzeros in inequality constraint Jacobian.:       48
Number of nonzeros in Lagrangian Hessian.............:      240

Total number of variables............................:       44
                     variables with only lower bounds:        0
                variables with lower and upper bounds:       39
                     variables with only upper bounds:        0
Total number of equality constraints.................:       35
Total number of inequality constraints...............:       24
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:       24

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.0059989e+02 3.99e+00 2.88e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  8.3066305e+03 2.47e+00 1.01e+02  -1.0 2.78e+00    -  4.11e-03 3.82e-01h  1
   2  6.7181372e+03 2.36e+00 9.62e+01  -1.0 1.60e+01    -  7.37e-02 4.44e-02f  1
   3  6.6689587e+03 2.30e+00 9.34e+01  -1.0 1.30e+01    -  4.94e-01 2.40e-02f  1
   4  6.5741805e+03 2.04e+00 8.25e+01  -1.0 1.29e+01    -  3.67e-01 1.12e-01f  2
   5  6.8264259e+03 1.80e+00 7.10e+01  -1.0 1.23e+01    -  8.72e-01 1.20e-01h  2
   6  8.8540136e+03 1.08e+00 4.20e+01  -1.0 9.14e+00    -  5.92e-01 4.00e-01h  1
   7  1.0572806e+04 8.62e-01 3.58e+01  -1.0 2.94e+00    -  4.93e-01 2.00e-01h  1
   8  1.7308577e+04 3.63e-02 1.46e+01  -1.0 2.41e+00    -  7.65e-01 9.58e-01h  1
   9  1.7572869e+04 1.33e-02 1.10e+00  -1.0 2.11e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7590631e+04 1.68e-03 1.61e-01  -1.0 5.04e-01    -  1.00e+00 1.00e+00h  1
  11  1.7558724e+04 5.24e-03 5.03e-01  -2.5 6.03e-01    -  8.35e-01 9.36e-01f  1
  12  1.7553111e+04 3.34e-03 4.12e+00  -2.5 2.84e-01    -  1.00e+00 8.20e-01h  1
  13  1.7552956e+04 3.24e-05 1.26e-02  -2.5 6.35e-02    -  1.00e+00 1.00e+00h  1
  14  1.7551990e+04 1.35e-05 1.09e+00  -3.8 2.53e-02    -  1.00e+00 9.25e-01h  1
  15  1.7551938e+04 4.46e-08 1.22e-02  -3.8 7.00e-03    -  1.00e+00 1.00e+00f  1
  16  1.7551940e+04 2.35e-10 2.06e-04  -3.8 3.83e-04    -  1.00e+00 1.00e+00h  1
  17  1.7551893e+04 1.75e-07 2.10e-01  -5.7 2.49e-03    -  1.00e+00 9.68e-01f  1
  18  1.7551891e+04 6.80e-11 3.09e-05  -5.7 2.38e-04    -  1.00e+00 1.00e+00f  1
  19  1.7551891e+04 5.68e-14 6.47e-10  -5.7 5.17e-07    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.7551891e+04 6.26e-12 3.03e-07  -8.6 3.52e-05    -  1.00e+00 1.00e+00f  1
  21  1.7551891e+04 5.68e-14 3.38e-12  -8.6 3.33e-08    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 21

                                   (scaled)                 (unscaled)
Objective...............:   4.3879727248486898e+02    1.7551890899394759e+04
Dual infeasibility......:   3.3822003142280486e-12    1.3528801256912194e-10
Constraint violation....:   3.6743585951626306e-14    5.6843418860808015e-14
Variable bound violation:   2.9463905093507492e-08    2.9463905093507492e-08
Complementarity.........:   2.5059076126917168e-09    1.0023630450766867e-07
Overall NLP error.......:   2.5059076126917168e-09    1.0023630450766867e-07


Number of objective function evaluations             = 28
Number of objective gradient evaluations             = 22
Number of equality constraint evaluations            = 28
Number of inequality constraint evaluations          = 28
Number of equality constraint Jacobian evaluations   = 22
Number of inequality constraint Jacobian evaluations = 22
Number of Lagrangian Hessian evaluations             = 21
Total seconds in IPOPT                               = 0.018

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case60_c.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     2170
Number of nonzeros in inequality constraint Jacobian.:      704
Number of nonzeros in Lagrangian Hessian.............:     3460

Total number of variables............................:      517
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      457
                     variables with only upper bounds:        0
Total number of equality constraints.................:      473
Total number of inequality constraints...............:      352
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      352

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  3.8499996e+03 2.00e+01 1.41e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.3245588e+04 1.86e+01 3.73e+01  -1.0 7.57e+00    -  2.13e-03 7.03e-02h  3
   2  1.7309771e+04 1.73e+01 3.47e+01  -1.0 1.53e+01    -  3.49e-02 6.78e-02h  1
   3  1.8342944e+04 1.71e+01 3.43e+01  -1.0 4.18e+01    -  1.55e-01 1.62e-02h  1
   4  2.4426939e+04 1.55e+01 3.37e+01  -1.0 4.49e+01    -  5.05e-01 8.84e-02h  1
   5  3.5654049e+04 1.29e+01 3.04e+01  -1.0 7.04e+01    -  2.66e-01 1.69e-01H  1
   6  4.5981864e+04 1.06e+01 3.76e+01  -1.0 1.07e+02    -  7.81e-01 1.83e-01h  1
   7  6.4990845e+04 6.28e+00 2.46e+01  -1.0 1.29e+02    -  7.62e-01 4.05e-01H  1
   8  7.2941782e+04 4.45e+00 1.98e+01  -1.0 1.46e+02    -  6.50e-01 2.92e-01h  1
   9  7.8657212e+04 3.11e+00 1.34e+01  -1.0 1.50e+02    -  2.32e-01 3.01e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.2721881e+04 2.11e+00 8.87e+00  -1.0 1.56e+02    -  2.37e-01 3.22e-01h  1
  11  8.6494258e+04 1.31e+00 8.94e+00  -1.0 1.47e+02    -  8.66e-01 3.79e-01h  1
  12  9.1978730e+04 1.81e-01 3.49e+00  -1.0 1.42e+02    -  6.80e-01 8.76e-01h  1
  13  9.2499709e+04 1.79e-01 6.09e+00  -1.0 1.18e+02    -  8.21e-01 6.38e-01h  1
  14  9.2809697e+04 7.56e-03 5.99e-01  -1.0 8.99e+01    -  1.00e+00 1.00e+00H  1
  15  9.2748777e+04 2.86e-03 2.52e+00  -1.7 2.65e+01    -  9.39e-01 7.19e-01h  1
  16  9.2718202e+04 4.67e-03 8.70e-02  -1.7 1.35e+01    -  1.00e+00 1.00e+00h  1
  17  9.2701386e+04 3.06e-03 1.06e+00  -2.5 1.16e+01    -  8.99e-01 7.12e-01h  1
  18  9.2698201e+04 1.55e-03 2.09e+00  -2.5 5.16e+00    -  1.00e+00 5.76e-01h  1
  19  9.2696531e+04 5.10e-04 3.57e-03  -2.5 2.53e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  9.2694394e+04 2.74e-04 1.07e+00  -3.8 2.72e+00    -  9.84e-01 7.42e-01h  1
  21  9.2693778e+04 1.15e-04 6.40e-04  -3.8 1.13e+00    -  1.00e+00 1.00e+00h  1
  22  9.2693813e+04 4.96e-06 2.97e-05  -3.8 9.20e-02    -  1.00e+00 1.00e+00h  1
  23  9.2693672e+04 7.42e-06 1.07e-02  -5.7 2.34e-01    -  9.98e-01 9.80e-01h  1
  24  9.2693671e+04 8.19e-07 9.01e-06  -5.7 1.39e-02    -  1.00e+00 1.00e+00h  1
  25  9.2693670e+04 1.48e-07 8.95e-04  -8.6 3.09e-03    -  1.00e+00 9.48e-01h  1
  26  9.2693670e+04 5.13e-09 5.45e-08  -8.6 3.72e-04    -  1.00e+00 1.00e+00f  1
  27  9.2693670e+04 6.00e-10 3.72e-11  -8.6 2.53e-04    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 27

                                   (scaled)                 (unscaled)
Objective...............:   3.0897889867007520e+03    9.2693669601022557e+04
Dual infeasibility......:   3.7179050873715082e-11    1.1153715262114524e-09
Constraint violation....:   6.0020255432391423e-10    6.0020255432391423e-10
Variable bound violation:   7.6218864109023343e-08    7.6218864109023343e-08
Complementarity.........:   2.5423138023358464e-09    7.6269414070075392e-08
Overall NLP error.......:   2.5423138023358464e-09    7.6269414070075392e-08


Number of objective function evaluations             = 35
Number of objective gradient evaluations             = 28
Number of equality constraint evaluations            = 35
Number of inequality constraint evaluations          = 35
Number of equality constraint Jacobian evaluations   = 28
Number of inequality constraint Jacobian evaluations = 28
Number of Lagrangian Hessian evaluations             = 27
Total seconds in IPOPT                               = 38.884

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     2170
Number of nonzeros in inequality constraint Jacobian.:      704
Number of nonzeros in Lagrangian Hessian.............:     3460

Total number of variables............................:      517
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      457
                     variables with only upper bounds:        0
Total number of equality constraints.................:      473
Total number of inequality constraints...............:      352
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      352

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  3.8499996e+03 2.00e+01 1.41e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.3245588e+04 1.86e+01 3.73e+01  -1.0 7.57e+00    -  2.13e-03 7.03e-02h  3
   2  1.7309771e+04 1.73e+01 3.47e+01  -1.0 1.53e+01    -  3.49e-02 6.78e-02h  1
   3  1.8342944e+04 1.71e+01 3.43e+01  -1.0 4.18e+01    -  1.55e-01 1.62e-02h  1
   4  2.4426939e+04 1.55e+01 3.37e+01  -1.0 4.49e+01    -  5.05e-01 8.84e-02h  1
   5  3.5654049e+04 1.29e+01 3.04e+01  -1.0 7.04e+01    -  2.66e-01 1.69e-01H  1
   6  4.5981864e+04 1.06e+01 3.76e+01  -1.0 1.07e+02    -  7.81e-01 1.83e-01h  1
   7  6.4990845e+04 6.28e+00 2.46e+01  -1.0 1.29e+02    -  7.62e-01 4.05e-01H  1
   8  7.2941782e+04 4.45e+00 1.98e+01  -1.0 1.46e+02    -  6.50e-01 2.92e-01h  1
   9  7.8657212e+04 3.11e+00 1.34e+01  -1.0 1.50e+02    -  2.32e-01 3.01e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  8.2721881e+04 2.11e+00 8.87e+00  -1.0 1.56e+02    -  2.37e-01 3.22e-01h  1
  11  8.6494258e+04 1.31e+00 8.94e+00  -1.0 1.47e+02    -  8.66e-01 3.79e-01h  1
  12  9.1978730e+04 1.81e-01 3.49e+00  -1.0 1.42e+02    -  6.80e-01 8.76e-01h  1
  13  9.2499709e+04 1.79e-01 6.09e+00  -1.0 1.18e+02    -  8.21e-01 6.38e-01h  1
  14  9.2809697e+04 7.56e-03 5.99e-01  -1.0 8.99e+01    -  1.00e+00 1.00e+00H  1
  15  9.2748777e+04 2.86e-03 2.52e+00  -1.7 2.65e+01    -  9.39e-01 7.19e-01h  1
  16  9.2718202e+04 4.67e-03 8.70e-02  -1.7 1.35e+01    -  1.00e+00 1.00e+00h  1
  17  9.2701386e+04 3.06e-03 1.06e+00  -2.5 1.16e+01    -  8.99e-01 7.12e-01h  1
  18  9.2698201e+04 1.55e-03 2.09e+00  -2.5 5.16e+00    -  1.00e+00 5.76e-01h  1
  19  9.2696531e+04 5.10e-04 3.57e-03  -2.5 2.53e+00    -  1.00e+00 1.00e+00h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  9.2694394e+04 2.74e-04 1.07e+00  -3.8 2.72e+00    -  9.84e-01 7.42e-01h  1
  21  9.2693778e+04 1.15e-04 6.40e-04  -3.8 1.13e+00    -  1.00e+00 1.00e+00h  1
  22  9.2693813e+04 4.96e-06 2.97e-05  -3.8 9.20e-02    -  1.00e+00 1.00e+00h  1
  23  9.2693672e+04 7.42e-06 1.07e-02  -5.7 2.34e-01    -  9.98e-01 9.80e-01h  1
  24  9.2693671e+04 8.19e-07 9.01e-06  -5.7 1.39e-02    -  1.00e+00 1.00e+00h  1
  25  9.2693670e+04 1.48e-07 8.95e-04  -8.6 3.09e-03    -  1.00e+00 9.48e-01h  1
  26  9.2693670e+04 5.13e-09 5.45e-08  -8.6 3.72e-04    -  1.00e+00 1.00e+00f  1
  27  9.2693670e+04 6.00e-10 3.72e-11  -8.6 2.53e-04    -  1.00e+00 1.00e+00h  1

Number of Iterations....: 27

                                   (scaled)                 (unscaled)
Objective...............:   3.0897889867007520e+03    9.2693669601022557e+04
Dual infeasibility......:   3.7179050873715082e-11    1.1153715262114524e-09
Constraint violation....:   6.0020255432391423e-10    6.0020255432391423e-10
Variable bound violation:   7.6218864109023343e-08    7.6218864109023343e-08
Complementarity.........:   2.5423138023358464e-09    7.6269414070075392e-08
Overall NLP error.......:   2.5423138023358464e-09    7.6269414070075392e-08


Number of objective function evaluations             = 35
Number of objective gradient evaluations             = 28
Number of equality constraint evaluations            = 35
Number of inequality constraint evaluations          = 35
Number of equality constraint Jacobian evaluations   = 28
Number of inequality constraint Jacobian evaluations = 28
Number of Lagrangian Hessian evaluations             = 27
Total seconds in IPOPT                               = 0.165

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case6468_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case6470_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case6495_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case6515_rte.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case7336_epigrids.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case73_ieee_rts.m&quot;
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     3079
Number of nonzeros in inequality constraint Jacobian.:      960
Number of nonzeros in Lagrangian Hessian.............:     4867

Total number of variables............................:      821
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      748
                     variables with only upper bounds:        0
Total number of equality constraints.................:      627
Total number of inequality constraints...............:      480
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      480

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.2029395e+05 2.52e+00 4.58e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.6840177e+05 1.57e+00 6.28e+01  -1.0 2.15e+00    -  9.96e-03 3.79e-01h  1
   2  1.5863973e+05 1.38e+00 5.55e+01  -1.0 5.37e+00    -  1.33e-02 1.21e-01f  1
   3  1.5548642e+05 1.36e+00 5.17e+01  -1.0 7.22e+00    -  3.52e-01 1.30e-02f  1
   4  1.5695662e+05 1.11e+00 4.06e+01  -1.0 6.22e+00    -  7.22e-01 1.83e-01h  1
   5  1.5887394e+05 6.95e-01 2.54e+01  -1.0 7.76e+00    -  3.89e-01 3.74e-01h  1
   6  1.5957285e+05 4.99e-01 2.10e+01  -1.0 9.38e+00    -  1.00e+00 2.82e-01h  1
   7  1.6281289e+05 3.69e-01 1.55e+01  -1.0 6.50e+00    -  3.44e-01 2.60e-01h  1
   8  1.6421420e+05 3.25e-01 1.22e+01  -1.0 5.49e+00    -  1.00e+00 1.19e-01h  1
   9  1.6632915e+05 2.66e-01 7.11e+00  -1.0 3.63e+00    -  5.01e-01 1.83e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7504296e+05 1.51e-01 1.06e+01  -1.0 2.44e+00    -  6.58e-02 4.32e-01h  1
  11  1.8861399e+05 6.24e-02 1.08e+01  -1.0 2.53e+00    -  2.74e-01 8.66e-01h  1
  12  1.9092060e+05 2.17e-02 3.46e+00  -1.0 1.11e+00    -  7.53e-01 1.00e+00h  1
  13  1.9108513e+05 3.84e-03 3.77e-01  -1.0 8.49e-01    -  1.00e+00 1.00e+00h  1
  14  1.9022312e+05 1.55e-03 4.99e-01  -1.7 2.53e-01    -  8.65e-01 1.00e+00f  1
  15  1.9008605e+05 1.06e-03 1.15e-02  -1.7 1.07e-01    -  1.00e+00 1.00e+00f  1
  16  1.8987249e+05 8.00e-04 3.18e-01  -3.8 1.55e-01    -  8.03e-01 6.68e-01f  1
  17  1.8982422e+05 5.39e-04 1.68e+00  -3.8 1.76e-01    -  8.21e-01 3.99e-01f  1
  18  1.8979502e+05 3.18e-04 2.71e+00  -3.8 2.56e-01    -  8.80e-01 4.71e-01h  1
  19  1.8976750e+05 9.31e-05 3.39e-01  -3.8 1.97e-01    -  1.00e+00 9.20e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.8976634e+05 3.16e-06 4.97e-05  -3.8 1.13e-02    -  1.00e+00 1.00e+00h  1
  21  1.8976428e+05 8.44e-07 4.71e-02  -5.7 1.03e-02    -  9.81e-01 9.21e-01h  1
  22  1.8976410e+05 4.22e-08 9.88e-07  -5.7 9.91e-04    -  1.00e+00 1.00e+00h  1
  23  1.8976408e+05 3.98e-10 4.49e-07  -8.6 1.35e-04    -  1.00e+00 1.00e+00h  1
  24  1.8976408e+05 2.84e-14 1.42e-12  -8.6 6.22e-05    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 24

                                   (scaled)                 (unscaled)
Objective...............:   1.4597236705182570e+03    1.8976407716737341e+05
Dual infeasibility......:   1.4208530936394057e-12    1.8471090217312274e-10
Constraint violation....:   2.8421709430404007e-14    2.8421709430404007e-14
Variable bound violation:   3.9923579997491743e-08    3.9923579997491743e-08
Complementarity.........:   2.5067203665655705e-09    3.2587364765352413e-07
Overall NLP error.......:   2.5067203665655705e-09    3.2587364765352413e-07


Number of objective function evaluations             = 25
Number of objective gradient evaluations             = 25
Number of equality constraint evaluations            = 25
Number of inequality constraint evaluations          = 25
Number of equality constraint Jacobian evaluations   = 25
Number of inequality constraint Jacobian evaluations = 25
Number of Lagrangian Hessian evaluations             = 24
Total seconds in IPOPT                               = 94.252

EXIT: Optimal Solution Found.
This is Ipopt version 3.14.14, running with linear solver MUMPS 5.6.2.

Number of nonzeros in equality constraint Jacobian...:     3079
Number of nonzeros in inequality constraint Jacobian.:      960
Number of nonzeros in Lagrangian Hessian.............:     4867

Total number of variables............................:      821
                     variables with only lower bounds:        0
                variables with lower and upper bounds:      748
                     variables with only upper bounds:        0
Total number of equality constraints.................:      627
Total number of inequality constraints...............:      480
        inequality constraints with only lower bounds:        0
   inequality constraints with lower and upper bounds:        0
        inequality constraints with only upper bounds:      480

iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
   0  1.2029395e+05 2.52e+00 4.58e+01  -1.0 0.00e+00    -  0.00e+00 0.00e+00   0
   1  1.6840177e+05 1.57e+00 6.28e+01  -1.0 2.15e+00    -  9.96e-03 3.79e-01h  1
   2  1.5863973e+05 1.38e+00 5.55e+01  -1.0 5.37e+00    -  1.33e-02 1.21e-01f  1
   3  1.5548642e+05 1.36e+00 5.17e+01  -1.0 7.22e+00    -  3.52e-01 1.30e-02f  1
   4  1.5695662e+05 1.11e+00 4.06e+01  -1.0 6.22e+00    -  7.22e-01 1.83e-01h  1
   5  1.5887394e+05 6.95e-01 2.54e+01  -1.0 7.76e+00    -  3.89e-01 3.74e-01h  1
   6  1.5957285e+05 4.99e-01 2.10e+01  -1.0 9.38e+00    -  1.00e+00 2.82e-01h  1
   7  1.6281289e+05 3.69e-01 1.55e+01  -1.0 6.50e+00    -  3.44e-01 2.60e-01h  1
   8  1.6421420e+05 3.25e-01 1.22e+01  -1.0 5.49e+00    -  1.00e+00 1.19e-01h  1
   9  1.6632915e+05 2.66e-01 7.11e+00  -1.0 3.63e+00    -  5.01e-01 1.83e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  10  1.7504296e+05 1.51e-01 1.06e+01  -1.0 2.44e+00    -  6.58e-02 4.32e-01h  1
  11  1.8861399e+05 6.24e-02 1.08e+01  -1.0 2.53e+00    -  2.74e-01 8.66e-01h  1
  12  1.9092060e+05 2.17e-02 3.46e+00  -1.0 1.11e+00    -  7.53e-01 1.00e+00h  1
  13  1.9108513e+05 3.84e-03 3.77e-01  -1.0 8.49e-01    -  1.00e+00 1.00e+00h  1
  14  1.9022312e+05 1.55e-03 4.99e-01  -1.7 2.53e-01    -  8.65e-01 1.00e+00f  1
  15  1.9008605e+05 1.06e-03 1.15e-02  -1.7 1.07e-01    -  1.00e+00 1.00e+00f  1
  16  1.8987249e+05 8.00e-04 3.18e-01  -3.8 1.55e-01    -  8.03e-01 6.68e-01f  1
  17  1.8982422e+05 5.39e-04 1.68e+00  -3.8 1.76e-01    -  8.21e-01 3.99e-01f  1
  18  1.8979502e+05 3.18e-04 2.71e+00  -3.8 2.56e-01    -  8.80e-01 4.71e-01h  1
  19  1.8976750e+05 9.31e-05 3.39e-01  -3.8 1.97e-01    -  1.00e+00 9.20e-01h  1
iter    objective    inf_pr   inf_du lg(mu)  ||d||  lg(rg) alpha_du alpha_pr  ls
  20  1.8976634e+05 3.16e-06 4.97e-05  -3.8 1.13e-02    -  1.00e+00 1.00e+00h  1
  21  1.8976428e+05 8.44e-07 4.71e-02  -5.7 1.03e-02    -  9.81e-01 9.21e-01h  1
  22  1.8976410e+05 4.22e-08 9.88e-07  -5.7 9.91e-04    -  1.00e+00 1.00e+00h  1
  23  1.8976408e+05 3.98e-10 4.49e-07  -8.6 1.35e-04    -  1.00e+00 1.00e+00h  1
  24  1.8976408e+05 2.84e-14 1.42e-12  -8.6 6.22e-05    -  1.00e+00 1.00e+00f  1

Number of Iterations....: 24

                                   (scaled)                 (unscaled)
Objective...............:   1.4597236705182570e+03    1.8976407716737341e+05
Dual infeasibility......:   1.4208530936394057e-12    1.8471090217312274e-10
Constraint violation....:   2.8421709430404007e-14    2.8421709430404007e-14
Variable bound violation:   3.9923579997491743e-08    3.9923579997491743e-08
Complementarity.........:   2.5067203665655705e-09    3.2587364765352413e-07
Overall NLP error.......:   2.5067203665655705e-09    3.2587364765352413e-07


Number of objective function evaluations             = 25
Number of objective gradient evaluations             = 25
Number of equality constraint evaluations            = 25
Number of inequality constraint evaluations          = 25
Number of equality constraint Jacobian evaluations   = 25
Number of inequality constraint Jacobian evaluations = 25
Number of Lagrangian Hessian evaluations             = 24
Total seconds in IPOPT                               = 0.233

EXIT: Optimal Solution Found.
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case78484_epigrids.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case793_goc.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case8387_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case89_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case9241_pegase.m&quot;
file = &quot;/tmp/jl_XPUwWW/pglib_opf_case9591_goc.m&quot;
10×23 DataFrame
 Row │ case                         vars   cons   optimization  optimization_m ⋯
     │ String                       Int64  Int64  Float64       Float64        ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ pglib_opf_case14_ieee.m        118    169     5.74188                0. ⋯
   2 │ pglib_opf_case24_ieee_rts.m    266    315    48.4005                 0.
   3 │ pglib_opf_case30_as.m          236    348    28.6904                 0.
   4 │ pglib_opf_case30_ieee.m        236    348    43.4783                 0.
   5 │ pglib_opf_case39_epri.m        282    401    96.5703                 0. ⋯
   6 │ pglib_opf_case3_lmbd.m          24     28     0.0779732              4.
   7 │ pglib_opf_case57_ieee.m        448    675   156.559                  0.
   8 │ pglib_opf_case5_pjm.m           44     53     0.427148               5.
   9 │ pglib_opf_case60_c.m           518    737   159.878                  0. ⋯
  10 │ pglib_opf_case73_ieee_rts.m    824    987   326.898                  0.
                                                              19 columns omitted</code></pre><pre><code class="language-julia hljs">io = IOBuffer()
println(io, &quot;```@raw html&quot;)
pretty_table(io, timing_data; backend = Val(:html))
# show(io, &quot;text/html&quot;, pretty_table(timing_data; backend = Val(:html)))
println(io, &quot;```&quot;)
Text(String(take!(io)))</code></pre><table>
  <thead>
    <tr class = "header">
      <th style = "text-align: right;">case</th>
      <th style = "text-align: right;">vars</th>
      <th style = "text-align: right;">cons</th>
      <th style = "text-align: right;">optimization</th>
      <th style = "text-align: right;">optimization_modelbuild</th>
      <th style = "text-align: right;">optimization_wcompilation</th>
      <th style = "text-align: right;">optimization_cost</th>
      <th style = "text-align: right;">mtk</th>
      <th style = "text-align: right;">mtk_time_modelbuild</th>
      <th style = "text-align: right;">mtk_time_wcompilation</th>
      <th style = "text-align: right;">mtk_cost</th>
      <th style = "text-align: right;">jump</th>
      <th style = "text-align: right;">jump_modelbuild</th>
      <th style = "text-align: right;">jump_wcompilation</th>
      <th style = "text-align: right;">jump_cost</th>
      <th style = "text-align: right;">nlpmodels</th>
      <th style = "text-align: right;">nlpmodels_modelbuild</th>
      <th style = "text-align: right;">nlpmodels_wcompilation</th>
      <th style = "text-align: right;">nlpmodels_cost</th>
      <th style = "text-align: right;">optim</th>
      <th style = "text-align: right;">optim_modelbuild</th>
      <th style = "text-align: right;">optim_wcompilation</th>
      <th style = "text-align: right;">optim_cost</th>
    </tr>
    <tr class = "subheader headerLastRow">
      <th style = "text-align: right;">String</th>
      <th style = "text-align: right;">Int64</th>
      <th style = "text-align: right;">Int64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
      <th style = "text-align: right;">Float64</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style = "text-align: right;">pglib_opf_case14_ieee.m</td>
      <td style = "text-align: right;">118</td>
      <td style = "text-align: right;">169</td>
      <td style = "text-align: right;">5.74188</td>
      <td style = "text-align: right;">0.000104979</td>
      <td style = "text-align: right;">5.63988</td>
      <td style = "text-align: right;">2178.08</td>
      <td style = "text-align: right;">0.07549</td>
      <td style = "text-align: right;">1.64429</td>
      <td style = "text-align: right;">5.79364</td>
      <td style = "text-align: right;">2178.08</td>
      <td style = "text-align: right;">0.015382</td>
      <td style = "text-align: right;">0.244083</td>
      <td style = "text-align: right;">0.0488776</td>
      <td style = "text-align: right;">2178.08</td>
      <td style = "text-align: right;">0.0784789</td>
      <td style = "text-align: right;">0.13727</td>
      <td style = "text-align: right;">0.0779019</td>
      <td style = "text-align: right;">2178.08</td>
      <td style = "text-align: right;">126.724</td>
      <td style = "text-align: right;">0.0651057</td>
      <td style = "text-align: right;">125.78</td>
      <td style = "text-align: right;">1658.7</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case24_ieee_rts.m</td>
      <td style = "text-align: right;">266</td>
      <td style = "text-align: right;">315</td>
      <td style = "text-align: right;">48.4005</td>
      <td style = "text-align: right;">0.000140389</td>
      <td style = "text-align: right;">47.9654</td>
      <td style = "text-align: right;">63352.2</td>
      <td style = "text-align: right;">0.183388</td>
      <td style = "text-align: right;">3.8984</td>
      <td style = "text-align: right;">12.9557</td>
      <td style = "text-align: right;">63352.2</td>
      <td style = "text-align: right;">0.0302247</td>
      <td style = "text-align: right;">0.030845</td>
      <td style = "text-align: right;">0.0311659</td>
      <td style = "text-align: right;">63352.2</td>
      <td style = "text-align: right;">0.216706</td>
      <td style = "text-align: right;">0.160922</td>
      <td style = "text-align: right;">0.205827</td>
      <td style = "text-align: right;">63352.2</td>
      <td style = "text-align: right;">384.308</td>
      <td style = "text-align: right;">0.159995</td>
      <td style = "text-align: right;">385.39</td>
      <td style = "text-align: right;">63741.2</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case30_as.m</td>
      <td style = "text-align: right;">236</td>
      <td style = "text-align: right;">348</td>
      <td style = "text-align: right;">28.6904</td>
      <td style = "text-align: right;">0.000171728</td>
      <td style = "text-align: right;">27.4957</td>
      <td style = "text-align: right;">803.127</td>
      <td style = "text-align: right;">0.172819</td>
      <td style = "text-align: right;">3.34265</td>
      <td style = "text-align: right;">12.8841</td>
      <td style = "text-align: right;">803.127</td>
      <td style = "text-align: right;">0.0210139</td>
      <td style = "text-align: right;">0.00510361</td>
      <td style = "text-align: right;">0.0219404</td>
      <td style = "text-align: right;">803.127</td>
      <td style = "text-align: right;">0.139637</td>
      <td style = "text-align: right;">0.173657</td>
      <td style = "text-align: right;">0.140331</td>
      <td style = "text-align: right;">803.127</td>
      <td style = "text-align: right;">294.567</td>
      <td style = "text-align: right;">0.0401112</td>
      <td style = "text-align: right;">293.27</td>
      <td style = "text-align: right;">772.093</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case30_ieee.m</td>
      <td style = "text-align: right;">236</td>
      <td style = "text-align: right;">348</td>
      <td style = "text-align: right;">43.4783</td>
      <td style = "text-align: right;">0.000190889</td>
      <td style = "text-align: right;">43.1774</td>
      <td style = "text-align: right;">8208.52</td>
      <td style = "text-align: right;">0.187162</td>
      <td style = "text-align: right;">3.27919</td>
      <td style = "text-align: right;">13.1114</td>
      <td style = "text-align: right;">8208.52</td>
      <td style = "text-align: right;">0.0299482</td>
      <td style = "text-align: right;">0.00495531</td>
      <td style = "text-align: right;">0.0307215</td>
      <td style = "text-align: right;">8208.52</td>
      <td style = "text-align: right;">0.212489</td>
      <td style = "text-align: right;">0.304633</td>
      <td style = "text-align: right;">0.214642</td>
      <td style = "text-align: right;">8208.52</td>
      <td style = "text-align: right;">293.066</td>
      <td style = "text-align: right;">0.0445731</td>
      <td style = "text-align: right;">292.631</td>
      <td style = "text-align: right;">4244.05</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case39_epri.m</td>
      <td style = "text-align: right;">282</td>
      <td style = "text-align: right;">401</td>
      <td style = "text-align: right;">96.5703</td>
      <td style = "text-align: right;">0.000178499</td>
      <td style = "text-align: right;">93.867</td>
      <td style = "text-align: right;">1.38416e5</td>
      <td style = "text-align: right;">0.25493</td>
      <td style = "text-align: right;">4.23422</td>
      <td style = "text-align: right;">16.4849</td>
      <td style = "text-align: right;">1.38416e5</td>
      <td style = "text-align: right;">0.0507258</td>
      <td style = "text-align: right;">0.00515369</td>
      <td style = "text-align: right;">0.0513258</td>
      <td style = "text-align: right;">1.38416e5</td>
      <td style = "text-align: right;">0.310656</td>
      <td style = "text-align: right;">0.188602</td>
      <td style = "text-align: right;">0.288098</td>
      <td style = "text-align: right;">1.38416e5</td>
      <td style = "text-align: right;">363.644</td>
      <td style = "text-align: right;">0.0661765</td>
      <td style = "text-align: right;">363.456</td>
      <td style = "text-align: right;">78346.0</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case3_lmbd.m</td>
      <td style = "text-align: right;">24</td>
      <td style = "text-align: right;">28</td>
      <td style = "text-align: right;">0.0779732</td>
      <td style = "text-align: right;">4.618e-5</td>
      <td style = "text-align: right;">0.105845</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.0178909</td>
      <td style = "text-align: right;">0.175923</td>
      <td style = "text-align: right;">0.0195717</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.0091549</td>
      <td style = "text-align: right;">0.00478162</td>
      <td style = "text-align: right;">0.00972831</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">0.0186829</td>
      <td style = "text-align: right;">0.0160607</td>
      <td style = "text-align: right;">0.0197536</td>
      <td style = "text-align: right;">5812.64</td>
      <td style = "text-align: right;">2.29765</td>
      <td style = "text-align: right;">0.000448636</td>
      <td style = "text-align: right;">2.29684</td>
      <td style = "text-align: right;">6273.63</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case57_ieee.m</td>
      <td style = "text-align: right;">448</td>
      <td style = "text-align: right;">675</td>
      <td style = "text-align: right;">156.559</td>
      <td style = "text-align: right;">0.000274488</td>
      <td style = "text-align: right;">152.2</td>
      <td style = "text-align: right;">37555.3</td>
      <td style = "text-align: right;">0.42469</td>
      <td style = "text-align: right;">12.1244</td>
      <td style = "text-align: right;">37.0462</td>
      <td style = "text-align: right;">37589.3</td>
      <td style = "text-align: right;">0.0442181</td>
      <td style = "text-align: right;">0.00775402</td>
      <td style = "text-align: right;">0.0450932</td>
      <td style = "text-align: right;">37589.3</td>
      <td style = "text-align: right;">0.306254</td>
      <td style = "text-align: right;">0.477642</td>
      <td style = "text-align: right;">0.30959</td>
      <td style = "text-align: right;">37589.3</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case5_pjm.m</td>
      <td style = "text-align: right;">44</td>
      <td style = "text-align: right;">53</td>
      <td style = "text-align: right;">0.427148</td>
      <td style = "text-align: right;">5.5219e-5</td>
      <td style = "text-align: right;">0.371297</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.124084</td>
      <td style = "text-align: right;">0.359544</td>
      <td style = "text-align: right;">0.0360806</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.01432</td>
      <td style = "text-align: right;">0.0046479</td>
      <td style = "text-align: right;">0.014778</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">0.0367502</td>
      <td style = "text-align: right;">0.0267777</td>
      <td style = "text-align: right;">0.0378028</td>
      <td style = "text-align: right;">17551.9</td>
      <td style = "text-align: right;">19.1386</td>
      <td style = "text-align: right;">0.000638655</td>
      <td style = "text-align: right;">18.8175</td>
      <td style = "text-align: right;">77.9548</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case60_c.m</td>
      <td style = "text-align: right;">518</td>
      <td style = "text-align: right;">737</td>
      <td style = "text-align: right;">159.878</td>
      <td style = "text-align: right;">0.000257608</td>
      <td style = "text-align: right;">139.885</td>
      <td style = "text-align: right;">35648.5</td>
      <td style = "text-align: right;">0.560815</td>
      <td style = "text-align: right;">14.2151</td>
      <td style = "text-align: right;">40.6548</td>
      <td style = "text-align: right;">92693.7</td>
      <td style = "text-align: right;">0.0796966</td>
      <td style = "text-align: right;">0.0286964</td>
      <td style = "text-align: right;">0.0813441</td>
      <td style = "text-align: right;">92693.7</td>
      <td style = "text-align: right;">0.649169</td>
      <td style = "text-align: right;">0.484268</td>
      <td style = "text-align: right;">0.575294</td>
      <td style = "text-align: right;">92693.7</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
    </tr>
    <tr>
      <td style = "text-align: right;">pglib_opf_case73_ieee_rts.m</td>
      <td style = "text-align: right;">824</td>
      <td style = "text-align: right;">987</td>
      <td style = "text-align: right;">326.898</td>
      <td style = "text-align: right;">0.000343018</td>
      <td style = "text-align: right;">319.089</td>
      <td style = "text-align: right;">1.5864e5</td>
      <td style = "text-align: right;">1.02645</td>
      <td style = "text-align: right;">27.3773</td>
      <td style = "text-align: right;">96.5115</td>
      <td style = "text-align: right;">1.89764e5</td>
      <td style = "text-align: right;">0.0997913</td>
      <td style = "text-align: right;">0.0136383</td>
      <td style = "text-align: right;">0.102478</td>
      <td style = "text-align: right;">1.89764e5</td>
      <td style = "text-align: right;">0.944354</td>
      <td style = "text-align: right;">0.851503</td>
      <td style = "text-align: right;">0.81381</td>
      <td style = "text-align: right;">1.89764e5</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
      <td style = "text-align: right;">NaN</td>
    </tr>
  </tbody>
</table><h2 id="Appendix"><a class="docs-heading-anchor" href="#Appendix">Appendix</a><a id="Appendix-1"></a><a class="docs-heading-anchor-permalink" href="#Appendix" title="Permalink"></a></h2><pre><code class="nohighlight hljs">Error: ArgumentError: Package SciMLBenchmarks not found in current path, ma
ybe you meant `import/using ..SciMLBenchmarks`.
- Otherwise, run `import Pkg; Pkg.add(&quot;SciMLBenchmarks&quot;)` to install the Sc
iMLBenchmarks package.</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../clnlbeam/">« CLNLBEAM Nonlinear Optimization Benchmark</a><a class="docs-footer-nextpage" href="../../ParameterEstimation/FitzHughNagumoParameterEstimation/">FitzHugh-Nagumo Parameter Estimation Benchmarks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Saturday 21 December 2024 01:53">Saturday 21 December 2024</span>. Using Julia version 1.11.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
