<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Optimal Powerflow Nonlinear Optimization Benchmark · The SciML Benchmarks</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://benchmarks.sciml.ai/stable/OptimizationFrameworks/optimal_powerflow/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="The SciML Benchmarks logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">The SciML Benchmarks</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">SciMLBenchmarks.jl: Benchmarks for Scientific Machine Learning (SciML) and Equation Solvers</a></li><li><span class="tocitem">Multi-Language Wrapper Benchmarks</span><ul><li><a class="tocitem" href="../../MultiLanguage/ode_wrapper_packages/">ODE Solver Multi-Language Wrapper Package Work-Precision Benchmarks (MATLAB, SciPy, Julia, deSolve (R))</a></li><li><a class="tocitem" href="../../MultiLanguage/special_benchmarks/">Special Multi-Language Differential Equation Solver Comparison Benchmarks</a></li></ul></li><li><span class="tocitem">Linear Solvers</span><ul><li><a class="tocitem" href="../../LinearSolve/LUFactorization/">LU Factorization Benchmarks</a></li><li><a class="tocitem" href="../../LinearSolve/SparsePDE/">Finite Difference Sparse PDE Jacobian Factorization Benchmarks</a></li></ul></li><li><span class="tocitem">Interval Rootfinding</span><ul><li><a class="tocitem" href="../../IntervalNonlinearProblem/simpleintervalrootfind/">Simple Interval Rootfinding (NonlinearSolve.jl vs Roots.jl vs MATLAB)</a></li></ul></li><li><span class="tocitem">Nonlinear Solvers</span><ul><li><a class="tocitem" href="../../NonlinearProblem/quadratic_nonlinear/">Quadratic Nonlinear Rootfinding Benchmark</a></li></ul></li><li><span class="tocitem">Non-Stiff Ordinary Differential Equations (ODEs)</span><ul><li><a class="tocitem" href="../../NonStiffODE/FitzhughNagumo_wpd/">Fitzhugh-Nagumo Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/LotkaVolterra_wpd/">Lotka-Volterra Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/Pleiades_wpd/">Pleiades Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/RigidBody_wpd/">Rigid Body Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/ThreeBody_wpd/">Three Body Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffODE/linear_wpd/">100 Independent Linear Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Ordinary Differential Equations (ODEs)</span><ul><li><a class="tocitem" href="../../StiffODE/Bruss/">Brusselator Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Hires/">HIRES Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Orego/">OREGO Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/Pollution/">POLLU Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/ROBER/">ROBER Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../StiffODE/VanDerPol/">VanDerPol Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Biological Differential Equations</span><ul><li><a class="tocitem" href="../../Bio/BCR/">BCR Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/Bidkhori2012/">Bidkhori2012 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/egfr_net/">Egfr_net Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/fceri_gamma2/">Fceri_gamma2 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/multisite2/">Multisite2 Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../Bio/multistate/">Multistate Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Differential-Algebraic Equations (DAEs)</span><ul><li><a class="tocitem" href="../../DAE/ChemicalAkzoNobel/">Chemical Akzo Nobel Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../DAE/OregoDAE/">OREGO Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../DAE/ROBERDAE/">ROBER Differential-Algebraic Equation (DAE) Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Boundary Value Problems (BVPs)</span><ul><li><a class="tocitem" href="../../NonStiffBVP/orbital/">Orbital Dynamics BVP Benchmark</a></li></ul></li><li><span class="tocitem">Simple Handwritten Partial Differential Equations (PDEs) as ODEs</span><ul><li><a class="tocitem" href="../../SimpleHandwrittenPDE/allen_cahn_fdm_wpd/">Allen_Cahn FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/allen_cahn_spectral_wpd/">Allen-Cahn Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/burgers_fdm_wpd/">Burgers FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/burgers_spectral_wpd/">Burgers Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/kdv_fdm_wpd/">KdV FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/kdv_spectral_wpd/">KdV Pseudospectral Methods Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/ks_fdm_wpd/">KS FDM Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../SimpleHandwrittenPDE/ks_spectral_wpd/">KS Pseudospectral Methods Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Complicated Partial Differential Equations (PDEs)</span><ul><li><a class="tocitem" href="../../ComplicatedPDE/Filament/">Filament Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../ComplicatedPDE/SpringBlockNonLinearResistance/">Spring-Block PDE Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Dynamical ODEs (Hamiltonian and Second Order)</span><ul><li><a class="tocitem" href="../../DynamicalODE/Henon-Heiles_energy_conservation_benchmark/">Hénon-Heiles Energy Conservation</a></li><li><a class="tocitem" href="../../DynamicalODE/Quadrupole_boson_Hamiltonian_energy_conservation_benchmark/">Quadruple Boson Energy Conservation</a></li><li><a class="tocitem" href="../../DynamicalODE/single_pendulums/">Single Pedulum Comparison</a></li></ul></li><li><span class="tocitem">N-Body Problem Benchmarks</span><ul><li><a class="tocitem" href="../../NBodySimulator/acceleration_functions/">Acceleration function benchmarks</a></li><li><a class="tocitem" href="../../NBodySimulator/liquid_argon/">Liquid argon benchmarks</a></li></ul></li><li><span class="tocitem">Non-Stiff Stochastic Differential Equations (SDEs)</span><ul><li><a class="tocitem" href="../../NonStiffSDE/BasicSDEWeakWorkPrecision/">SDE Basic Weak Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffSDE/BasicSDEWorkPrecision/">SDE Basic Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Stochastic Differential Equations (SDEs)</span><ul><li><a class="tocitem" href="../../StiffSDE/Oval2LongRun/">Oval2 Long Run</a></li><li><a class="tocitem" href="../../StiffSDE/Oval2LongTimes/">Oval2 Long Times</a></li><li><a class="tocitem" href="../../StiffSDE/Oval2Timings/">Oval2 Timings</a></li><li><a class="tocitem" href="../../StiffSDE/QuadraticStiffness/">Quadratic Stiffness Benchmarks</a></li><li><a class="tocitem" href="../../StiffSDE/StochasticHeat/">Stochastic Heat Equation Benchmarks</a></li></ul></li><li><span class="tocitem">Non-Stiff Delay Differential Equations (DDEs)</span><ul><li><a class="tocitem" href="../../NonStiffDDE/Mackey_Glass_wpd/">Mackey and Glass Work-Precision Diagrams</a></li><li><a class="tocitem" href="../../NonStiffDDE/Wheldon_Kirk_Finlay_wpd/">Wheldon, Kirk, and Finlay Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Stiff Delay Differential equations (DDEs)</span><ul><li><a class="tocitem" href="../../StiffDDE/QuorumSensing/">Quorum Sensing Work-Precision Diagrams</a></li></ul></li><li><span class="tocitem">Jump Process Equations (Gillespie Benchmarks)</span><ul><li><a class="tocitem" href="../../Jumps/Diffusion_CTRW/">Diffusion Model</a></li><li><a class="tocitem" href="../../Jumps/Mendes_multistate_example/">Mendes Multistate Model</a></li><li><a class="tocitem" href="../../Jumps/MultivariateHawkes/">Multivariate Hawkes Model</a></li><li><a class="tocitem" href="../../Jumps/NegFeedback_GeneExpr/">Negative Feedback Gene Expression Model</a></li><li><a class="tocitem" href="../../Jumps/NegFeedback_GeneExpr_Marchetti/">Negative Feedback Marchetti Model</a></li><li><a class="tocitem" href="../../Jumps/Spatial_Signaling_Sanft/">Spatial Signaling Model from Sanft and Othmer (2015)</a></li></ul></li><li><span class="tocitem">Hybrid (Time-Dependent) Jump Processes</span><ul><li><a class="tocitem" href="../../HybridJumps/Synapse/">Synapse model</a></li></ul></li><li><span class="tocitem">Nonlinear Optimization Solver Benchmarks</span><ul><li><a class="tocitem" href="../../Optimizaton/2drosenbrock/">2-Dimensional Rosenbrock Function Nonlinear Optimization Benchmark</a></li></ul></li><li><span class="tocitem">Optimization Framework Benchmarks</span><ul><li class="is-active"><a class="tocitem" href>Optimal Powerflow Nonlinear Optimization Benchmark</a><ul class="internal"><li><a class="tocitem" href="#Data-Load-and-Setup-Code"><span>Data Load and Setup Code</span></a></li><li><a class="tocitem" href="#Test-Setup"><span>Test Setup</span></a></li><li><a class="tocitem" href="#Setup-and-Validations"><span>Setup and Validations</span></a></li><li><a class="tocitem" href="#JuMP.jl"><span>JuMP.jl</span></a></li><li><a class="tocitem" href="#NLPModels.jl"><span>NLPModels.jl</span></a></li><li><a class="tocitem" href="#Nonconvex"><span>Nonconvex</span></a></li><li><a class="tocitem" href="#Optim.jl"><span>Optim.jl</span></a></li><li><a class="tocitem" href="#CASADI"><span>CASADI</span></a></li><li><a class="tocitem" href="#Test-the-Benchmarking"><span>Test the Benchmarking</span></a></li><li><a class="tocitem" href="#Run-the-Full-Benchmark"><span>Run the Full Benchmark</span></a></li></ul></li></ul></li><li><span class="tocitem">Parameter Estimation and Inverse Problem Benchmarks</span><ul><li><a class="tocitem" href="../../ParameterEstimation/FitzHughNagumoParameterEstimation/">FitzHugh-Nagumo Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../ParameterEstimation/LorenzParameterEstimation/">Lorenz Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../ParameterEstimation/LotkaVolterraParameterEstimation/">Lotka-Volterra Parameter Estimation Benchmarks</a></li></ul></li><li><span class="tocitem">Bayesian Inference and Probabilistic Inverse Problem Benchmarks</span><ul><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesFitzHughNagumo/">Fitzhugh-Nagumo Bayesian Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesLorenz/">Lorenz Bayesian Parameter Estimation Benchmarks</a></li><li><a class="tocitem" href="../../BayesianInference/DiffEqBayesLotkaVolterra/">Lotka-Volterra Bayesian Parameter Estimation Benchmarks</a></li></ul></li><li><span class="tocitem">MethodOfLines.jl Partial Differential Equation (PDE) Formulations</span><ul><li><a class="tocitem" href="../../MethodOfLinesPDE/MOL_fdm/">Burgers FDM Work-Precision Diagrams with Various MethodOfLines Methods</a></li></ul></li><li><span class="tocitem">Physics-Informed Neural Network (Neural Network PDE Solver) Cost Function Benchmarks</span><ul><li><a class="tocitem" href="../../PINNErrorsVsTime/allen_cahn_et/">Allen-Cahn PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/diffusion_et/">Diffusion PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/hamilton_jacobi_et/">Hamilton-Jacobi PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/level_set_et/">Level Set PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li><li><a class="tocitem" href="../../PINNErrorsVsTime/nernst_planck_et/">Nernst-Planck PDE Physics-Informed Neural Network (PINN) Loss Function Error vs Time Benchmarks</a></li></ul></li><li><span class="tocitem">Physics-Informed Neural Network (Neural Network PDE Solver) Optimizer Benchmarks</span><ul><li><a class="tocitem" href="../../PINNOptimizers/1d_diffusion/">Diffusion Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/1d_poisson_nernst_planck/">Nernst-Planck Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/allen_cahn/">Allen-Cahn Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/burgers_equation/">Berger&#39;s Equation Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/hamilton_jacobi/">Hamilton-Jacobi PDE Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li><li><a class="tocitem" href="../../PINNOptimizers/poisson/">Poisson PDE Physics-Informed Neural Network (PINN) Optimizer Benchmarks</a></li></ul></li><li><span class="tocitem">SDE Adaptivity Benchmarks</span><ul><li><a class="tocitem" href="../../AdaptiveSDE/AdaptiveEfficiencyTests/">Adaptive Efficiency Tests</a></li><li><a class="tocitem" href="../../AdaptiveSDE/qmaxDetermination/">qmax Determination</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Optimization Framework Benchmarks</a></li><li class="is-active"><a href>Optimal Powerflow Nonlinear Optimization Benchmark</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Optimal Powerflow Nonlinear Optimization Benchmark</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/SciML/SciMLBenchmarksOutput/blob/main/docs/src/OptimizationFrameworks/optimal_powerflow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Optimal-Powerflow-Nonlinear-Optimization-Benchmark"><a class="docs-heading-anchor" href="#Optimal-Powerflow-Nonlinear-Optimization-Benchmark">Optimal Powerflow Nonlinear Optimization Benchmark</a><a id="Optimal-Powerflow-Nonlinear-Optimization-Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Optimal-Powerflow-Nonlinear-Optimization-Benchmark" title="Permalink"></a></h1><h2 id="Data-Load-and-Setup-Code"><a class="docs-heading-anchor" href="#Data-Load-and-Setup-Code">Data Load and Setup Code</a><a id="Data-Load-and-Setup-Code-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Load-and-Setup-Code" title="Permalink"></a></h2><p>This is generic setup code usable for all solver setups. Basically removing some unnecessary untyped dictionaries before getting to the benchmarks.</p><pre><code class="language-julia hljs">PRINT_LEVEL = 0
MAX_CPU_TIME = 100.0</code></pre><pre><code class="nohighlight hljs">100.0</code></pre><pre><code class="language-julia hljs">import PowerModels
import ConcreteStructs
using BenchmarkTools

ConcreteStructs.@concrete struct DataRepresentation
    data
    ref
    var_lookup
    var_init
    var_lb
    var_ub
    ref_gen_idxs
    lookup_pg
    lookup_qg
    lookup_va
    lookup_vm
    lookup_lij
    lookup_p_lij
    lookup_q_lij
    cost_arrs
    f_bus
    t_bus
    ref_bus_idxs
    ref_buses_idxs
    ref_bus_gens
    ref_bus_arcs
    ref_branch_idxs
    ref_arcs_from
    ref_arcs_to
    p_idxmap
    q_idxmap
    bus_pd
    bus_qd
    bus_gs
    bus_bs
    br_g
    br_b
    br_tr
    br_ti
    br_ttm
    br_g_fr
    br_b_fr
    br_g_to
    br_b_to
end

function load_and_setup_data(file_name)
    data = PowerModels.parse_file(file_name)
    PowerModels.standardize_cost_terms!(data, order=2)
    PowerModels.calc_thermal_limits!(data)
    ref = PowerModels.build_ref(data)[:it][:pm][:nw][0]

    # Some data munging to type-stable forms

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        push!(var_init, 0.0) #pg
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #qg
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1

    ref_gen_idxs = [i for i in keys(ref[:gen])]
    lookup_pg = Dict{Int,Int}()
    lookup_qg = Dict{Int,Int}()
    lookup_va = Dict{Int,Int}()
    lookup_vm = Dict{Int,Int}()
    lookup_lij = Tuple{Int,Int,Int}[]
    lookup_p_lij = Int[]
    lookup_q_lij = Int[]
    cost_arrs = Dict{Int,Vector{Float64}}()

    for (i,gen) in ref[:gen]
        lookup_pg[i] = var_lookup[&quot;pg_$(i)&quot;]
        lookup_qg[i] = var_lookup[&quot;qg_$(i)&quot;]
        cost_arrs[i] = gen[&quot;cost&quot;]
    end

    for (i,bus) in ref[:bus]
        lookup_va[i] = var_lookup[&quot;va_$(i)&quot;]
        lookup_vm[i] = var_lookup[&quot;vm_$(i)&quot;]
    end

    for (l,i,j) in ref[:arcs]
        push!(lookup_lij, (l,i,j))
        push!(lookup_p_lij,var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;])
        push!(lookup_q_lij,var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;])
    end

    f_bus = Dict{Int,Int}()
    t_bus = Dict{Int,Int}()

    for (l,branch) in ref[:branch]
        f_bus[l] = branch[&quot;f_bus&quot;]
        t_bus[l] = branch[&quot;t_bus&quot;]
    end

    ref_bus_idxs = [i for i in keys(ref[:bus])]
    ref_buses_idxs = [i for i in keys(ref[:ref_buses])]
    ref_bus_gens = ref[:bus_gens]
    ref_bus_arcs = ref[:bus_arcs]
    ref_branch_idxs = [i for i in keys(ref[:branch])]
    ref_arcs_from = ref[:arcs_from]
    ref_arcs_to = ref[:arcs_to]

    p_idxmap = Dict(lookup_lij[i] =&gt; lookup_p_lij[i] for i in 1:length(lookup_lij))
    q_idxmap = Dict(lookup_lij[i] =&gt; lookup_q_lij[i] for i in 1:length(lookup_lij))

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    DataRepresentation(
        data,
        ref,
        var_lookup,
        var_init,
        var_lb,
        var_ub,
        ref_gen_idxs,
        lookup_pg,
        lookup_qg,
        lookup_va,
        lookup_vm,
        lookup_lij,
        lookup_p_lij,
        lookup_q_lij,
        cost_arrs,
        f_bus,
        t_bus,
        ref_bus_idxs,
        ref_buses_idxs,
        ref_bus_gens,
        ref_bus_arcs,
        ref_branch_idxs,
        ref_arcs_from,
        ref_arcs_to,
        p_idxmap,
        q_idxmap,
        bus_pd,
        bus_qd,
        bus_gs,
        bus_bs,
        br_g,
        br_b,
        br_tr,
        br_ti,
        br_ttm,
        br_g_fr,
        br_b_fr,
        br_g_to,
        br_b_to)
end

file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><h2 id="Test-Setup"><a class="docs-heading-anchor" href="#Test-Setup">Test Setup</a><a id="Test-Setup-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Setup" title="Permalink"></a></h2><p>Ensure that all objectives and constraints evaluate to the same value on a random vector on the same dataset</p><pre><code class="language-julia hljs">test_u0 = [0.6292298794022337, 0.30740951571225206, 0.0215258802699263, 0.38457509230779996, 0.9419186480931858, 0.34961116773074874, 0.875763562401991, 0.3203478635827923, 0.6354060958226175, 0.45537545721771266, 0.3120599359696674, 0.2421238802331842, 0.886455177641366, 0.49797378087768696, 0.652913329799645, 0.03590201299300255, 0.5618806749518928, 0.8142146688533769, 0.3973557130434364, 0.27827135011662674, 0.16456134856048643, 0.7465018431665373, 0.4898329811551083, 0.6966035226583556, 0.7419662648518377, 0.8505905798503723, 0.27102126066405097, 0.1988238097281576, 0.09684601934490256, 0.49238142828542797, 0.1366594202307445, 0.6337080281764231, 0.28814906958008235, 0.5404996094640431, 0.015153517398975858, 0.6338449294034381, 0.5165464961007717, 0.572879113636733, 0.9652420600585092, 0.26535868365228543, 0.865686920119479, 0.38426996353892773, 0.007412077949221274, 0.3889835001514599] 
test_obj = 7079.190664351089
test_cons = [0.0215258802699263, -1.0701734802505833, -5.108902216849063, -3.49724505910433, -2.617834191007569, 0.5457423426033834, -0.7150251969424766, -2.473175092089014, -2.071687022809815, -1.5522321037165985, -1.0107399030803794, 3.0047739260369246, 0.2849522377447594, -2.8227966798520674, 3.2236954017592256, 1.0793383525116511, -1.633412293595111, -3.1618224299953224, -0.7775962590542184, 1.7252573527333024, -4.23535583005632, -1.7030832394691608, 1.5810450617647889, -0.33289810365419437, 0.19476447251065077, 1.0688558672739048, 1.563372246165339, 9.915310272572729, 1.4932615291788414, 2.0016715378998793, -1.4038702698147258, -0.8834081057449231, 0.21730536348839036, -7.40879932706212, -1.6000837514115611, 0.8542376821320647, 0.06615508569119477, -0.6077039991323074, 0.6138802155526912, 0.0061762164203837955, -0.3065125522705683, 0.5843454392910835, 0.7251928172073308, 1.2740182727083802, 0.11298343104675009, 0.2518186223833513, 0.4202616621130535, 0.3751697141306502, 0.4019890236200105, 0.5950107614751935, 1.0021074654956683, 0.897077248544158, 0.15136310228960612]</code></pre><pre><code class="nohighlight hljs">53-element Vector{Float64}:
  0.0215258802699263
 -1.0701734802505833
 -5.108902216849063
 -3.49724505910433
 -2.617834191007569
  0.5457423426033834
 -0.7150251969424766
 -2.473175092089014
 -2.071687022809815
 -1.5522321037165985
  ⋮
  0.11298343104675009
  0.2518186223833513
  0.4202616621130535
  0.3751697141306502
  0.4019890236200105
  0.5950107614751935
  1.0021074654956683
  0.897077248544158
  0.15136310228960612</code></pre><h2 id="Setup-and-Validations"><a class="docs-heading-anchor" href="#Setup-and-Validations">Setup and Validations</a><a id="Setup-and-Validations-1"></a><a class="docs-heading-anchor-permalink" href="#Setup-and-Validations" title="Permalink"></a></h2><p>Now is the setup code for each optimization framework, along with the validation runs on the test case. Any test which fails the validation case, i.e. has <code>x_test_res[1] !≈ test_obj</code> or <code>x_test_res[2] !≈ test_cons</code> should be considered invalidated as this means that the model in that modeling platform does not evaluate to give the same results</p><h3 id="Optimization.jl"><a class="docs-heading-anchor" href="#Optimization.jl">Optimization.jl</a><a id="Optimization.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Optimization.jl" title="Permalink"></a></h3><p>Constraint optimization implementation reference: https://github.com/SciML/Optimization.jl/blob/master/lib/OptimizationMOI/test/runtests.jl Other AD libraries can be considered: https://docs.sciml.ai/dev/modules/Optimization/API/optimization_function/</p><pre><code class="language-julia hljs">import Optimization
import OptimizationMOI
import ModelingToolkit
import Ipopt
import Enzyme

function build_opf_optimization_prob(dataset; adchoice = Optimization.AutoEnzyme())
    (;data,
    ref,
    var_lookup,
    var_init,
    var_lb,
    var_ub,
    ref_gen_idxs,
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij,
    cost_arrs,
    f_bus,
    t_bus,
    ref_bus_idxs,
    ref_buses_idxs,
    ref_bus_gens,
    ref_bus_arcs,
    ref_branch_idxs,
    ref_arcs_from,
    ref_arcs_to,
    p_idxmap,
    q_idxmap,
    bus_pd,
    bus_qd,
    bus_gs,
    bus_bs,
    br_g,
    br_b,
    br_tr,
    br_ti,
    br_ttm,
    br_g_fr,
    br_b_fr,
    br_g_to,
    br_b_to) = dataset

    #total_callback_time = 0.0
    function opf_objective(x, param)
        #start = time()
        cost = 0.0
        for i in ref_gen_idxs
            pg = x[lookup_pg[i]]
            _cost_arr = cost_arrs[i]
            cost += _cost_arr[1]*pg^2 + _cost_arr[2]*pg + _cost_arr[3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints(ret, x, param)
        offsetidx = 0

        # va_con
        for (reti,i) in enumerate(ref_buses_idxs)
            ret[reti + offsetidx] = x[lookup_va[i]]
        end

        offsetidx += length(ref_buses_idxs)
        
        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref_bus_gens[i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*x[lookup_vm[i]]^2
        #     )

        # power_balance_p_con
        for (reti,i) in enumerate(ref_bus_idxs)
            ret[reti + offsetidx] = sum(x[lookup_pg[j]] for j in ref_bus_gens[i]; init=0.0) -
            bus_pd[i] -
            bus_gs[i]*x[lookup_vm[i]]^2 -
            sum(x[p_idxmap[a]] for a in ref_bus_arcs[i])
        end

        offsetidx += length(ref_bus_idxs)

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(x[lookup_qg[g]] for g in ref_bus_gens[i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*x[lookup_vm[i]]^2
        #     )
        # power_balance_q_con
        for (reti,i) in enumerate(ref_bus_idxs)
        ret[reti + offsetidx] = sum(x[lookup_qg[j]] for j in ref_bus_gens[i]; init=0.0) -
        bus_qd[i] +
        bus_bs[i]*x[lookup_vm[i]]^2 -
        sum(x[q_idxmap[a]] for a in ref_bus_arcs[i])
        end

        offsetidx += length(ref_bus_idxs)

        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        # power_flow_p_from_con =
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = (br_g[l]+br_g_fr[l])/br_ttm[l]*x[lookup_vm[f_bus[l]]]^2 +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*cos(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) +
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*sin(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) -
        x[p_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_from)

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        # power_flow_p_to_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = (br_g[l]+br_g_to[l])*x[lookup_vm[t_bus[l]]]^2 +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*cos(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) +
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*sin(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) -
        x[p_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_to)

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        # power_flow_q_from_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = -(br_b[l]+br_b_fr[l])/br_ttm[l]*x[lookup_vm[f_bus[l]]]^2 -
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*cos(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[f_bus[l]]]*x[lookup_vm[t_bus[l]]]*sin(x[lookup_va[f_bus[l]]]-x[lookup_va[t_bus[l]]])) -
        x[q_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_from)

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        # power_flow_q_to_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = -(br_b[l]+br_b_to[l])*x[lookup_vm[t_bus[l]]]^2 -
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*cos(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[lookup_vm[t_bus[l]]]*x[lookup_vm[f_bus[l]]]*sin(x[lookup_va[t_bus[l]]]-x[lookup_va[f_bus[l]]])) -
        x[q_idxmap[(l,i,j)]]
        end

        offsetidx += length(ref_arcs_to)

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        # power_flow_vad_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = x[lookup_va[f_bus[l]]] - x[lookup_va[t_bus[l]]]
        end

        offsetidx += length(ref_arcs_from)

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        # power_flow_mva_from_con
        for (reti,(l,i,j)) in enumerate(ref_arcs_from)
        ret[reti + offsetidx] = x[p_idxmap[(l,i,j)]]^2 + x[q_idxmap[(l,i,j)]]^2
        end

        offsetidx += length(ref_arcs_from)

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        # power_flow_mva_to_con 
        for (reti,(l,i,j)) in enumerate(ref_arcs_to)
        ret[reti + offsetidx] = x[p_idxmap[(l,i,j)]]^2 + x[q_idxmap[(l,i,j)]]^2
        end

        offsetidx += length(ref_arcs_to)

        @assert offsetidx == length(ret)
        nothing
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    model_variables = length(var_init)
    ret = Array{Float64}(undef, length(con_lbs))
    model_constraints = length(con_lbs)

    optprob = Optimization.OptimizationFunction(opf_objective, adchoice; cons=opf_constraints)
    prob = Optimization.OptimizationProblem(optprob, var_init; lb=var_lb, ub=var_ub, lcons=con_lbs, ucons=con_ubs)
end

function solve_opf_optimization(dataset; adchoice = Optimization.AutoSparseReverseDiff())
    model_build_time = @elapsed prob = build_opf_optimization_prob(dataset; adchoice)

    # Correctness tests
    ret = zeros(length(prob.lcons))
    prob.f.cons(ret, prob.u0, nothing)
    @allocated prob.f(prob.u0, nothing) == 0
    @allocated prob.f.cons(ret, prob.u0, nothing) == 0

    solve_time_with_compilation = @elapsed sol = Optimization.solve(prob, Ipopt.Optimizer(), print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    cost = sol.minimum
    feasible = (sol.retcode == Optimization.SciMLBase.ReturnCode.Success)
    #println(sol.u) # solution vector

    solve_time_without_compilation = @elapsed sol = Optimization.solve(prob, Ipopt.Optimizer(), print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    
    return (prob,sol),Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; length(prob.u0),
        &quot;constraints&quot; =&gt; length(prob.lcons),
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_optimization_prob(dataset, test_u0)
    prob = build_opf_optimization_prob(dataset)
    ret = zeros(length(prob.lcons))
    prob.f.cons(ret, test_u0, nothing)
    obj = prob.f(test_u0, nothing)
    obj, ret
end</code></pre><pre><code class="nohighlight hljs">test_optimization_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">optimization_test_res = test_optimization_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(7079.190664351089, [0.0215258802699263, -1.0701734802505833, -5.1089022168
49063, -3.49724505910433, -2.617834191007569, 0.5457423426033834, -0.715025
1969424766, -2.473175092089014, -2.071687022809815, -1.5522321037165985  … 
 1.2740182727083802, 0.11298343104675009, 0.2518186223833513, 0.42026166211
30535, 0.3751697141306502, 0.4019890236200105, 0.5950107614751935, 1.002107
4654956683, 0.897077248544158, 0.15136310228960612])</code></pre><pre><code class="language-julia hljs">@assert optimization_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert optimization_test_res[2] == test_cons</code></pre><h2 id="JuMP.jl"><a class="docs-heading-anchor" href="#JuMP.jl">JuMP.jl</a><a id="JuMP.jl-1"></a><a class="docs-heading-anchor-permalink" href="#JuMP.jl" title="Permalink"></a></h2><p>Implementation reference: https://github.com/lanl-ansi/PowerModelsAnnex.jl/blob/master/src/model/ac-opf.jl Only the built-in AD library is supported</p><pre><code class="language-julia hljs">import PowerModels
import Ipopt
import JuMP

function build_opf_jump_prob(dataset)
    (;data, ref) = dataset
    constraints = Any[]
    model = JuMP.Model(Ipopt.Optimizer)

    vars = [JuMP.@variable(model, va[i in keys(ref[:bus])]),
            JuMP.@variable(model, ref[:bus][i][&quot;vmin&quot;] &lt;= vm[i in keys(ref[:bus])] &lt;= ref[:bus][i][&quot;vmax&quot;], start=1.0),
            JuMP.@variable(model, ref[:gen][i][&quot;pmin&quot;] &lt;= pg[i in keys(ref[:gen])] &lt;= ref[:gen][i][&quot;pmax&quot;]),
            JuMP.@variable(model, ref[:gen][i][&quot;qmin&quot;] &lt;= qg[i in keys(ref[:gen])] &lt;= ref[:gen][i][&quot;qmax&quot;]),
            JuMP.@variable(model, -ref[:branch][l][&quot;rate_a&quot;] &lt;= p[(l,i,j) in ref[:arcs]] &lt;= ref[:branch][l][&quot;rate_a&quot;]),
            JuMP.@variable(model, -ref[:branch][l][&quot;rate_a&quot;] &lt;= q[(l,i,j) in ref[:arcs]] &lt;= ref[:branch][l][&quot;rate_a&quot;])]

    JuMP.@objective(model, Min, sum(gen[&quot;cost&quot;][1]*pg[i]^2 + gen[&quot;cost&quot;][2]*pg[i] + gen[&quot;cost&quot;][3] for (i,gen) in ref[:gen]))

    for (i,bus) in ref[:ref_buses]
        push!(constraints,JuMP.@constraint(model, va[i] == 0))
    end

    for (i,bus) in ref[:bus]
        bus_loads = [ref[:load][l] for l in ref[:bus_loads][i]]
        bus_shunts = [ref[:shunt][s] for s in ref[:bus_shunts][i]]

        push!(constraints,JuMP.@constraint(model,
            sum(p[a] for a in ref[:bus_arcs][i]) ==
            sum(pg[g] for g in ref[:bus_gens][i]) -
            sum(load[&quot;pd&quot;] for load in bus_loads) -
            sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        ))

        push!(constraints,JuMP.@constraint(model,
            sum(q[a] for a in ref[:bus_arcs][i]) ==
            sum(qg[g] for g in ref[:bus_gens][i]) -
            sum(load[&quot;qd&quot;] for load in bus_loads) +
            sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        ))
    end

    # Branch power flow physics and limit constraints
    for (i,branch) in ref[:branch]
        f_idx = (i, branch[&quot;f_bus&quot;], branch[&quot;t_bus&quot;])
        t_idx = (i, branch[&quot;t_bus&quot;], branch[&quot;f_bus&quot;])

        p_fr = p[f_idx]
        q_fr = q[f_idx]
        p_to = p[t_idx]
        q_to = q[t_idx]

        vm_fr = vm[branch[&quot;f_bus&quot;]]
        vm_to = vm[branch[&quot;t_bus&quot;]]
        va_fr = va[branch[&quot;f_bus&quot;]]
        va_to = va[branch[&quot;t_bus&quot;]]

        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)
        ttm = tr^2 + ti^2
        g_fr = branch[&quot;g_fr&quot;]
        b_fr = branch[&quot;b_fr&quot;]
        g_to = branch[&quot;g_to&quot;]
        b_to = branch[&quot;b_to&quot;]

        # From side of the branch flow
        push!(constraints,JuMP.@NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) ))
        push!(constraints,JuMP.@NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) ))

        # To side of the branch flow
        push!(constraints,JuMP.@NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) ))
        push!(constraints,JuMP.@NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) ))

        # Voltage angle difference limit
        push!(constraints,JuMP.@constraint(model, branch[&quot;angmin&quot;] &lt;= va_fr - va_to &lt;= branch[&quot;angmax&quot;]))

        # Apparent power limit, from side and to side
        push!(constraints,JuMP.@constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2))
        push!(constraints,JuMP.@constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2))
    end

    model_variables = JuMP.num_variables(model)

    # for consistency with other solvers, skip the variable bounds in the constraint count
    non_nl_constraints = sum(JuMP.num_constraints(model, ft, st) for (ft, st) in JuMP.list_of_constraint_types(model) if ft != JuMP.VariableRef)
    model_constraints = JuMP.num_nonlinear_constraints(model) + non_nl_constraints

    model, vars, constraints
end

function solve_opf_jump(dataset)
    model_build_time = @elapsed model = build_opf_jump_prob(dataset)[1]
    JuMP.set_attribute(model, &quot;max_cpu_time&quot;, MAX_CPU_TIME)
    JuMP.set_attribute(model, &quot;print_level&quot;, PRINT_LEVEL)

    solve_time_with_compilation = @elapsed JuMP.optimize!(model)
    solve_time_without_compilation = @elapsed JuMP.optimize!(model)

    cost = JuMP.objective_value(model)
    feasible = (JuMP.termination_status(model) == JuMP.LOCALLY_SOLVED)

    nlp_block = JuMP.MOI.get(model, JuMP.MOI.NLPBlock())
    total_callback_time =
        nlp_block.evaluator.eval_objective_timer +
        nlp_block.evaluator.eval_objective_gradient_timer +
        nlp_block.evaluator.eval_constraint_timer +
        nlp_block.evaluator.eval_constraint_jacobian_timer +
        nlp_block.evaluator.eval_hessian_lagrangian_timer
    model_variables = JuMP.num_variables(model)
    non_nl_constraints = sum(JuMP.num_constraints(model, ft, st) for (ft, st) in JuMP.list_of_constraint_types(model) if ft != JuMP.VariableRef)
    model_constraints = JuMP.num_nonlinear_constraints(model) + non_nl_constraints
    
    return model, Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_jump_prob(dataset, test_u0)
    model, vars, constraints  = build_opf_jump_prob(dataset)
    (;
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij) = dataset
    f = JuMP.objective_function(model)

    flatvars = reduce(vcat,[reduce(vcat,vars[i]) for i in 1:length(vars)])
    point = Dict()
    for v in flatvars
        varname, varint = split(JuMP.name(v), &quot;[&quot;)
        idx = if varint[1] == &#39;(&#39;
            varint = (parse(Int, varint[2]), parse(Int, varint[5]), parse(Int, varint[8]))
            if varname == &quot;p&quot;
                lookup_p_lij[findfirst(x-&gt;x==varint,lookup_lij)]
            elseif varname == &quot;q&quot;
                lookup_q_lij[findfirst(x-&gt;x==varint,lookup_lij)]
            else
                error(&quot;Invalid $varname, $varint&quot;)
            end
        else
            varint = parse(Int, varint[1:end-1])
            if varname == &quot;va&quot;
                lookup_va[varint]
            elseif varname == &quot;pg&quot;
                lookup_pg[varint]
            elseif varname == &quot;qg&quot;
                lookup_qg[varint]
            elseif varname == &quot;vm&quot;
                lookup_vm[varint]
            else
                error(&quot;Invalid $varname, $varint&quot;)
            end
        end
        point[v] = test_u0[idx]
    end
    obj = JuMP.value(x-&gt;point[x], f)

    # The JuMP assertion error is because JuMP and optimization.jl build different problems. JuMP builds f(x) == a and optimization.jl builds f(x) - a == 0
    # Workaround this for consistent evaluation
    # It&#39;s not a general purpose approach because only some of the Optimization.jl constraints are written as f(x) - a = 0 . 
    # Others are written as f(x) &lt;= a, like the p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2 constraints

    primal_value(set::JuMP.MOI.EqualTo) = JuMP.MOI.constant(set)
    primal_value(set) = 0.0
    function primal_value(f, constraint)
        object = JuMP.constraint_object(constraint)
        fx = JuMP.value(f, object.func)
        return fx - primal_value(object.set)
    end
    function primal_value(f, constraint::JuMP.NonlinearConstraintRef)
        return JuMP.value(f, constraint)
    end
    obj = JuMP.value(x-&gt;point[x], f)
    cons = [primal_value(x-&gt;point[x], c) for c in constraints]
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_jump_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">jump_test_res = test_jump_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(7079.190664351089, [0.0215258802699263, 1.0701734802505833, 0.715025196942
4766, 5.108902216849064, 2.473175092089014, 3.49724505910433, 2.07168702280
9815, 2.6178341910075695, 1.5522321037165985, -0.5457423426033834  …  0.006
1762164203837955, 0.2518186223833513, 0.897077248544158, 1.633412293595111,
 -1.4932615291788414, -1.5810450617647889, 1.6000837514115611, -0.306512552
2705683, 0.4202616621130535, 0.15136310228960612])</code></pre><pre><code class="language-julia hljs">@assert jump_test_res[1] ≈ test_obj</code></pre><pre><code class="language-julia hljs">@assert sort(abs.(jump_test_res[2])) ≈ sort(abs.(test_cons))</code></pre><h2 id="NLPModels.jl"><a class="docs-heading-anchor" href="#NLPModels.jl">NLPModels.jl</a><a id="NLPModels.jl-1"></a><a class="docs-heading-anchor-permalink" href="#NLPModels.jl" title="Permalink"></a></h2><p>Implementation reference: https://juliasmoothoptimizers.github.io/ADNLPModels.jl/stable/tutorial/ Other AD libraries can be considered: https://juliasmoothoptimizers.github.io/ADNLPModels.jl/stable/</p><pre><code class="language-julia hljs">import ADNLPModels
import NLPModelsIpopt

function build_opf_nlpmodels_prob(dataset)
    (;data, ref) = dataset

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        push!(var_init, 0.0) #pg
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #qg
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1
    #total_callback_time = 0.0
    function opf_objective(x)
        #start = time()
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[var_lookup[&quot;pg_$(i)&quot;]]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints!(cx, x)
        #start = time()

        va = Dict(i =&gt; x[var_lookup[&quot;va_$(i)&quot;]] for (i,bus) in ref[:bus])
        vm = Dict(i =&gt; x[var_lookup[&quot;vm_$(i)&quot;]] for (i,bus) in ref[:bus])

        pg = Dict(i =&gt; x[var_lookup[&quot;pg_$(i)&quot;]] for (i,gen) in ref[:gen])
        qg = Dict(i =&gt; x[var_lookup[&quot;qg_$(i)&quot;]] for (i,gen) in ref[:gen])

        p = Dict((l,i,j) =&gt; x[var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])
        q = Dict((l,i,j) =&gt; x[var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])

        vm_fr = Dict(l =&gt; vm[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        vm_to = Dict(l =&gt; vm[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])
        va_fr = Dict(l =&gt; va[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        va_to = Dict(l =&gt; va[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])


        # va_con = [va[i] for (i,bus) in ref[:ref_buses]]
        k = 0
        for (i,bus) in ref[:ref_buses]
            k += 1
            cx[k] = va[i]
        end

        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        for (i, bus) in ref[:bus]
            k += 1
            cx[k] = sum(pg[j] for j in ref[:bus_gens][i]; init=0.0) - bus_pd[i] - bus_gs[i]*vm[i]^2 - sum(p[a] for a in ref[:bus_arcs][i])
        end

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(qg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        for (i, bus) in ref[:bus]
            k += 1
            cx[k] = sum(qg[j] for j in ref[:bus_gens][i]; init=0.0) - bus_qd[i] + bus_bs[i]*vm[i]^2 - sum(q[a] for a in ref[:bus_arcs][i])
        end


        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = (br_g[l]+br_g_fr[l])/br_ttm[l]*vm_fr[l]^2 +
            (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
            (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
            p[(l,i,j)]
        end

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = (br_g[l]+br_g_to[l])*vm_to[l]^2 +
            (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
            (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
            p[(l,i,j)]
        end

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = -(br_b[l]+br_b_fr[l])/br_ttm[l]*vm_fr[l]^2 -
            (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
            (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
            q[(l,i,j)]
        end

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = -(br_b[l]+br_b_to[l])*vm_to[l]^2 -
            (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
            (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
            q[(l,i,j)]
        end

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = va_fr[l] - va_to[l]
        end

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        for (l,i,j) in ref[:arcs_from]
            k += 1
            cx[k] = p[(l,i,j)]^2 + q[(l,i,j)]^2
        end

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        for (l,i,j) in ref[:arcs_to]
            k += 1
            cx[k] = p[(l,i,j)]^2 + q[(l,i,j)]^2
        end

        #total_callback_time += time() - start
        return cx
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    model_variables = length(var_init)
    model_constraints = length(opf_constraints!(similar(con_lbs), var_init))

    nlp = ADNLPModels.ADNLPModel!(opf_objective, var_init, var_lb, var_ub, opf_constraints!, con_lbs, con_ubs, backend = :optimized)
end

function solve_opf_nlpmodels(dataset)
    model_build_time = @elapsed nlp = build_opf_nlpmodels_prob(dataset)
    solve_time_with_compilation = @elapsed output = NLPModelsIpopt.ipopt(nlp, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    solve_time_without_compilation = @elapsed output = NLPModelsIpopt.ipopt(nlp, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME)
    cost = output.objective
    feasible = (output.primal_feas &lt;= 1e-6)  

    model_variables = nlp.meta.nvar
    model_constraints = nlp.meta.ncon

    return (nlp, output), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_nlpmodels_prob(dataset, test_u0)
    nlp = build_opf_nlpmodels_prob(dataset)
    ret = zeros(nlp.meta.ncon)
    nlp.c!(ret, test_u0)
    obj = nlp.f(test_u0)
    obj, ret
end</code></pre><pre><code class="nohighlight hljs">test_nlpmodels_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">nlpmodels_test_res = test_nlpmodels_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(7079.190664351089, [0.0215258802699263, -1.0701734802505833, -5.1089022168
49063, -3.49724505910433, -2.617834191007569, 0.5457423426033834, -0.715025
1969424766, -2.473175092089014, -2.071687022809815, -1.5522321037165985  … 
 1.2740182727083802, 0.11298343104675009, 0.2518186223833513, 0.42026166211
30535, 0.3751697141306502, 0.4019890236200105, 0.5950107614751935, 1.002107
4654956683, 0.897077248544158, 0.15136310228960612])</code></pre><pre><code class="language-julia hljs">@assert nlpmodels_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert nlpmodels_test_res[2] == test_cons</code></pre><h2 id="Nonconvex"><a class="docs-heading-anchor" href="#Nonconvex">Nonconvex</a><a id="Nonconvex-1"></a><a class="docs-heading-anchor-permalink" href="#Nonconvex" title="Permalink"></a></h2><p>Implementation reference: https://julianonconvex.github.io/Nonconvex.jl/stable/problem/ Currently does not converge due to an upstream issue with the AD backend Zygote: https://github.com/JuliaNonconvex/Nonconvex.jl/issues/130</p><pre><code class="language-julia hljs">import Nonconvex
Nonconvex.@load Ipopt

function build_opf_nonconvex_prob(dataset)
    (;data, ref) = dataset
    time_model_start = time()

    model = Nonconvex.DictModel()

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_rate_a = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_angmin = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_angmax = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]

        br_rate_a[i] = branch[&quot;rate_a&quot;]
        br_angmin[i] = branch[&quot;angmin&quot;]
        br_angmax[i] = branch[&quot;angmax&quot;]
    end


    for (i,bus) in ref[:bus]
        addvar!(model, &quot;va_$(i)&quot;, -Inf, Inf, init=0.0) #va
        addvar!(model, &quot;vm_$(i)&quot;, bus[&quot;vmin&quot;], bus[&quot;vmax&quot;], init=1.0) #vm
    end

    for (i,gen) in ref[:gen]
        addvar!(model, &quot;pg_$(i)&quot;, gen[&quot;pmin&quot;], gen[&quot;pmax&quot;], init=0.0) #pg
        addvar!(model, &quot;qg_$(i)&quot;, gen[&quot;qmin&quot;], gen[&quot;qmax&quot;], init=0.0) #qg
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]
        addvar!(model, &quot;p_$(l)_$(i)_$(j)&quot;, -branch[&quot;rate_a&quot;], branch[&quot;rate_a&quot;], init=0.0) #p
        addvar!(model, &quot;q_$(l)_$(i)_$(j)&quot;, -branch[&quot;rate_a&quot;], branch[&quot;rate_a&quot;], init=0.0) #q
    end


    # JuMP.@objective(model, Min, sum(gen[&quot;cost&quot;][1]*pg[i]^2 + gen[&quot;cost&quot;][2]*pg[i] + gen[&quot;cost&quot;][3] for (i,gen) in ref[:gen]))
    function opf_objective(x::OrderedDict)
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[&quot;pg_$(i)&quot;]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        return cost
    end
    Nonconvex.set_objective!(model, opf_objective)

    # JuMP.@constraint(model, va[i] == 0)
    function const_ref_bus(x::OrderedDict, i)
        return x[&quot;va_$(i)&quot;]
    end
    for (i,bus) in ref[:ref_buses]
        add_eq_constraint!(model, x -&gt; const_ref_bus(x,i))
    end

    # @constraint(model,
    #     sum(p[a] for a in ref[:bus_arcs][i]) ==
    #     sum(pg[g] for g in ref[:bus_gens][i]) -
    #     sum(load[&quot;pd&quot;] for load in bus_loads) -
    #     sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
    # )
    function const_power_balance_p(x::OrderedDict, b)
        balance = - bus_pd[b] - bus_gs[b]*x[&quot;vm_$(b)&quot;]^2
        for (l,i,j) in ref[:bus_arcs][b]
            balance -= x[&quot;p_$(l)_$(i)_$(j)&quot;]
        end
        for j in ref[:bus_gens][b]
            balance += x[&quot;pg_$(j)&quot;]
        end
        return balance
    end

    # @constraint(model,
    #     sum(q[a] for a in ref[:bus_arcs][i]) ==
    #     sum(qg[g] for g in ref[:bus_gens][i]) -
    #     sum(load[&quot;qd&quot;] for load in bus_loads) +
    #     sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
    # )
    function const_power_balance_q(x::OrderedDict, b)
        balance = - bus_qd[b] + bus_bs[b]*x[&quot;vm_$(b)&quot;]^2
        for (l,i,j) in ref[:bus_arcs][b]
            balance -= x[&quot;q_$(l)_$(i)_$(j)&quot;]
        end
        for j in ref[:bus_gens][b]
            balance += x[&quot;qg_$(j)&quot;]
        end
        return balance
    end

    for (i,bus) in ref[:bus]
        add_eq_constraint!(model, x -&gt; const_power_balance_p(x,i))
        add_eq_constraint!(model, x -&gt; const_power_balance_q(x,i))
    end


    # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
    function const_flow_p_from(x::OrderedDict,l,i,j)
        return (br_g[l]+br_g_fr[l])/br_ttm[l]*x[&quot;vm_$(i)&quot;]^2 +
        (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*cos(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) +
        (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*sin(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) -
        x[&quot;p_$(l)_$(i)_$(j)&quot;]
    end
    # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
    function const_flow_q_from(x::OrderedDict,l,i,j)
        return -(br_b[l]+br_b_fr[l])/br_ttm[l]*x[&quot;vm_$(i)&quot;]^2 -
       (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*cos(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) +
       (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(i)&quot;]*x[&quot;vm_$(j)&quot;]*sin(x[&quot;va_$(i)&quot;]-x[&quot;va_$(j)&quot;])) -
       x[&quot;q_$(l)_$(i)_$(j)&quot;]
    end

    # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
    function const_flow_p_to(x::OrderedDict,l,i,j)
        return (br_g[l]+br_g_to[l])*x[&quot;vm_$(j)&quot;]^2 +
        (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*cos(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) +
        (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*sin(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) -
        x[&quot;p_$(l)_$(j)_$(i)&quot;]
    end
    # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
    function const_flow_q_to(x::OrderedDict,l,i,j)
       return -(br_b[l]+br_b_to[l])*x[&quot;vm_$(j)&quot;]^2 -
       (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*cos(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) +
       (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(x[&quot;vm_$(j)&quot;]*x[&quot;vm_$(i)&quot;]*sin(x[&quot;va_$(j)&quot;]-x[&quot;va_$(i)&quot;])) -
       x[&quot;q_$(l)_$(j)_$(i)&quot;]
    end

    function const_thermal_limit(x::OrderedDict,l,i,j)
       return x[&quot;p_$(l)_$(i)_$(j)&quot;]^2 + x[&quot;q_$(l)_$(i)_$(j)&quot;]^2 - br_rate_a[l]^2
    end

    function const_voltage_angle_difference_lb(x::OrderedDict,l,i,j)
       return br_angmin[l] - x[&quot;va_$(i)&quot;] + x[&quot;va_$(j)&quot;]
    end

    function const_voltage_angle_difference_ub(x::OrderedDict,l,i,j)
       return x[&quot;va_$(i)&quot;] - x[&quot;va_$(j)&quot;] - br_angmax[l]
    end

    for (l,i,j) in ref[:arcs_from]
        add_eq_constraint!(model, x -&gt; const_flow_p_from(x,l,i,j))
        add_eq_constraint!(model, x -&gt; const_flow_q_from(x,l,i,j))

        add_eq_constraint!(model, x -&gt; const_flow_p_to(x,l,i,j))
        add_eq_constraint!(model, x -&gt; const_flow_q_to(x,l,i,j))

        add_ineq_constraint!(model, x -&gt; const_thermal_limit(x,l,i,j))
        add_ineq_constraint!(model, x -&gt; const_thermal_limit(x,l,j,i))

        add_ineq_constraint!(model, x -&gt; const_voltage_angle_difference_lb(x,l,i,j))
        add_ineq_constraint!(model, x -&gt; const_voltage_angle_difference_ub(x,l,i,j))
    end
    model
end

function solve_opf_nonconvex(dataset)
    model_build_time = @elapsed model = build_opf_nonconvex_prob(dataset)

    solve_time_with_compilation = @elapsed result = Nonconvex.optimize(
        model,
        IpoptAlg(),
        NonconvexCore.getinit(model);
        options = IpoptOptions(; first_order=false, symbolic=true, sparse=true, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME),
    )

    solve_time_without_compilation = @elapsed result = Nonconvex.optimize(
        model,
        IpoptAlg(),
        NonconvexCore.getinit(model);
        options = IpoptOptions(; first_order=false, symbolic=true, sparse=true, print_level = PRINT_LEVEL, max_cpu_time = MAX_CPU_TIME),
    )

    cost = result.minimum
    feasible = result.status == 0 # just guessing this is correct for Ipopt

    model_variables = Nonconvex.NonconvexCore.getnvars(model)
    model_constraints = Nonconvex.NonconvexCore.getnconstraints(model)

    return (model, result), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_nonconvex_prob(dataset, test_u0)
    model = build_opf_nonconvex_prob(dataset)
        (;
    lookup_pg,
    lookup_qg,
    lookup_va,
    lookup_vm,
    lookup_lij,
    lookup_p_lij,
    lookup_q_lij) = dataset

    point = Dict()
    for v in keys(model.init)
        varsplit = split(v, &quot;_&quot;)
        varname = varsplit[1]
        varint = parse.(Int, varsplit[2:end])

        idx = if varname == &quot;p&quot;
            lookup_p_lij[findfirst(x-&gt;x==Tuple(varint),lookup_lij)]
        elseif varname == &quot;q&quot;
            lookup_q_lij[findfirst(x-&gt;x==Tuple(varint),lookup_lij)]
        elseif varname == &quot;va&quot;
            lookup_va[varint[1]]
        elseif varname == &quot;pg&quot;
            lookup_pg[varint[1]]
        elseif varname == &quot;qg&quot;
            lookup_qg[varint[1]]
        elseif varname == &quot;vm&quot;
            lookup_vm[varint[1]]
        else
            error(&quot;Invalid $varname, $varint&quot;)
        end
        point[v] = test_u0[idx]
    end
    u0 = OrderedDict(keys(model.init) .=&gt; getindex.((point,),keys(model.init)))
    obj = model.objective(u0)
    cons = vcat(model.eq_constraints(u0), model.ineq_constraints(u0))
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_nonconvex_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">nonconvex_test_res = test_nonconvex_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(7079.190664351089, [0.0215258802699263, -1.0701734802505833, -0.7150251969
424766, -5.108902216849064, -2.4731750920890136, -3.4972450591043294, -2.07
1687022809815, -2.617834191007569, -1.5522321037165985, 0.5457423426033834 
 …  -1.13747899115099, 0.09028143995439242, -17.895781377616647, -17.250522
75145584, -0.5297749920186825, -0.517422559177915, -15.579738337886946, -15
.848636897710394, -0.21708622332773042, -0.8301113278688671])</code></pre><pre><code class="language-julia hljs">@assert nonconvex_test_res[1] ≈ test_obj</code></pre><pre><code class="language-julia hljs">@assert sort(abs.(nonconvex_test_res[2])) ≈ sort(abs.(test_cons))</code></pre><pre><code class="nohighlight hljs">Error: DimensionMismatch: dimensions must match: a has dims (Base.OneTo(59)
,), b has dims (Base.OneTo(53),), mismatch at 1</code></pre><pre><code class="language-julia hljs">println(sort(abs.(nonconvex_test_res[2])))</code></pre><pre><code class="nohighlight hljs">[0.0215258802699263, 0.08410522353400862, 0.09028143995439242, 0.1947644725
1065077, 0.21708622332773042, 0.21730536348839036, 0.2849522377447594, 0.33
063890653376593, 0.33289810365419437, 0.45744368990710405, 0.51742255917791
5, 0.5297749920186825, 0.5457423426033834, 0.5897538612894937, 0.7150251969
424766, 0.7775962590542184, 0.8301113278688671, 0.8834081057449231, 1.01073
99030803794, 1.0688558672739048, 1.0701734802505833, 1.0793383525116511, 1.
1313027747306061, 1.13747899115099, 1.3778364577303637, 1.4038702698147258,
 1.4932615291788414, 1.5522321037165985, 1.563372246165339, 1.5810450617647
889, 1.6000837514115611, 1.633412293595111, 1.7030832394691608, 1.725257352
7333024, 2.0016715378998793, 2.071687022809815, 2.4731750920890136, 2.61783
4191007569, 2.8227966798520674, 3.0047739260369246, 3.1618224299953224, 3.2
236954017592256, 3.4972450591043294, 4.23535583005632, 4.48598172729162, 5.
108902216849064, 5.164989238524806, 7.40879932706212, 9.915310272572729, 15
.579738337886946, 15.848636897710394, 17.145492534504328, 17.25052275145584
, 17.422407182792668, 17.563254560708913, 17.745610976379986, 17.7724302858
69348, 17.895781377616647, 18.034616568953247]</code></pre><pre><code class="language-julia hljs">println(sort(abs.(test_cons)))</code></pre><pre><code class="nohighlight hljs">[0.0061762164203837955, 0.0215258802699263, 0.06615508569119477, 0.11298343
104675009, 0.15136310228960612, 0.19476447251065077, 0.21730536348839036, 0
.2518186223833513, 0.2849522377447594, 0.3065125522705683, 0.33289810365419
437, 0.3751697141306502, 0.4019890236200105, 0.4202616621130535, 0.54574234
26033834, 0.5843454392910835, 0.5950107614751935, 0.6077039991323074, 0.613
8802155526912, 0.7150251969424766, 0.7251928172073308, 0.7775962590542184, 
0.8542376821320647, 0.8834081057449231, 0.897077248544158, 1.00210746549566
83, 1.0107399030803794, 1.0688558672739048, 1.0701734802505833, 1.079338352
5116511, 1.2740182727083802, 1.4038702698147258, 1.4932615291788414, 1.5522
321037165985, 1.563372246165339, 1.5810450617647889, 1.6000837514115611, 1.
633412293595111, 1.7030832394691608, 1.7252573527333024, 2.0016715378998793
, 2.071687022809815, 2.473175092089014, 2.617834191007569, 2.82279667985206
74, 3.0047739260369246, 3.1618224299953224, 3.2236954017592256, 3.497245059
10433, 4.23535583005632, 5.108902216849063, 7.40879932706212, 9.91531027257
2729]</code></pre><h2 id="Optim.jl"><a class="docs-heading-anchor" href="#Optim.jl">Optim.jl</a><a id="Optim.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Optim.jl" title="Permalink"></a></h2><p>Implementation reference: https://julianlsolvers.github.io/Optim.jl/stable/#examples/generated/ipnewton_basics/ Currently does not converge to a feasible point, root cause in unclear <code>debug/optim-debug.jl</code> can be used to confirm it will converge if given a suitable starting point</p><pre><code class="language-julia hljs">import Optim

function build_opf_optim_prob(dataset)
    (;data, ref) = dataset

    bus_pd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_qd = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    bus_gs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])
    bus_bs = Dict(i =&gt; 0.0 for (i,bus) in ref[:bus])

    for (i,bus) in ref[:bus]
        if length(ref[:bus_loads][i]) &gt; 0
            bus_pd[i] = sum(ref[:load][l][&quot;pd&quot;] for l in ref[:bus_loads][i])
            bus_qd[i] = sum(ref[:load][l][&quot;qd&quot;] for l in ref[:bus_loads][i])
        end

        if length(ref[:bus_shunts][i]) &gt; 0
            bus_gs[i] = sum(ref[:shunt][s][&quot;gs&quot;] for s in ref[:bus_shunts][i])
            bus_bs[i] = sum(ref[:shunt][s][&quot;bs&quot;] for s in ref[:bus_shunts][i])
        end
    end


    br_g = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_tr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ti = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_ttm = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    br_g_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_fr = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_g_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])
    br_b_to = Dict(i =&gt; 0.0 for (i,branch) in ref[:branch])

    for (i,branch) in ref[:branch]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)

        br_g[i] = g
        br_b[i] = b

        br_tr[i] = tr
        br_ti[i] = ti
        br_ttm[i] = tr^2 + ti^2

        br_g_fr[i] = branch[&quot;g_fr&quot;]
        br_b_fr[i] = branch[&quot;b_fr&quot;]
        br_g_to[i] = branch[&quot;g_to&quot;]
        br_b_to[i] = branch[&quot;b_to&quot;]
    end

    var_lookup = Dict{String,Int}()

    var_init = Float64[]
    var_lb = Float64[]
    var_ub = Float64[]

    var_idx = 1
    for (i,bus) in ref[:bus]
        push!(var_init, 0.0) #va
        push!(var_lb, -Inf)
        push!(var_ub, Inf)
        var_lookup[&quot;va_$(i)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 1.0) #vm
        push!(var_lb, bus[&quot;vmin&quot;])
        push!(var_ub, bus[&quot;vmax&quot;])
        var_lookup[&quot;vm_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (i,gen) in ref[:gen]
        #push!(var_init, 0.0) #pg
        push!(var_init, (gen[&quot;pmax&quot;]+gen[&quot;pmin&quot;])/2) # non-standard start
        push!(var_lb, gen[&quot;pmin&quot;])
        push!(var_ub, gen[&quot;pmax&quot;])
        var_lookup[&quot;pg_$(i)&quot;] = var_idx
        var_idx += 1

        #push!(var_init, 0.0) #qg
        push!(var_init, (gen[&quot;qmax&quot;]+gen[&quot;qmin&quot;])/2) # non-standard start
        push!(var_lb, gen[&quot;qmin&quot;])
        push!(var_ub, gen[&quot;qmax&quot;])
        var_lookup[&quot;qg_$(i)&quot;] = var_idx
        var_idx += 1
    end

    for (l,i,j) in ref[:arcs]
        branch = ref[:branch][l]

        push!(var_init, 0.0) #p
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1

        push!(var_init, 0.0) #q
        push!(var_lb, -branch[&quot;rate_a&quot;])
        push!(var_ub,  branch[&quot;rate_a&quot;])
        var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;] = var_idx
        var_idx += 1
    end

    @assert var_idx == length(var_init)+1
    #total_callback_time = 0.0
    function opf_objective(x)
        #start = time()
        cost = 0.0
        for (i,gen) in ref[:gen]
            pg = x[var_lookup[&quot;pg_$(i)&quot;]]
            cost += gen[&quot;cost&quot;][1]*pg^2 + gen[&quot;cost&quot;][2]*pg + gen[&quot;cost&quot;][3]
        end
        #total_callback_time += time() - start
        return cost
    end

    function opf_constraints(c,x)
        #start = time()
        va = Dict(i =&gt; x[var_lookup[&quot;va_$(i)&quot;]] for (i,bus) in ref[:bus])
        vm = Dict(i =&gt; x[var_lookup[&quot;vm_$(i)&quot;]] for (i,bus) in ref[:bus])

        pg = Dict(i =&gt; x[var_lookup[&quot;pg_$(i)&quot;]] for (i,gen) in ref[:gen])
        qg = Dict(i =&gt; x[var_lookup[&quot;qg_$(i)&quot;]] for (i,gen) in ref[:gen])

        p = Dict((l,i,j) =&gt; x[var_lookup[&quot;p_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])
        q = Dict((l,i,j) =&gt; x[var_lookup[&quot;q_$(l)_$(i)_$(j)&quot;]] for (l,i,j) in ref[:arcs])

        vm_fr = Dict(l =&gt; vm[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        vm_to = Dict(l =&gt; vm[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])
        va_fr = Dict(l =&gt; va[branch[&quot;f_bus&quot;]] for (l,branch) in ref[:branch])
        va_to = Dict(l =&gt; va[branch[&quot;t_bus&quot;]] for (l,branch) in ref[:branch])


        va_con = [va[i] for (i,bus) in ref[:ref_buses]]

        #     @constraint(model,
        #         sum(p[a] for a in ref[:bus_arcs][i]) ==
        #         sum(pg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;pd&quot;] for load in bus_loads) -
        #         sum(shunt[&quot;gs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        power_balance_p_con = [
           sum(pg[j] for j in ref[:bus_gens][i]; init=0.0) -
           bus_pd[i] -
           bus_gs[i]*vm[i]^2 -
           sum(p[a] for a in ref[:bus_arcs][i])
           for (i,bus) in ref[:bus]
        ]

        #     @constraint(model,
        #         sum(q[a] for a in ref[:bus_arcs][i]) ==
        #         sum(qg[g] for g in ref[:bus_gens][i]) -
        #         sum(load[&quot;qd&quot;] for load in bus_loads) +
        #         sum(shunt[&quot;bs&quot;] for shunt in bus_shunts)*vm[i]^2
        #     )
        power_balance_q_con = [
           sum(qg[j] for j in ref[:bus_gens][i]; init=0.0) -
           bus_qd[i] +
           bus_bs[i]*vm[i]^2 -
           sum(q[a] for a in ref[:bus_arcs][i])
           for (i,bus) in ref[:bus]
        ]


        # @NLconstraint(model, p_fr ==  (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        power_flow_p_from_con = [
           (br_g[l]+br_g_fr[l])/br_ttm[l]*vm_fr[l]^2 +
           (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
           (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
           p[(l,i,j)]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @NLconstraint(model, p_to ==  (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        power_flow_p_to_con = [
           (br_g[l]+br_g_to[l])*vm_to[l]^2 +
           (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
           (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
           p[(l,i,j)]
           for (l,i,j) in ref[:arcs_to]
        ]

        # @NLconstraint(model, q_fr == -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*sin(va_fr-va_to)) )
        power_flow_q_from_con = [
           -(br_b[l]+br_b_fr[l])/br_ttm[l]*vm_fr[l]^2 -
           (-br_b[l]*br_tr[l]-br_g[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*cos(va_fr[l]-va_to[l])) +
           (-br_g[l]*br_tr[l]+br_b[l]*br_ti[l])/br_ttm[l]*(vm_fr[l]*vm_to[l]*sin(va_fr[l]-va_to[l])) -
           q[(l,i,j)]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @NLconstraint(model, q_to == -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*sin(va_to-va_fr)) )
        power_flow_q_to_con = [
           -(br_b[l]+br_b_to[l])*vm_to[l]^2 -
           (-br_b[l]*br_tr[l]+br_g[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*cos(va_to[l]-va_fr[l])) +
           (-br_g[l]*br_tr[l]-br_b[l]*br_ti[l])/br_ttm[l]*(vm_to[l]*vm_fr[l]*sin(va_to[l]-va_fr[l])) -
           q[(l,i,j)]
           for (l,i,j) in ref[:arcs_to]
        ]

        # @constraint(model, va_fr - va_to &lt;= branch[&quot;angmax&quot;])
        # @constraint(model, va_fr - va_to &gt;= branch[&quot;angmin&quot;])
        power_flow_vad_con = [
           va_fr[l] - va_to[l]
           for (l,i,j) in ref[:arcs_from]
        ]

        # @constraint(model, p_fr^2 + q_fr^2 &lt;= branch[&quot;rate_a&quot;]^2)
        power_flow_mva_from_con = [
           p[(l,i,j)]^2 + q[(l,i,j)]^2
           for (l,i,j) in ref[:arcs_from]
        ]

        # @constraint(model, p_to^2 + q_to^2 &lt;= branch[&quot;rate_a&quot;]^2)
        power_flow_mva_to_con = [
           p[(l,i,j)]^2 + q[(l,i,j)]^2
           for (l,i,j) in ref[:arcs_to]
        ]

        c .= [
            va_con...,
            power_balance_p_con...,
            power_balance_q_con...,
            power_flow_p_from_con...,
            power_flow_p_to_con...,
            power_flow_q_from_con...,
            power_flow_q_to_con...,
            power_flow_vad_con...,
            power_flow_mva_from_con...,
            power_flow_mva_to_con...,
        ]
        #total_callback_time += time() - start
        return c
    end

    con_lbs = Float64[]
    con_ubs = Float64[]

    #@constraint(model, va[i] == 0)
    for (i,bus) in ref[:ref_buses]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end


    #power_balance_p_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
        #push!(con_lbs, -Inf)
        #push!(con_ubs, Inf)
    end

    #power_balance_q_con
    for (i,bus) in ref[:bus]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
        #push!(con_lbs, -Inf)
        #push!(con_ubs, Inf)
    end


    #power_flow_p_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_p_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_from_con
    for (l,i,j) in ref[:arcs_from]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_q_to_con
    for (l,i,j) in ref[:arcs_to]
        push!(con_lbs, 0.0)
        push!(con_ubs, 0.0)
    end

    #power_flow_vad_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, branch[&quot;angmin&quot;])
        push!(con_ubs, branch[&quot;angmax&quot;])
    end

    #power_flow_mva_from_con
    for (l,i,j) in ref[:arcs_from]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    #power_flow_mva_to_con
    for (l,i,j) in ref[:arcs_to]
        branch = ref[:branch][l]
        push!(con_lbs, -Inf)
        push!(con_ubs, branch[&quot;rate_a&quot;]^2)
    end

    df = Optim.TwiceDifferentiable(opf_objective, var_init)
    dfc = Optim.TwiceDifferentiableConstraints(opf_constraints, var_lb, var_ub, con_lbs, con_ubs)
    df, dfc, var_init, con_lbs, con_ubs
end

function solve_opf_optim(dataset)
    model_build_time = @elapsed df, dfc, var_init, con_lbs, con_ubs = build_opf_optim_prob(dataset)

    options = Optim.Options(show_trace=PRINT_LEVEL == 0,time_limit=MAX_CPU_TIME)
    solve_time_with_compilation = @elapsed res = Optim.optimize(df, dfc, var_init, Optim.IPNewton(), options)
    solve_time_without_compilation = @elapsed res = Optim.optimize(df, dfc, var_init, Optim.IPNewton(), options)

    sol = res.minimizer
    cost = res.minimum

    # NOTE: confirmed these constraint violations can be eliminated
    # if a better starting point is used
    sol_eval = dfc.c!(zeros(dfc.bounds.nc), sol)
    vio_lb = [max(v,0) for v in (con_lbs .- sol_eval)]
    vio_ub = [max(v,0) for v in (sol_eval .- con_ubs)]
    const_vio = vio_lb .+ vio_ub
    constraint_tol = 1e-6
    feasible = (sum(const_vio) &lt;= constraint_tol)

    return (res,), Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; length(var_init),
        &quot;constraints&quot; =&gt; dfc.bounds.nc,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time_without_compilation,
        &quot;time_solve_compilation&quot; =&gt; solve_time_with_compilation,
    )
end

function test_optim_prob(dataset, test_u0)
    df, dfc, var_init, con_lbs, con_ubs = build_opf_optim_prob(dataset)
    obj = df.f(test_u0)
    cons = dfc.c!(zeros(dfc.bounds.nc), test_u0)
    obj, cons
end</code></pre><pre><code class="nohighlight hljs">test_optim_prob (generic function with 1 method)</code></pre><pre><code class="language-julia hljs">optim_test_res = test_optim_prob(dataset, test_u0)</code></pre><pre><code class="nohighlight hljs">(7079.190664351089, [0.0215258802699263, -1.0701734802505833, -5.1089022168
49063, -3.49724505910433, -2.617834191007569, 0.5457423426033834, -0.715025
1969424766, -2.473175092089014, -2.071687022809815, -1.5522321037165985  … 
 1.2740182727083802, 0.11298343104675009, 0.2518186223833513, 0.42026166211
30535, 0.3751697141306502, 0.4019890236200105, 0.5950107614751935, 1.002107
4654956683, 0.897077248544158, 0.15136310228960612])</code></pre><pre><code class="language-julia hljs">@assert optim_test_res[1] == test_obj</code></pre><pre><code class="language-julia hljs">@assert optim_test_res[2] == test_cons</code></pre><h2 id="CASADI"><a class="docs-heading-anchor" href="#CASADI">CASADI</a><a id="CASADI-1"></a><a class="docs-heading-anchor-permalink" href="#CASADI" title="Permalink"></a></h2><p>Implementation reference: https://github.com/lanl-ansi/PowerModelsAnnex.jl/blob/master/src/model/ac-opf.jl</p><p>CASADI Segfaults so removed for now.</p><pre><code class="nohighlight hljs">import PowerModels
import PythonCall
import CondaPkg
CondaPkg.add(&quot;casadi&quot;)

function solve_opf_casadi(dataset)
    (;data, ref) = dataset

    time_model_start = time()

    casadi = PythonCall.pyimport(&quot;casadi&quot;)

    x, x0, lbx, ubx, cons, lbg, ubg = [], [], [], [], [], [], []
    va, vm = Dict{Int,Any}(), Dict{Int,Any}()
    for (k, _) in ref[:bus]
        va[k] = casadi.SX.sym(&quot;va$k&quot;)
        push!(x, va[k])
        push!(x0, 0.0)
        push!(lbx, -casadi.inf)
        push!(ubx, casadi.inf)
        vm[k] = casadi.SX.sym(&quot;vm$k&quot;)
        push!(x, vm[k])
        push!(x0, 1.0)
        push!(lbx, ref[:bus][k][&quot;vmin&quot;])
        push!(ubx, ref[:bus][k][&quot;vmax&quot;])
    end
    pg, qg = Dict{Int,Any}(), Dict{Int,Any}()
    for (k, ) in ref[:gen]
        pg[k] = casadi.SX.sym(&quot;pg$k&quot;)
        push!(x, pg[k])
        push!(x0, 0.0)
        push!(lbx, ref[:gen][k][&quot;pmin&quot;])
        push!(ubx, ref[:gen][k][&quot;pmax&quot;])
        qg[k] = casadi.SX.sym(&quot;qg$k&quot;)
        push!(x, qg[k])
        push!(x0, 0.0)
        push!(lbx, ref[:gen][k][&quot;qmin&quot;])
        push!(ubx, ref[:gen][k][&quot;qmax&quot;])
    end
    p, q = Dict{NTuple{3,Int},Any}(), Dict{NTuple{3,Int},Any}()
    for k in ref[:arcs]
        a = ref[:branch][k[1]][&quot;rate_a&quot;]
        p[k] = casadi.SX.sym(&quot;p$k&quot;)
        push!(x, p[k])
        push!(x0, 0.0)
        push!(lbx, -a)
        push!(ubx, a)
        q[k] = casadi.SX.sym(&quot;q$k&quot;)
        push!(x, q[k])
        push!(x0, 0.0)
        push!(lbx, -a)
        push!(ubx, a)
    end
    f = sum(
        cost[&quot;cost&quot;][1] * pg[k]^2 +
        cost[&quot;cost&quot;][2] * pg[k] +
        cost[&quot;cost&quot;][3] for (k, cost) in ref[:gen]
    )
    for (k, _) in ref[:ref_buses]
        push!(cons, va[k])
        push!(lbg, 0)
        push!(ubg, 0)
    end
    for (i, _) in ref[:bus]
        bus_loads = [ref[:load][l] for l in ref[:bus_loads][i]]
        bus_shunts = [ref[:shunt][s] for s in ref[:bus_shunts][i]]
        push!(
            cons,
            sum(p[k] for k in ref[:bus_arcs][i]) -
            sum(pg[g] for g in ref[:bus_gens][i]; init = 0) +
            sum(load[&quot;pd&quot;] for load in bus_loads; init = 0) +
            sum(shunt[&quot;gs&quot;] for shunt in bus_shunts; init = 0) * vm[i]^2
        )
        push!(lbg, 0)
        push!(ubg, 0)
        push!(
            cons,
            sum(q[k] for k in ref[:bus_arcs][i]) -
            sum(qg[g] for g in ref[:bus_gens][i]; init = 0) +
            sum(load[&quot;qd&quot;] for load in bus_loads; init = 0) -
            sum(shunt[&quot;bs&quot;] for shunt in bus_shunts; init = 0) * vm[i]^2
        )
        push!(lbg, 0)
        push!(ubg, 0)
    end
    for (i, branch) in ref[:branch]
        f_idx = (i, branch[&quot;f_bus&quot;], branch[&quot;t_bus&quot;])
        t_idx = (i, branch[&quot;t_bus&quot;], branch[&quot;f_bus&quot;])
        p_fr = p[f_idx]
        q_fr = q[f_idx]
        p_to = p[t_idx]
        q_to = q[t_idx]
        vm_fr = vm[branch[&quot;f_bus&quot;]]
        vm_to = vm[branch[&quot;t_bus&quot;]]
        va_fr = va[branch[&quot;f_bus&quot;]]
        va_to = va[branch[&quot;t_bus&quot;]]
        g, b = PowerModels.calc_branch_y(branch)
        tr, ti = PowerModels.calc_branch_t(branch)
        ttm = tr^2 + ti^2
        g_fr = branch[&quot;g_fr&quot;]
        b_fr = branch[&quot;b_fr&quot;]
        g_to = branch[&quot;g_to&quot;]
        b_to = branch[&quot;b_to&quot;]
        push!(
            cons,
            (g+g_fr)/ttm*vm_fr^2 + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*casadi.cos(va_fr-va_to)) + (-b*tr-g*ti)/ttm*(vm_fr*vm_to*casadi.sin(va_fr-va_to)) - p_fr
        )
        push!(
            cons,
            -(b+b_fr)/ttm*vm_fr^2 - (-b*tr-g*ti)/ttm*(vm_fr*vm_to*casadi.cos(va_fr-va_to)) + (-g*tr+b*ti)/ttm*(vm_fr*vm_to*casadi.sin(va_fr-va_to)) - q_fr
        )
        push!(
            cons,
            (g+g_to)*vm_to^2 + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*casadi.cos(va_to-va_fr)) + (-b*tr+g*ti)/ttm*(vm_to*vm_fr*casadi.sin(va_to-va_fr)) - p_to
        )
        push!(
            cons,
            -(b+b_to)*vm_to^2 - (-b*tr+g*ti)/ttm*(vm_to*vm_fr*casadi.cos(va_to-va_fr)) + (-g*tr-b*ti)/ttm*(vm_to*vm_fr*casadi.sin(va_to-va_fr)) - q_to
        )
        for i in 1:4
            push!(lbg, 0)
            push!(ubg, 0)
        end
        push!(cons, va_fr - va_to)
        push!(lbg, branch[&quot;angmin&quot;])
        push!(ubg, branch[&quot;angmax&quot;])
        push!(cons, p_fr^2 + q_fr^2)
        push!(lbg, -casadi.inf)
        push!(ubg, branch[&quot;rate_a&quot;]^2)
        push!(cons, p_to^2 + q_to^2)
        push!(lbg, -casadi.inf)
        push!(ubg, branch[&quot;rate_a&quot;]^2)
    end

    nlp = Dict(&quot;x&quot; =&gt; casadi.vcat(x), &quot;f&quot; =&gt; f, &quot;g&quot; =&gt; casadi.vcat(cons))
    options = PythonCall.pydict(Dict(&quot;error_on_fail&quot; =&gt; true))
    model = casadi.nlpsol(&quot;model&quot;, &quot;ipopt&quot;, PythonCall.pydict(nlp), options)

    model_variables = length(x)
    model_constraints = length(lbg)

    model_build_time = time() - time_model_start

    time_solve_start = time()
    solution = model(; lbx = lbx, ubx = ubx, lbg = lbg, ubg = ubg, x0 = x0)
    cost = PythonCall.pyconvert(Float64, (PythonCall.pyfloat(solution[&quot;f&quot;])))
    feasible = true # error if not feasible

    solve_time = time() - time_solve_start
    total_time = time() - time_data_start

    println(&quot;&quot;)
    println(&quot;\033[1mSummary\033[0m&quot;)
    println(&quot;   case........: $(file_name)&quot;)
    println(&quot;   variables...: $(model_variables)&quot;)
    println(&quot;   constraints.: $(model_constraints)&quot;)
    println(&quot;   feasible....: $(feasible)&quot;)
    println(&quot;   cost........: $(round(Int, cost))&quot;)
    println(&quot;   total time..: $(total_time)&quot;)
    println(&quot;     data time.: $(data_load_time)&quot;)
    println(&quot;     build time: $(model_build_time)&quot;)
    println(&quot;     solve time: $(solve_time)&quot;)
    # println(&quot;      callbacks: $(total_callback_time)&quot;)
    println(&quot;&quot;)

    return Dict(
        &quot;case&quot; =&gt; file_name,
        &quot;variables&quot; =&gt; model_variables,
        &quot;constraints&quot; =&gt; model_constraints,
        &quot;feasible&quot; =&gt; feasible,
        &quot;cost&quot; =&gt; cost,
        &quot;time_total&quot; =&gt; total_time,
        &quot;time_data&quot; =&gt; data_load_time,
        &quot;time_build&quot; =&gt; model_build_time,
        &quot;time_solve&quot; =&gt; solve_time,
        #&quot;time_callbacks&quot; =&gt; TBD,
    )
end

solve_opf_casadi(&quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;)</code></pre><h2 id="Test-the-Benchmarking"><a class="docs-heading-anchor" href="#Test-the-Benchmarking">Test the Benchmarking</a><a id="Test-the-Benchmarking-1"></a><a class="docs-heading-anchor-permalink" href="#Test-the-Benchmarking" title="Permalink"></a></h2><pre><code class="language-julia hljs">file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optimization(dataset);
res</code></pre><pre><code class="nohighlight hljs">***************************************************************************
***
This program contains Ipopt, a library for large-scale nonlinear optimizati
on.
 Ipopt is released as open source code under the Eclipse Public License (EP
L).
         For more information visit https://github.com/coin-or/Ipopt
***************************************************************************
***

Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.000179159
  &quot;time_solve_compilation&quot; =&gt; 44.7918
  &quot;time_solve&quot;             =&gt; 0.664806
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_jump(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 2.87675
  &quot;time_solve_compilation&quot; =&gt; 0.901542
  &quot;time_solve&quot;             =&gt; 0.0179817
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nlpmodels(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 1.01253
  &quot;time_solve_compilation&quot; =&gt; 3.38473
  &quot;time_solve&quot;             =&gt; 0.0377214
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nonconvex(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 17551.9
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 59
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.127579
  &quot;time_solve_compilation&quot; =&gt; 113.452
  &quot;time_solve&quot;             =&gt; 1.38915
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optim(dataset);
res</code></pre><pre><code class="nohighlight hljs">Iter     Lagrangian value Function value   Gradient norm    |==constr.|    
  μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16   
  7.89e+14
 * time: 1.694602877452421e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16   
  2.59e+14
 * time: 1.694602881810158e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16   
  1.58e+14
 * time: 1.694602882446373e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16   
  8.46e+13
 * time: 1.694602883104443e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16   
  9.24e+13
 * time: 1.69460288374175e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16   
  1.59e+14
 * time: 1.694602884376572e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16   
  2.74e+14
 * time: 1.694602885004686e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17   
  2.63e+14
 * time: 1.694602885663528e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17   
  2.27e+14
 * time: 1.694602886297157e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17   
  2.01e+14
 * time: 1.694602886932322e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17   
  1.91e+14
 * time: 1.694602887567395e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17   
  1.65e+14
 * time: 1.694602888224621e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17   
  1.51e+14
 * time: 1.694602888856475e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17   
  1.49e+14
 * time: 1.694602889490952e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17   
  1.76e+14
 * time: 1.694602890126104e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17   
  1.83e+14
 * time: 1.694602890784382e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17   
  1.75e+14
 * time: 1.694602891417055e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17   
  1.14e+14
 * time: 1.694602892051305e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17   
  1.01e+14
 * time: 1.694602892686415e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17   
  8.05e+13
 * time: 1.6946028933217e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17   
  4.61e+13
 * time: 1.69460289397695e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17   
  2.40e+13
 * time: 1.694602894609729e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17   
  2.16e+13
 * time: 1.694602895243108e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17   
  1.86e+13
 * time: 1.694602895878983e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17   
  1.51e+13
 * time: 1.694602896536037e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17   
  1.09e+13
 * time: 1.694602897168469e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17   
  7.96e+12
 * time: 1.69460289780313e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17   
  5.51e+12
 * time: 1.694602898436752e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17   
  3.47e+12
 * time: 1.694602899092933e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17   
  2.09e+12
 * time: 1.694602899726265e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17   
  3.23e+12
 * time: 1.694602899949854e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|    
  μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16   
  7.89e+14
 * time: 1.694602901134114e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16   
  2.59e+14
 * time: 1.694602901767318e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16   
  1.58e+14
 * time: 1.694602902402145e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16   
  8.46e+13
 * time: 1.694602903060538e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16   
  9.24e+13
 * time: 1.694602903691813e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16   
  1.59e+14
 * time: 1.694602904330813e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16   
  2.74e+14
 * time: 1.694602904959188e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17   
  2.63e+14
 * time: 1.694602905594896e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17   
  2.27e+14
 * time: 1.694602906250088e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17   
  2.01e+14
 * time: 1.694602906879849e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17   
  1.91e+14
 * time: 1.694602907511852e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17   
  1.65e+14
 * time: 1.694602908143876e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17   
  1.51e+14
 * time: 1.694602908798503e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17   
  1.49e+14
 * time: 1.694602909428204e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17   
  1.76e+14
 * time: 1.694602910059865e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17   
  1.83e+14
 * time: 1.694602910691821e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17   
  1.75e+14
 * time: 1.694602911346514e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17   
  1.14e+14
 * time: 1.694602911974371e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17   
  1.01e+14
 * time: 1.69460291260532e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17   
  8.05e+13
 * time: 1.694602913236085e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17   
  4.61e+13
 * time: 1.694602913890518e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17   
  2.40e+13
 * time: 1.69460291451874e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17   
  2.16e+13
 * time: 1.694602915148585e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17   
  1.86e+13
 * time: 1.694602915780006e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17   
  1.51e+13
 * time: 1.694602916435204e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17   
  1.09e+13
 * time: 1.694602917078029e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17   
  7.96e+12
 * time: 1.694602917708374e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17   
  5.51e+12
 * time: 1.694602918340106e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17   
  3.47e+12
 * time: 1.694602918973151e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17   
  2.09e+12
 * time: 1.694602919636023e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17   
  3.23e+12
 * time: 1.694602919858454e9
Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 77.9548
  &quot;variables&quot;              =&gt; 44
  &quot;constraints&quot;            =&gt; 53
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.000551664
  &quot;time_solve_compilation&quot; =&gt; 30.0642
  &quot;time_solve&quot;             =&gt; 19.9086
  &quot;feasible&quot;               =&gt; false</code></pre><pre><code class="language-julia hljs">file_name = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
dataset = load_and_setup_data(file_name);</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optimization(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 8.3059e-5
  &quot;time_solve_compilation&quot; =&gt; 5.07572
  &quot;time_solve&quot;             =&gt; 0.160885
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_jump(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.00167281
  &quot;time_solve_compilation&quot; =&gt; 0.00974476
  &quot;time_solve&quot;             =&gt; 0.00873307
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nlpmodels(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.0141156
  &quot;time_solve_compilation&quot; =&gt; 0.0200323
  &quot;time_solve&quot;             =&gt; 0.0512326
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_nonconvex(dataset);
res</code></pre><pre><code class="nohighlight hljs">Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 5812.64
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 31
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.0194634
  &quot;time_solve_compilation&quot; =&gt; 3.90085
  &quot;time_solve&quot;             =&gt; 0.70686
  &quot;feasible&quot;               =&gt; true</code></pre><pre><code class="language-julia hljs">model, res = solve_opf_optim(dataset);
res</code></pre><pre><code class="nohighlight hljs">Iter     Lagrangian value Function value   Gradient norm    |==constr.|    
  μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05   
  6.55e+00
 * time: 1.694602930322152e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03   
  6.55e-01
 * time: 1.694602930445511e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03   
  1.03e+00
 * time: 1.694602930560678e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03   
  3.43e-01
 * time: 1.694602930677787e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03   
  2.84e-01
 * time: 1.694602930794559e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03   
  2.21e-01
 * time: 1.69460293091131e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03   
  1.78e-01
 * time: 1.694602931050379e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03   
  1.46e-01
 * time: 1.694602931166698e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02   
  1.20e-01
 * time: 1.694602931282805e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02   
  9.98e-02
 * time: 1.694602931399477e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02   
  8.41e-02
 * time: 1.694602931514647e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02   
  4.28e-01
 * time: 1.694602931629768e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02   
  5.28e-01
 * time: 1.694602931762396e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02   
  5.28e-01
 * time: 1.694602931891943e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02   
  5.28e-01
 * time: 1.694602932041887e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02   
  5.28e-01
 * time: 1.69460293217632e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02   
  5.28e-01
 * time: 1.69460293231941e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02   
  5.28e-01
 * time: 1.694602932397429e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|    
  μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05   
  6.55e+00
 * time: 1.694602932616588e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03   
  6.55e-01
 * time: 1.694602932731667e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03   
  1.03e+00
 * time: 1.694602932846821e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03   
  3.43e-01
 * time: 1.69460293296483e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03   
  2.84e-01
 * time: 1.694602933082172e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03   
  2.21e-01
 * time: 1.694602933198936e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03   
  1.78e-01
 * time: 1.694602933315522e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03   
  1.46e-01
 * time: 1.694602933432183e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02   
  1.20e-01
 * time: 1.694602933571376e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02   
  9.98e-02
 * time: 1.694602933687815e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02   
  8.41e-02
 * time: 1.694602933802484e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02   
  4.28e-01
 * time: 1.694602933917089e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02   
  5.28e-01
 * time: 1.694602934048482e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02   
  5.28e-01
 * time: 1.694602934179181e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02   
  5.28e-01
 * time: 1.694602934308307e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02   
  5.28e-01
 * time: 1.694602934470139e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02   
  5.28e-01
 * time: 1.694602934612485e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02   
  5.28e-01
 * time: 1.694602934691506e9
Dict{String, Any} with 8 entries:
  &quot;cost&quot;                   =&gt; 6273.63
  &quot;variables&quot;              =&gt; 24
  &quot;constraints&quot;            =&gt; 28
  &quot;case&quot;                   =&gt; &quot;../../benchmarks/OptimizationFrameworks/opf_
data…
  &quot;time_build&quot;             =&gt; 0.0576262
  &quot;time_solve_compilation&quot; =&gt; 2.31406
  &quot;time_solve&quot;             =&gt; 2.29408
  &quot;feasible&quot;               =&gt; false</code></pre><pre><code class="language-julia hljs">using DataFrames, PrettyTables

function multidata_multisolver_benchmark(dataset_files; sizelimit = 100)

    cases = String[]
    vars = Int[]
    cons = Int[]

    optimization_time = Float64[]
    jump_time = Float64[]
    nlpmodels_time = Float64[]
    nonconvex_time = Float64[]
    optim_time = Float64[]

    optimization_time_modelbuild = Float64[]
    jump_time_modelbuild = Float64[]
    nlpmodels_time_modelbuild = Float64[]
    nonconvex_time_modelbuild = Float64[]
    optim_time_modelbuild = Float64[]

    optimization_time_compilation = Float64[]
    jump_time_compilation = Float64[]
    nlpmodels_time_compilation = Float64[]
    nonconvex_time_compilation = Float64[]
    optim_time_compilation = Float64[]

    optimization_cost = Float64[]
    jump_cost = Float64[]
    nlpmodels_cost = Float64[]
    nonconvex_cost = Float64[]
    optim_cost = Float64[]

    for file in dataset_files
        @show file
        dataset = load_and_setup_data(file)

        prob = build_opf_optimization_prob(dataset)
        @info &quot;Number of Variables: $(length(prob.u0))&quot;
        @info &quot;Number of Constraints: $(length(prob.lcons))&quot;

        if length(prob.u0) &gt; sizelimit
            @info &quot;Variable size over limit. Skipping for now&quot;
            continue
        end
        
        model, res = solve_opf_optimization(dataset)
        push!(cases, split(res[&quot;case&quot;],&quot;/&quot;)[end])
        push!(vars, res[&quot;variables&quot;])
        push!(cons, res[&quot;constraints&quot;])
        push!(optimization_time, res[&quot;time_solve&quot;])
        push!(optimization_time_modelbuild, res[&quot;time_build&quot;])
        push!(optimization_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(optimization_cost, res[&quot;cost&quot;])

        model, res = solve_opf_jump(dataset)
        push!(jump_time, res[&quot;time_solve&quot;])
        push!(jump_time_modelbuild, res[&quot;time_build&quot;])
        push!(jump_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(jump_cost, res[&quot;cost&quot;])

        model, res = solve_opf_nlpmodels(dataset)
        push!(nlpmodels_time, res[&quot;time_solve&quot;])
        push!(nlpmodels_time_modelbuild, res[&quot;time_build&quot;])
        push!(nlpmodels_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(nlpmodels_cost, res[&quot;cost&quot;])
        
        model, res = solve_opf_nonconvex(dataset)
        push!(nonconvex_time, res[&quot;time_solve&quot;])
        push!(nonconvex_time_modelbuild, res[&quot;time_build&quot;])
        push!(nonconvex_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(nonconvex_cost, res[&quot;cost&quot;])

        model, res = solve_opf_optim(dataset)
        push!(optim_time, res[&quot;time_solve&quot;])
        push!(optim_time_modelbuild, res[&quot;time_build&quot;])
        push!(optim_time_compilation, res[&quot;time_solve_compilation&quot;])
        push!(optim_cost, res[&quot;cost&quot;])
    end
    DataFrame(:case =&gt; cases, :vars =&gt; vars, :cons =&gt; cons, 
              :optimization =&gt; optimization_time, :optimization_modelbuild =&gt; optimization_time_modelbuild, :optimization_wcompilation =&gt; optimization_time_compilation, :optimization_cost =&gt; optimization_cost,
              :jump =&gt; jump_time, :jump_modelbuild =&gt; jump_time_modelbuild, :jump_wcompilation =&gt; jump_time_compilation, :jump_cost =&gt; jump_cost, 
              :nlpmodels =&gt; nlpmodels_time, :nlpmodels_modelbuild =&gt; nlpmodels_time_modelbuild, :nlpmodels_wcompilation =&gt; nlpmodels_time_compilation,  :nlpmodels_cost =&gt; nlpmodels_cost, 
              :nonconvex =&gt; nonconvex_time, :nonconvex_modelbuild =&gt; nonconvex_time_modelbuild, :nonconvex_wcompilation =&gt; nonconvex_time_compilation,  :nonconvex_cost =&gt; nonconvex_cost,
              :optim =&gt; optim_time, :optim_modelbuild =&gt; optim_time_modelbuild, :optim_wcompilation =&gt; optim_time_compilation,  :optim_cost =&gt; optim_cost)
end

test_datasets = [
    &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;,
    &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
    ]</code></pre><pre><code class="nohighlight hljs">2-element Vector{String}:
 &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
 &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;</code></pre><pre><code class="language-julia hljs">timing_data = multidata_multisolver_benchmark(test_datasets)</code></pre><pre><code class="nohighlight hljs">file = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case3_lmbd.m&quot;
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05     6.55e+00
 * time: 1.694602970415567e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03     6.55e-01
 * time: 1.694602973524225e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03     1.03e+00
 * time: 1.694602973640026e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03     3.43e-01
 * time: 1.694602973758326e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03     2.84e-01
 * time: 1.694602973876465e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03     2.21e-01
 * time: 1.694602973994926e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03     1.78e-01
 * time: 1.694602974113587e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03     1.46e-01
 * time: 1.694602974232613e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02     1.20e-01
 * time: 1.694602974351075e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02     9.98e-02
 * time: 1.694602974469232e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02     8.41e-02
 * time: 1.694602974585261e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02     4.28e-01
 * time: 1.69460297470131e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02     5.28e-01
 * time: 1.694602974855968e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02     5.28e-01
 * time: 1.694602974985278e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02     5.28e-01
 * time: 1.694602975117077e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02     5.28e-01
 * time: 1.694602975253241e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02     5.28e-01
 * time: 1.694602975417741e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02     5.28e-01
 * time: 1.694602975476894e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05     6.55e+00
 * time: 1.694602975698505e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03     6.55e-01
 * time: 1.694602975814745e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03     1.03e+00
 * time: 1.694602975931063e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03     3.43e-01
 * time: 1.69460297607185e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03     2.84e-01
 * time: 1.694602976189386e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03     2.21e-01
 * time: 1.694602976307195e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03     1.78e-01
 * time: 1.694602976425042e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03     1.46e-01
 * time: 1.694602976543391e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02     1.20e-01
 * time: 1.694602976662337e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02     9.98e-02
 * time: 1.694602976781341e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02     8.41e-02
 * time: 1.694602976897735e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02     4.28e-01
 * time: 1.694602977014115e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02     5.28e-01
 * time: 1.694602977146377e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02     5.28e-01
 * time: 1.69460297729886e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02     5.28e-01
 * time: 1.694602977428673e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02     5.28e-01
 * time: 1.694602977566527e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02     5.28e-01
 * time: 1.694602977732105e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02     5.28e-01
 * time: 1.694602977790306e9
file = &quot;../../benchmarks/OptimizationFrameworks/opf_data/pglib_opf_case5_pjm.m&quot;
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16     7.89e+14
 * time: 1.694602986156171e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16     2.59e+14
 * time: 1.694602986800759e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16     1.58e+14
 * time: 1.69460298744688e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16     8.46e+13
 * time: 1.694602988114906e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16     9.24e+13
 * time: 1.694602988756902e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16     1.59e+14
 * time: 1.694602989395701e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16     2.74e+14
 * time: 1.694602990033104e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17     2.63e+14
 * time: 1.694602990702471e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17     2.27e+14
 * time: 1.694602991344195e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17     2.01e+14
 * time: 1.69460299198738e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17     1.91e+14
 * time: 1.694602992628316e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17     1.65e+14
 * time: 1.694602993297542e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17     1.51e+14
 * time: 1.694602993936014e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17     1.49e+14
 * time: 1.694602994577562e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17     1.76e+14
 * time: 1.694602995219295e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17     1.83e+14
 * time: 1.694602995865681e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17     1.75e+14
 * time: 1.694602996531766e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17     1.14e+14
 * time: 1.694602997173205e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17     1.01e+14
 * time: 1.694602997815346e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17     8.05e+13
 * time: 1.69460299845954e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17     4.61e+13
 * time: 1.694602999127426e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17     2.40e+13
 * time: 1.694602999768093e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17     2.16e+13
 * time: 1.694603000410048e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17     1.86e+13
 * time: 1.694603001052595e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17     1.51e+13
 * time: 1.694603001719587e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17     1.09e+13
 * time: 1.69460300236715e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17     7.96e+12
 * time: 1.694603003008561e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17     5.51e+12
 * time: 1.694603003650335e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17     3.47e+12
 * time: 1.694603004318274e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17     2.09e+12
 * time: 1.694603004957018e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17     3.23e+12
 * time: 1.6946030051876e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16     7.89e+14
 * time: 1.694603006381768e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16     2.59e+14
 * time: 1.694603007023121e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16     1.58e+14
 * time: 1.694603007663967e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16     8.46e+13
 * time: 1.694603008331641e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16     9.24e+13
 * time: 1.694603008971413e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16     1.59e+14
 * time: 1.694603009631049e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16     2.74e+14
 * time: 1.694603010268005e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17     2.63e+14
 * time: 1.69460301091113e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17     2.27e+14
 * time: 1.694603011579289e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17     2.01e+14
 * time: 1.694603012219871e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17     1.91e+14
 * time: 1.694603012860406e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17     1.65e+14
 * time: 1.694603013503564e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17     1.51e+14
 * time: 1.694603014171076e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17     1.49e+14
 * time: 1.694603014811983e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17     1.76e+14
 * time: 1.694603015453345e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17     1.83e+14
 * time: 1.694603016095712e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17     1.75e+14
 * time: 1.694603016763767e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17     1.14e+14
 * time: 1.694603017413289e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17     1.01e+14
 * time: 1.694603018055909e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17     8.05e+13
 * time: 1.694603018696479e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17     4.61e+13
 * time: 1.694603019366462e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17     2.40e+13
 * time: 1.694603020007258e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17     2.16e+13
 * time: 1.694603020649734e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17     1.86e+13
 * time: 1.694603021292027e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17     1.51e+13
 * time: 1.694603021937143e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17     1.09e+13
 * time: 1.694603022602302e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17     7.96e+12
 * time: 1.694603023242273e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17     5.51e+12
 * time: 1.694603023883967e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17     3.47e+12
 * time: 1.694603024527636e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17     2.09e+12
 * time: 1.694603025207631e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17     3.23e+12
 * time: 1.694603025437386e9
2×23 DataFrame
 Row │ case                    vars   cons   optimization  optimization_modelb ⋯
     │ String                  Int64  Int64  Float64       Float64             ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ pglib_opf_case3_lmbd.m     24     28      0.159684                5.592 ⋯
   2 │ pglib_opf_case3_lmbd.m     44     53      0.674099                4.791
                                                              19 columns omitted</code></pre><pre><code class="language-julia hljs">pretty_table(timing_data)</code></pre><p>┌────────────────────────┬───────┬───────┬──────────────┬─────────────────────────┬───────────────────────────┬───────────────────┬───────────┬─────────────────┬───────────────────┬───────────┬───────────┬──────────────────────┬────────────────────────┬────────────────┬───────────┬──────────────────────┬────────────────────────┬────────────────┬─────────┬──────────────────┬────────────────────┬────────────┐ │                   case │  vars │  cons │ optimization │ optimization<em>modelbuild │ optimization</em>wcompilation │ optimization<em>cost │      jump │ jump</em>modelbuild │ jump<em>wcompilation │ jump</em>cost │ nlpmodels │ nlpmodels<em>modelbuild │ nlpmodels</em>wcompilation │ nlpmodels<em>cost │ nonconvex │ nonconvex</em>modelbuild │ nonconvex<em>wcompilation │ nonconvex</em>cost │   optim │ optim<em>modelbuild │ optim</em>wcompilation │ optim<em>cost │ │                 String │ Int64 │ Int64 │      Float64 │                 Float64 │                   Float64 │           Float64 │   Float64 │         Float64 │           Float64 │   Float64 │   Float64 │              Float64 │                Float64 │        Float64 │   Float64 │              Float64 │                Float64 │        Float64 │ Float64 │          Float64 │            Float64 │    Float64 │ ├────────────────────────┼───────┼───────┼──────────────┼─────────────────────────┼───────────────────────────┼───────────────────┼───────────┼─────────────────┼───────────────────┼───────────┼───────────┼──────────────────────┼────────────────────────┼────────────────┼───────────┼──────────────────────┼────────────────────────┼────────────────┼─────────┼──────────────────┼────────────────────┼────────────┤ │ pglib</em>opf<em>case3</em>lmbd.m │    24 │    28 │     0.159684 │               5.5929e-5 │                  0.448048 │           5812.64 │ 0.0086702 │      0.00168752 │        0.00957737 │   5812.64 │ 0.0184414 │              4.79234 │               0.514072 │        5812.64 │  0.716496 │              3.13606 │                2.82488 │        5812.64 │ 2.31341 │      0.000476816 │            8.93353 │    6273.63 │ │ pglib<em>opf</em>case3_lmbd.m │    44 │    53 │     0.674099 │                4.791e-5 │                  0.695703 │           17551.9 │  0.017551 │      0.00174382 │         0.0183168 │   17551.9 │ 0.0639197 │            0.0238398 │              0.0404386 │        17551.9 │   1.34627 │            0.0902744 │                4.20403 │        17551.9 │ 20.2498 │      0.000377287 │            20.2166 │    77.9548 │ └────────────────────────┴───────┴───────┴──────────────┴─────────────────────────┴───────────────────────────┴───────────────────┴───────────┴─────────────────┴───────────────────┴───────────┴───────────┴──────────────────────┴────────────────────────┴────────────────┴───────────┴──────────────────────┴────────────────────────┴────────────────┴─────────┴──────────────────┴────────────────────┴────────────┘</p><h2 id="Run-the-Full-Benchmark"><a class="docs-heading-anchor" href="#Run-the-Full-Benchmark">Run the Full Benchmark</a><a id="Run-the-Full-Benchmark-1"></a><a class="docs-heading-anchor-permalink" href="#Run-the-Full-Benchmark" title="Permalink"></a></h2><pre><code class="language-julia hljs">using LibGit2
tmpdir = Base.Filesystem.mktempdir()
LibGit2.clone(&quot;https://github.com/power-grid-lib/pglib-opf&quot;, tmpdir)
benchmarkfiles = readdir(tmpdir)
benchmarkfiles = benchmarkfiles[endswith(&quot;.m&quot;).(benchmarkfiles)]
benchmark_datasets = joinpath.((tmpdir,),benchmarkfiles)</code></pre><pre><code class="nohighlight hljs">66-element Vector{String}:
 &quot;/tmp/jl_UVcMT2/pglib_opf_case10000_goc.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case10192_epigrids.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case10480_goc.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case118_ieee.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case1354_pegase.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case13659_pegase.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case14_ieee.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case162_ieee_dtc.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case179_goc.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case1803_snem.m&quot;
 ⋮
 &quot;/tmp/jl_UVcMT2/pglib_opf_case6515_rte.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case7336_epigrids.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case73_ieee_rts.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case78484_epigrids.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case793_goc.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case8387_pegase.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case89_pegase.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case9241_pegase.m&quot;
 &quot;/tmp/jl_UVcMT2/pglib_opf_case9591_goc.m&quot;</code></pre><pre><code class="language-julia hljs">timing_data = multidata_multisolver_benchmark(benchmark_datasets)</code></pre><pre><code class="nohighlight hljs">file = &quot;/tmp/jl_UVcMT2/pglib_opf_case10000_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case10192_epigrids.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case10480_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case118_ieee.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case1354_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case13659_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case14_ieee.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case162_ieee_dtc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case179_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case1803_snem.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case1888_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case19402_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case1951_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case197_snem.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2000_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case200_activ.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case20758_epigrids.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2312_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2383wp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case240_pserc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case24464_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case24_ieee_rts.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2736sp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2737sop_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2742_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2746wop_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2746wp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2848_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2853_sdet.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2868_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case2869_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case30000_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case300_ieee.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3012wp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3022_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case30_as.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case30_ieee.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3120sp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3375wp_k.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3970_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case39_epri.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case3_lmbd.m&quot;
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05     6.55e+00
 * time: 1.694603109174144e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03     6.55e-01
 * time: 1.694603109270819e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03     1.03e+00
 * time: 1.694603109369138e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03     3.43e-01
 * time: 1.694603109464947e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03     2.84e-01
 * time: 1.694603109560894e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03     2.21e-01
 * time: 1.694603109728875e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03     1.78e-01
 * time: 1.694603109831665e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03     1.46e-01
 * time: 1.69460310992874e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02     1.20e-01
 * time: 1.694603110031098e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02     9.98e-02
 * time: 1.694603110126594e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02     8.41e-02
 * time: 1.694603110220233e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02     4.28e-01
 * time: 1.694603110313557e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02     5.28e-01
 * time: 1.694603110491961e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02     5.28e-01
 * time: 1.694603110605876e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02     5.28e-01
 * time: 1.694603110715205e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02     5.28e-01
 * time: 1.694603110836151e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02     5.28e-01
 * time: 1.694603110956349e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02     5.28e-01
 * time: 1.694603111015029e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -1.332793e+05    2.012000e+05     1.452933e+03     3.337912e+05     6.55e+00
 * time: 1.694603111261894e9
     1   3.871159e+03     1.384170e+04     1.848863e+03     9.912224e+03     6.55e-01
 * time: 1.694603111360197e9
     2   4.987679e+03     1.025073e+04     4.608072e+02     5.168011e+03     1.03e+00
 * time: 1.694603111456098e9
     3   5.334802e+03     9.051079e+03     5.889282e+02     3.685359e+03     3.43e-01
 * time: 1.694603111554625e9
     4   5.509669e+03     8.156831e+03     5.818415e+02     2.622187e+03     2.84e-01
 * time: 1.694603111655075e9
     5   5.602026e+03     7.589242e+03     6.207632e+02     1.968189e+03     2.21e-01
 * time: 1.69460311175082e9
     6   5.655170e+03     7.200137e+03     6.569763e+02     1.529936e+03     1.78e-01
 * time: 1.694603111846481e9
     7   5.689681e+03     6.906897e+03     6.817978e+02     1.205104e+03     1.46e-01
 * time: 1.694603111941794e9
     8   5.713434e+03     6.680810e+03     6.964722e+02     9.575828e+02     1.20e-01
 * time: 1.694603112105549e9
     9   5.729766e+03     6.517382e+03     7.044579e+02     7.796863e+02     9.98e-02
 * time: 1.694603112207753e9
    10   5.750961e+03     6.289108e+03     1.247805e+04     5.324717e+02     8.41e-02
 * time: 1.694603112302913e9
    11   5.736646e+03     6.273828e+03     2.371472e+05     5.109277e+02     4.28e-01
 * time: 1.694603112403524e9
    12   5.730447e+03     6.273790e+03     2.608217e+05     5.108370e+02     5.28e-01
 * time: 1.694603112513449e9
    13   5.730414e+03     6.273714e+03     2.069287e+05     5.106566e+02     5.28e-01
 * time: 1.694603112620894e9
    14   5.730417e+03     6.273637e+03     1.730478e+05     5.104764e+02     5.28e-01
 * time: 1.694603112728142e9
    15   5.730433e+03     6.273627e+03     1.696171e+05     5.104538e+02     5.28e-01
 * time: 1.694603112913095e9
    16   5.730435e+03     6.273626e+03     1.691994e+05     5.104510e+02     5.28e-01
 * time: 1.694603113037552e9
    17   5.730436e+03     6.273626e+03     1.691980e+05     5.104510e+02     5.28e-01
 * time: 1.694603113097223e9
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4020_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4601_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4619_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4661_sdet.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4837_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case4917_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case500_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case5658_epigrids.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case57_ieee.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case588_sdet.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case5_pjm.m&quot;
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16     7.89e+14
 * time: 1.694603127156394e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16     2.59e+14
 * time: 1.694603127736953e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16     1.58e+14
 * time: 1.694603128235154e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16     8.46e+13
 * time: 1.694603128825544e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16     9.24e+13
 * time: 1.694603129407187e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16     1.59e+14
 * time: 1.69460312998347e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16     2.74e+14
 * time: 1.694603130472415e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17     2.63e+14
 * time: 1.694603131123781e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17     2.27e+14
 * time: 1.694603131705635e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17     2.01e+14
 * time: 1.694603132286746e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17     1.91e+14
 * time: 1.694603132874325e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17     1.65e+14
 * time: 1.694603133372445e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17     1.51e+14
 * time: 1.694603133976704e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17     1.49e+14
 * time: 1.694603134560367e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17     1.76e+14
 * time: 1.694603135159503e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17     1.83e+14
 * time: 1.69460313574672e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17     1.75e+14
 * time: 1.694603136238981e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17     1.14e+14
 * time: 1.694603136827686e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17     1.01e+14
 * time: 1.694603137410859e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17     8.05e+13
 * time: 1.694603137992698e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17     4.61e+13
 * time: 1.694603138488233e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17     2.40e+13
 * time: 1.694603139098989e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17     2.16e+13
 * time: 1.694603139694244e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17     1.86e+13
 * time: 1.694603140279036e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17     1.51e+13
 * time: 1.694603140865276e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17     1.09e+13
 * time: 1.694603141360274e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17     7.96e+12
 * time: 1.694603141950028e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17     5.51e+12
 * time: 1.694603142534238e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17     3.47e+12
 * time: 1.69460314311655e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17     2.09e+12
 * time: 1.694603143617564e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17     3.23e+12
 * time: 1.694603143938845e9
Iter     Lagrangian value Function value   Gradient norm    |==constr.|      μ
     0   -6.806002e+16    1.635500e+04     9.027326e+15     1.196696e+16     7.89e+14
 * time: 1.694603144950108e9
     1   -5.653618e+16    1.239424e+04     2.048354e+16     3.866281e+16     2.59e+14
 * time: 1.694603145534557e9
     2   -6.312953e+16    9.504854e+03     2.472419e+16     5.295854e+16     1.58e+14
 * time: 1.69460314611695e9
     3   -6.963967e+16    6.629948e+03     3.379787e+16     6.480692e+16     8.46e+13
 * time: 1.694603146702847e9
     4   -8.019084e+16    4.225763e+03     5.796137e+16     7.583884e+16     9.24e+13
 * time: 1.694603147197365e9
     5   -9.003775e+16    3.427203e+03     8.262621e+16     8.352453e+16     1.59e+14
 * time: 1.694603147784914e9
     6   -1.036563e+17    2.990479e+03     1.206177e+17     9.343366e+16     2.74e+14
 * time: 1.694603148373958e9
     7   -1.201133e+17    2.937273e+03     1.748921e+17     1.107859e+17     2.63e+14
 * time: 1.694603148955207e9
     8   -1.298488e+17    2.891923e+03     2.008420e+17     1.222013e+17     2.27e+14
 * time: 1.694603149451806e9
     9   -1.359597e+17    2.835253e+03     2.136709e+17     1.295591e+17     2.01e+14
 * time: 1.694603150064274e9
    10   -1.405817e+17    2.759768e+03     2.223574e+17     1.349031e+17     1.91e+14
 * time: 1.694603150645709e9
    11   -1.437112e+17    2.658988e+03     2.290012e+17     1.392006e+17     1.65e+14
 * time: 1.694603151224634e9
    12   -1.464692e+17    2.516357e+03     2.368001e+17     1.428086e+17     1.51e+14
 * time: 1.694603151806595e9
    13   -1.488184e+17    2.322116e+03     2.482098e+17     1.457502e+17     1.49e+14
 * time: 1.694603152298674e9
    14   -1.515591e+17    2.184809e+03     2.565629e+17     1.484211e+17     1.76e+14
 * time: 1.694603152895586e9
    15   -1.544486e+17    2.042027e+03     2.516699e+17     1.517197e+17     1.83e+14
 * time: 1.694603153475739e9
    16   -1.564462e+17    1.971423e+03     2.431387e+17     1.541470e+17     1.75e+14
 * time: 1.694603154054126e9
    17   -1.571498e+17    1.897328e+03     2.080075e+17     1.558652e+17     1.14e+14
 * time: 1.694603154549443e9
    18   -1.585181e+17    1.779351e+03     1.905178e+17     1.576816e+17     1.01e+14
 * time: 1.694603155174248e9
    19   -1.602408e+17    1.613097e+03     1.793373e+17     1.599373e+17     8.05e+13
 * time: 1.694603155756043e9
    20   -1.619481e+17    1.438560e+03     1.854662e+17     1.620090e+17     4.61e+13
 * time: 1.694603156337e9
    21   -1.633753e+17    1.273718e+03     1.923713e+17     1.635305e+17     2.40e+13
 * time: 1.69460315692663e9
    22   -1.647239e+17    1.079019e+03     1.841617e+17     1.650091e+17     2.16e+13
 * time: 1.694603157421783e9
    23   -1.661138e+17    8.558663e+02     1.739263e+17     1.665270e+17     1.86e+13
 * time: 1.694603158007169e9
    24   -1.676187e+17    6.038961e+02     1.598350e+17     1.681490e+17     1.51e+13
 * time: 1.694603158589091e9
    25   -1.686664e+17    4.324137e+02     1.559112e+17     1.691788e+17     1.09e+13
 * time: 1.69460315916883e9
    26   -1.694824e+17    2.958285e+02     1.532171e+17     1.699581e+17     7.96e+12
 * time: 1.694603159665008e9
    27   -1.701523e+17    1.844768e+02     1.519071e+17     1.705673e+17     5.51e+12
 * time: 1.694603160291816e9
    28   -1.706362e+17    1.110139e+02     1.568218e+17     1.709533e+17     3.47e+12
 * time: 1.694603160874325e9
    29   -1.708669e+17    7.795483e+01     1.709948e+17     1.710819e+17     2.09e+12
 * time: 1.69460316145989e9
    30   -1.707499e+17    7.795483e+01     1.390829e+17     1.710819e+17     3.23e+12
 * time: 1.694603161636486e9
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case60_c.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case6468_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case6470_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case6495_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case6515_rte.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case7336_epigrids.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case73_ieee_rts.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case78484_epigrids.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case793_goc.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case8387_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case89_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case9241_pegase.m&quot;
file = &quot;/tmp/jl_UVcMT2/pglib_opf_case9591_goc.m&quot;
2×23 DataFrame
 Row │ case                    vars   cons   optimization  optimization_modelb ⋯
     │ String                  Int64  Int64  Float64       Float64             ⋯
─────┼──────────────────────────────────────────────────────────────────────────
   1 │ pglib_opf_case3_lmbd.m     24     28      0.200956                7.323 ⋯
   2 │ pglib_opf_case3_lmbd.m     44     53      0.649885                5.926
                                                              19 columns omitted</code></pre><pre><code class="language-julia hljs">pretty_table(timing_data; backend = Val(:html))</code></pre><p>&lt;table&gt;   &lt;thead&gt;     &lt;tr class = &quot;header&quot;&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;case&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;vars&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;cons&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optimization&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optimization<em>modelbuild&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optimization</em>wcompilation&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optimization<em>cost&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;jump&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;jump</em>modelbuild&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;jump<em>wcompilation&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;jump</em>cost&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nlpmodels&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nlpmodels<em>modelbuild&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nlpmodels</em>wcompilation&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nlpmodels<em>cost&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nonconvex&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nonconvex</em>modelbuild&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nonconvex<em>wcompilation&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;nonconvex</em>cost&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optim&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optim<em>modelbuild&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optim</em>wcompilation&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;optim<em>cost&lt;/th&gt;     &lt;/tr&gt;     &lt;tr class = &quot;subheader headerLastRow&quot;&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;String&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Int64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Int64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;       &lt;th style = &quot;text-align: right;&quot;&gt;Float64&lt;/th&gt;     &lt;/tr&gt;   &lt;/thead&gt;   &lt;tbody&gt;     &lt;tr&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;pglib</em>opf<em>case3</em>lmbd.m&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;24&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;28&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.200956&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;7.323e-5&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.131947&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;5812.64&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.00870355&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.00177076&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0094121&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;5812.64&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0187173&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0144845&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0187191&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;5812.64&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.665355&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0209947&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.604167&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;5812.64&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;2.08219&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.000308877&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;2.02208&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;6273.63&lt;/td&gt;     &lt;/tr&gt;     &lt;tr&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;pglib<em>opf</em>case3_lmbd.m&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;44&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;53&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.649885&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;5.9269e-5&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.648627&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17551.9&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0180593&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.00182187&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0190596&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17551.9&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0379589&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0246195&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0387638&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17551.9&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;1.28124&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.0863439&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;1.28286&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17551.9&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17.6976&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;0.000472726&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;17.8499&lt;/td&gt;       &lt;td style = &quot;text-align: right;&quot;&gt;77.9548&lt;/td&gt;     &lt;/tr&gt;   &lt;/tbody&gt; &lt;/table&gt;</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../Optimizaton/2drosenbrock/">« 2-Dimensional Rosenbrock Function Nonlinear Optimization Benchmark</a><a class="docs-footer-nextpage" href="../../ParameterEstimation/FitzHughNagumoParameterEstimation/">FitzHugh-Nagumo Parameter Estimation Benchmarks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Wednesday 13 September 2023 11:20">Wednesday 13 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
